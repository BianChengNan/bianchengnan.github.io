<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BianChengNan&#39;s Blog</title>
  
  <subtitle>Coding is hard, you can make it easy!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bianchengnan.github.io/"/>
  <updated>2025-12-23T13:51:14.893Z</updated>
  <id>https://bianchengnan.github.io/</id>
  
  <author>
    <name>BianChengNan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>置顶声明</title>
    <link href="https://bianchengnan.github.io//articles/top-most-announcement/"/>
    <id>https://bianchengnan.github.io//articles/top-most-announcement/</id>
    <published>2029-03-01T01:29:14.000Z</published>
    <updated>2025-12-23T13:51:14.893Z</updated>
    
    <content type="html"><![CDATA[<p>实在抱歉，因为图片使用的是 <code>http</code> 链接，在 <code>chrome</code> 或者 <code>edge</code> 浏览器中打开本博客的时候，看不到文章中的图片。</p><p>可以在 <code>chrome</code> 中通过 <code>chrome://flags</code> （在 <code>edge</code> 中通过 <code>edge://flags</code>）启用 <code>Insecure origins treated as secure</code>，</p><p>并且把图床地址 <a href="http://resources.bianchengnan.tech" target="_blank" rel="noopener">http://resources.bianchengnan.tech</a> 加入到信任列表的方式查看图片。（非常感谢群友 张帆 的提示）</p><p>整个操作如下图：</p><p><img src="http://resources.bianchengnan.tech/top-most-announcement/enable-show-image-in-chrome.png" alt="enable-show-image-in-chrome"></p><p>如果还不能查看相关图片，请联系我，或者到我的公众号里查看。</p><p>我的个人微信号是 <code>BianChengNan</code>，公众号是 <code>编程难</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实在抱歉，因为图片使用的是 &lt;code&gt;http&lt;/code&gt; 链接，在 &lt;code&gt;chrome&lt;/code&gt; 或者 &lt;code&gt;edge&lt;/code&gt; 浏览器中打开本博客的时候，看不到文章中的图片。&lt;/p&gt;
&lt;p&gt;可以在 &lt;code&gt;chrome&lt;/code&gt; 中通过 
      
    
    </summary>
    
      <category term="原" scheme="https://bianchengnan.github.io/categories/%E5%8E%9F/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>排错实战 | 使用 chkmatch 和 procmon 速解 MFC 调试符号加载失败</title>
    <link href="https://bianchengnan.github.io//articles/troubleshoot-mfc-pdb-mismatch-by-chkmatch-and-procmon/"/>
    <id>https://bianchengnan.github.io//articles/troubleshoot-mfc-pdb-mismatch-by-chkmatch-and-procmon/</id>
    <published>2025-12-14T11:11:33.000Z</published>
    <updated>2025-12-23T13:51:15.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>最近在调试的时候想查看 <code>mfc140u.dll</code> 中的函数，发现对应的调试符号没有加载，手动加载了几次都是失败。再三确认调试符号确实存在，而且设置的符号路径都对。难道又是调试符号不匹配？于是打算用 <code>chkmatch</code> 确认一下是否匹配。</p><p>最后，发现是调试符号放到了 <code>system32</code> 路径下，<code>chkmatch</code> 是 <code>32</code> 位程序，会自动到 <code>sysWOW64</code> 目录下找。本文简单记录了使用 <code>procmon</code> 快速排查定位，最后使用 <code>chkmatch -c</code> 使调试符号与 <code>mfc140u.dll</code> 强制匹配的过程。  </p><a id="more"></a><h2 id="初遇问题"><a href="#初遇问题" class="headerlink" title="初遇问题"></a>初遇问题</h2><p>今天调试的时候，又是找不到 <code>mfc140u.dll</code> 的符号，如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-mfc-pdb-mismatch-by-chkmatch-and-procmon/mfc140u.pdb-not-loaded-error.png" alt="mfc140u.pdb-not-loaded-error"></p><p>但是有一个很重要的逻辑需要查看该模块中的代码。于是手动加载了几次，再三确认了调试符号确实存在，而且符号路径设置的确实正确。很有可能是符号不匹配导致的。于是想着用 <code>chkmatch</code> 检查一下。</p><h2 id="chkmatch-报错"><a href="#chkmatch-报错" class="headerlink" title="chkmatch 报错"></a>chkmatch 报错</h2><p>没想到，运行 <code>chkmatch</code> 的时候却报找不到调试符号。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-mfc-pdb-mismatch-by-chkmatch-and-procmon/chkmatch-cannot-find-pdb-file.png" alt="chkmatch-cannot-find-pdb-file"></p><p>明明 <code>mfc140u.amd64.pdb</code> 就在 <code>c:\windows\system32</code> 目录下，但 <code>chkmatch</code> 为什么却找不到呢？看来需要请 <code>procmon</code> 出马了。</p><h2 id="procmon-出马"><a href="#procmon-出马" class="headerlink" title="procmon 出马"></a>procmon 出马</h2><p>运行 <code>procmon</code>，然后执行 <code>chkmatch</code>，执行完成后，停止采集。根据进程名过滤后，只保留文件读写操作。很快就看到了关键的事件。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-mfc-pdb-mismatch-by-chkmatch-and-procmon/procmon-view-key-event.png" alt="procmon-view-key-event"></p><p>从 <code>Path</code> 一列，可以清楚的知道，<code>chkmatch</code> 访问的是 <code>c:\windows\sysWOW64\mfc140u.amd64.pdb</code>，而不是 <code>c:\windows\system32\mfc140u.amd64.pdb</code>。</p><p>看到这里，我恍然大悟，在 <code>64</code> 位系统下运行的 <code>32</code> 位进程访问注册表和文件路径时会发生重定向。</p><h2 id="强制匹配"><a href="#强制匹配" class="headerlink" title="强制匹配"></a>强制匹配</h2><p>把 <code>mfc140u.amd64.pdb</code> 拷贝到其它路径下，然后再次执行检查操作，发现确实是调试符号不匹配导致的 <code>mfc140u.dll</code> 加载符号失败。</p><p><code>chkmatch</code> 不仅可以检查调试符号是否匹配，还可以修改调试符号的关键信息，使其与对应的模块文件强制匹配。只需要把 <code>-c</code> 选项换成 <code>-m</code> 选项即可。把修改后的调试符号放到 <code>d:\share\dll-pdbs\</code> 路径下，并在 <code>vs</code> 中设置好调试符号路径，然后右键，重新加载调试符号，这次可以看到期盼已久的函数名及对应的源码了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>procmon</code> 是监控各种操作的神器</p><p><code>chkmatch</code> 不仅可以检查调试符号是否匹配，还可修改调试符号信息使其匹配</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;最近在调试的时候想查看 &lt;code&gt;mfc140u.dll&lt;/code&gt; 中的函数，发现对应的调试符号没有加载，手动加载了几次都是失败。再三确认调试符号确实存在，而且设置的符号路径都对。难道又是调试符号不匹配？于是打算用 &lt;code&gt;chkmatch&lt;/code&gt; 确认一下是否匹配。&lt;/p&gt;
&lt;p&gt;最后，发现是调试符号放到了 &lt;code&gt;system32&lt;/code&gt; 路径下，&lt;code&gt;chkmatch&lt;/code&gt; 是 &lt;code&gt;32&lt;/code&gt; 位程序，会自动到 &lt;code&gt;sysWOW64&lt;/code&gt; 目录下找。本文简单记录了使用 &lt;code&gt;procmon&lt;/code&gt; 快速排查定位，最后使用 &lt;code&gt;chkmatch -c&lt;/code&gt; 使调试符号与 &lt;code&gt;mfc140u.dll&lt;/code&gt; 强制匹配的过程。  &lt;/p&gt;
    
    </summary>
    
      <category term="排错" scheme="https://bianchengnan.github.io/categories/%E6%8E%92%E9%94%99/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工具" scheme="https://bianchengnan.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="pdb" scheme="https://bianchengnan.github.io/tags/pdb/"/>
    
      <category term="procmon" scheme="https://bianchengnan.github.io/tags/procmon/"/>
    
      <category term="chkmatch" scheme="https://bianchengnan.github.io/tags/chkmatch/"/>
    
      <category term="调试符号" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何关闭 ASLR</title>
    <link href="https://bianchengnan.github.io//articles/how-to-disable-ASLR/"/>
    <id>https://bianchengnan.github.io//articles/how-to-disable-ASLR/</id>
    <published>2025-12-13T11:50:01.000Z</published>
    <updated>2025-12-23T13:51:14.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>写文章的时候经常需要截图，有时候截完图程序就关了，但是发现还有另外一个地方需要截图说明。再次启动程序的时候，模块加载位置变了，与原来的截图的内容不匹配了，又要重新截图。为了解决这个问题特意查了一下如何禁用地址空间随机化。有两种方法：一种是全局禁用，一种是针对某个程序禁用。这里做个记录，方便后续查询。</p><a id="more"></a><h2 id="禁用方法"><a href="#禁用方法" class="headerlink" title="禁用方法"></a>禁用方法</h2><p><code>设置</code> -&gt; <code>更新和安全</code> -&gt; <code>windows 安全中心</code> -&gt; <code>应用和浏览器控制</code> -&gt; <code>Exploit Protection</code>，点击 <code>Exploit Protection 设置</code> 按钮进入设置界面。</p><blockquote><p><strong>说明：</strong> 也可以直接按 <code>windows</code> 键，然后输入 <code>windows 安全中心</code> 进入 <code>windows 安全中心</code></p></blockquote><h3 id="全局禁用"><a href="#全局禁用" class="headerlink" title="全局禁用"></a>全局禁用</h3><p>在 <code>系统设置</code> 页下，关闭 <code>高熵 ASLR</code> 和 <code>随机化内存分配(自下而上 ASLR)</code>，确保 <code>强制影像随机化(强制性 ASLR)</code> 是关闭的（默认是关闭的）。修改后<strong>重启生效</strong>。</p><p><img src="http://resources.bianchengnan.tech/how-to-disable-ASLR/disable-aslr-system.png" alt="disable-aslr-system"></p><p>使用 <code>Procmon</code> 观察可以发现，对应的注册表项是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\kernel]</span><br><span class="line">"MitigationOptions"=hex:00,02,22,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"MitigationAuditOptions"=hex:00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"EAFModules"=""</span><br></pre></td></tr></table></figure><h3 id="针对某个程序禁用"><a href="#针对某个程序禁用" class="headerlink" title="针对某个程序禁用"></a>针对某个程序禁用</h3><p>在 <code>程序设置</code> 页下，可以添加或修改指定程序的设置。既可以按程序名称进行设置，也可以按照全路径进行设置。</p><p>勾选 <code>强制映像随机化(强制性 ASLR)</code> 和 <code>随机化内存分配(自下而上 ASLR)</code> 选项下的 <code>替代系统设置</code>，并且确保下方的开关是关闭的（默认是关闭的）。重启应用程序后生效。如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-disable-ASLR/disable-aslr-per-exe.png" alt="disable-aslr-per-exe"></p><p>使用 <code>Procmon</code> 观察可以发现，最终设置的是 <code>Image File Execution Options</code> 注册表项。</p><p>按照程序名称进行配置的注册表项如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LoadDlls.exe]</span><br><span class="line">"MitigationOptions"=hex:00,02,22,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"MitigationAuditOptions"=hex:00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"EAFModules"=""</span><br></pre></td></tr></table></figure><p>按照完整路径进行配置的注册表项如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LoadDlls1.exe]</span><br><span class="line">"UseFilter"=dword:00000001</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LoadDlls1.exe\&#123;aec33db5-c793-77a9-0b18-88d2ce11206b&#125;]</span><br><span class="line">"FilterFullPath"="D:\\MyBlogStuff\\LoadDlls\\x64\\Debug\\LoadDlls1.exe"</span><br><span class="line">"MitigationOptions"=hex:00,02,22,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"MitigationAuditOptions"=hex:00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"EAFModules"=""</span><br></pre></td></tr></table></figure><h2 id="修改-PE-文件"><a href="#修改-PE-文件" class="headerlink" title="修改 PE 文件"></a>修改 PE 文件</h2><p>除了修改系统设置外，还可以通过禁用 <code>PE</code> 文件头中的标志位来禁用 <code>ASLR</code>。有两种方式：</p><ol><li><p>如果有程序源码，可以修改 <code>vs</code> 中的工程设置来设置生成的 <code>PE</code> 文件头的标志位。</p><p><code>右键</code> -&gt; <code>属性</code> -&gt; <code>链接器</code> -&gt; <code>高级</code> -&gt; <code>随机地址</code> 选择 <code>否 (/DYNAMICBASE:NO)</code>，如下图：<img src="http://resources.bianchengnan.tech/how-to-disable-ASLR/disable-aslr-in-vs-project.png" alt="disable-aslr-in-vs-project"></p><p>这样编译生成的 <code>PE</code> 文件就不会包含重定位标志。</p><blockquote><p><strong>说明：</strong> 如果 <code>固定基址</code> 设置的值是 <code>是 (/FIXED)</code>，那么 <code>PE</code> 文件的 <code>IMAGE_FILE_HEADER.Characteristics</code> 的第 <code>0</code> 位（<code>IMAGE_FILE_RELOCS_STRIPPED</code> 位）的值是 <code>0</code>，并且生成的 <code>PE</code> 文件中不存在重定位信息（<code>Relocation info stripped</code>）。重定位模块可能会失败。</p></blockquote></li></ol><ol start="2"><li><p>如果程序已经生成，可以通过修改 <code>PE</code> 文件头来禁用 <code>ASLR</code></p><p>可以修改 <code>PE</code> 文件中 <code>IMAGE_OPTIONAL_HEADER32.DllCharacteristics</code> 中的第 <code>6</code> 位（从 <code>0</code> 开始）,也即 <code>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</code> 位的值，如果置 <code>1</code> 表示可以在加载时被重定位。</p><p><img src="http://resources.bianchengnan.tech/how-to-disable-ASLR/disable-aslr-by-NtHeaders-OptionalHeader-DllCharacteristics.png" alt="disable-aslr-by-NtHeaders-OptionalHeader-DllCharacteristics"></p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Windows PE 权威指南》</p><p><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=msvc-170" target="_blank" rel="noopener">https://learn.microsoft.com/zh-cn/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=msvc-170</a></p><p><a href="https://blog.csdn.net/meanong/article/details/80018392" target="_blank" rel="noopener">https://blog.csdn.net/meanong/article/details/80018392</a></p><p><a href="https://www.52pojie.cn/thread-1099755-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1099755-1-1.html</a></p><p><a href="https://blog.nsfocus.net/dynamorio-9/" target="_blank" rel="noopener">https://blog.nsfocus.net/dynamorio-9/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;写文章的时候经常需要截图，有时候截完图程序就关了，但是发现还有另外一个地方需要截图说明。再次启动程序的时候，模块加载位置变了，与原来的截图的内容不匹配了，又要重新截图。为了解决这个问题特意查了一下如何禁用地址空间随机化。有两种方法：一种是全局禁用，一种是针对某个程序禁用。这里做个记录，方便后续查询。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="ASLR" scheme="https://bianchengnan.github.io/tags/ASLR/"/>
    
      <category term="PE" scheme="https://bianchengnan.github.io/tags/PE/"/>
    
      <category term="procmon" scheme="https://bianchengnan.github.io/tags/procmon/"/>
    
      <category term="注册表" scheme="https://bianchengnan.github.io/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
      <category term="windows" scheme="https://bianchengnan.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>MFC对话框的“双胞胎”控件：隐藏了一个，还有一个在看我</title>
    <link href="https://bianchengnan.github.io//articles/two-interesting-mfc-dialog-bugs/"/>
    <id>https://bianchengnan.github.io//articles/two-interesting-mfc-dialog-bugs/</id>
    <published>2025-12-13T07:30:22.000Z</published>
    <updated>2025-12-23T13:51:15.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前段日子，遇到两个非常有意思的 <code>MFC</code> 对话框相关的 <code>bug</code>：</p><ol><li>为 <code>ComboBox</code> 控件设置了文本，但是却显示为空</li><li>明明已经隐藏了控件，但是控件却没有隐藏</li></ol><p>最后发现这两个问题是同一个问题，对话框中存在相同 <code>ID</code> 的控件。因为这两个问题是同一个问题，本文只介绍其中一个问题的排查思路。</p><a id="more"></a><blockquote><p><strong>说明：</strong> 实际项目中的情况要复杂的多，本文用到的例子都是我准备的示例程序</p></blockquote><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>程序会在某些情况下显式/隐藏某些特定控件，但是却发现对应的控件没有被隐藏，如下图：</p><p><img src="http://resources.bianchengnan.tech/two-interesting-mfc-dialog-bugs/can-not-hide-control.gif" alt="can-not-hide-control"></p><p>对应的控制代码也非常简单，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CString strTitle;</span><br><span class="line">GetDlgItem(IDC_BTN_SHOW_HIDE)-&gt;GetWindowTextW(strTitle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> showStatus = (strTitle == <span class="string">L"Show"</span>) ? SW_SHOW : SW_HIDE;</span><br><span class="line">GetDlgItem(IDC_EDIT_TEXT)-&gt;ShowWindow(showStatus);</span><br><span class="line">  </span><br><span class="line">strTitle = (strTitle == <span class="string">L"Show"</span>) ? <span class="string">L"Hide"</span> : <span class="string">L"Show"</span>;</span><br><span class="line">GetDlgItem(IDC_BTN_SHOW_HIDE)-&gt;SetWindowTextW(strTitle);</span><br></pre></td></tr></table></figure><p>反复确认代码逻辑，没有问题。那会是什么原因呢？<code>GetDlgItem()</code> 获取的控件不对？还是调用 <code>ShowWindow()</code> 失败了？还是其它什么原因？</p><h2 id="深入调查"><a href="#深入调查" class="headerlink" title="深入调查"></a>深入调查</h2><p>通过查看 <code>ShowWindow()</code> 的返回值，发现对 <code>ShowWindow()</code> 的调用是成功的。<code>GetDlgItem()</code> 获取的控件句柄是 <code>0x00020a7c</code>，</p><p><img src="http://resources.bianchengnan.tech/two-interesting-mfc-dialog-bugs/search-target-window.png" alt="search-target-window"></p><p>通过 <code>spyxx</code> 的窗口搜索功能，在 <code>句柄（A）：</code> 对应的位置输入 <code>0x00020a7c</code>，可以发现控件确实已经被隐藏了。</p><p>那么显示着的控件又是哪一个呢？再用 <code>spyxx</code> 的窗口搜索功能，拖动靶心到对应的窗口上，可以发现控件句柄是 <code>00060a5e</code>，在对应的列表项上右键，突出显式，可以确认显示着的控件句柄确实是 <code>0x00060a5e</code>。</p><p><img src="http://resources.bianchengnan.tech/two-interesting-mfc-dialog-bugs/highlight-visible-control.gif" alt="highlight-visible-control"></p><p>难道同一个位置有两个一模一样的控件？赶紧查看一下 <code>rc</code> 文件。</p><h2 id="查看-rc"><a href="#查看-rc" class="headerlink" title="查看 rc"></a>查看 rc</h2><p>果然，在 <code>rc</code> 文件中有重复的控件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IDD_REPEATCONTROLID_DIALOG DIALOGEX <span class="number">0</span>, <span class="number">0</span>, <span class="number">272</span>, <span class="number">110</span></span><br><span class="line">STYLE DS_SETFONT | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME</span><br><span class="line">EXSTYLE WS_EX_APPWINDOW</span><br><span class="line">CAPTION <span class="string">"RepeatControlId"</span></span><br><span class="line">FONT <span class="number">8</span>, <span class="string">"MS Shell Dlg"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x1</span></span><br><span class="line">BEGIN</span><br><span class="line">    DEFPUSHBUTTON   <span class="string">"退出"</span>,IDOK,<span class="number">215</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">14</span></span><br><span class="line">    EDITTEXT        IDC_EDIT_TEXT,<span class="number">89</span>,<span class="number">7</span>,<span class="number">176</span>,<span class="number">15</span>,ES_AUTOHSCROLL <span class="comment">//&lt;----</span></span><br><span class="line">    EDITTEXT        IDC_EDIT_TEXT,<span class="number">89</span>,<span class="number">7</span>,<span class="number">176</span>,<span class="number">15</span>,ES_AUTOHSCROLL</span><br><span class="line">    PUSHBUTTON      <span class="string">"Hide"</span>,IDC_BTN_SHOW_HIDE,<span class="number">7</span>,<span class="number">7</span>,<span class="number">73</span>,<span class="number">15</span></span><br><span class="line">    LTEXT           <span class="string">"点击按钮会隐藏右侧文本框，..."</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">26</span>,<span class="number">258</span>,<span class="number">59</span></span><br><span class="line">END</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong> 实际项目中，对话框中的控件数量超级多，不像示例程序这么明显，一眼就能看出来有重复控件</p></blockquote><p>至此，可以结案了，因为 <code>rc</code> 中有重复的控件，所以导致在隐藏控件时，只隐藏了一个。另外一个 <code>bug</code> 也是同样的问题，不再赘述。</p><h2 id="警示"><a href="#警示" class="headerlink" title="警示"></a>警示</h2><p>按理说，同一个对话框中存在相同 <code>ID</code> 的控件，编译的时候至少会报警告。重新编译程序，观察编译警告，果然发现有提示：</p><p><code>1&gt;RepeatControlId.rc(106): warning RC2182: duplicate dialog control ID 1000</code></p><p>一定要注意编译器的警告啊！</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>示例程序代码已经上传到了<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/two-interesting-mfc-dialog-bugs/RepeatControlId" target="_blank" rel="noopener">github</a>，感兴趣的朋友可以下载体验。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>同一个对话框中不要存在有相同 <code>ID</code> 的控件</p></li><li><p><code>spyxx</code> 是查看窗口句柄的好工具，一定要善加利用</p></li><li><p>务必注意编译器的警告信息！</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前段日子，遇到两个非常有意思的 &lt;code&gt;MFC&lt;/code&gt; 对话框相关的 &lt;code&gt;bug&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为 &lt;code&gt;ComboBox&lt;/code&gt; 控件设置了文本，但是却显示为空&lt;/li&gt;
&lt;li&gt;明明已经隐藏了控件，但是控件却没有隐藏&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后发现这两个问题是同一个问题，对话框中存在相同 &lt;code&gt;ID&lt;/code&gt; 的控件。因为这两个问题是同一个问题，本文只介绍其中一个问题的排查思路。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="mfc" scheme="https://bianchengnan.github.io/tags/mfc/"/>
    
  </entry>
  
  <entry>
    <title>内存都去哪了？探究 VirtualAlloc 分配背后被“浪费”的 60KB</title>
    <link href="https://bianchengnan.github.io//articles/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/"/>
    <id>https://bianchengnan.github.io//articles/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/</id>
    <published>2025-12-06T13:43:53.000Z</published>
    <updated>2025-12-23T13:51:14.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录了一次因  <code>VirtualAlloc</code> 分配失败引发的 <code>OOM</code> 问题排查过程。通过编写测试程序模拟内存分配，发现 <code>32</code> 位进程在未开启 <code>Large Address Aware</code> 时，用户空间仅 <code>2GB</code> 可用，且 <code>VirtualAlloc</code> 实际分配粒度均为 <strong>64KB</strong>——若申请 <code>4KB</code>，剩余 <code>60KB</code> 将变为不可用空间，导致地址空间碎片化与大量浪费。借助 <code>VMMap</code> 碎片视图与 <code>Windbg</code> 分析，直观展示了分配粒度对内存布局的影响，并验证了按 <code>64KB</code> 对齐分配可避免该问题。</p><a id="more"></a><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>测试代码非常简单，我就直接贴到这里了，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nk = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usage: TestVirtualAlloc.exe N(kb). default 4kb"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    nk = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pAddr = VirtualAlloc(<span class="literal">nullptr</span>, nk * <span class="number">1024</span>, MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">        <span class="keyword">if</span> (pAddr == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"VirtualAlloc(%dkb) loop %6d failed. last error 0n%d\r\n"</span>, nk, idx++, GetLastError());</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"VirtualAlloc(%dkb) loop %6d succeed. address 0x%08x\r\n"</span>, nk, idx++, pAddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Free-空间出乎意料的大"><a href="#Free-空间出乎意料的大" class="headerlink" title="Free 空间出乎意料的大"></a>Free 空间出乎意料的大</h2><p>编译 <code>32</code> 位版本的程序，执行 <code>TestVirtualAlloc.exe 4</code>（每次分配 <code>4kb</code>），执行一段时间后，最终会失败，如下图：</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/virtual-alloc-failed.png" alt="virtual-alloc-failed"></p><p>这是预料内的现象，因为程序在不停的分配空间，<code>32</code> 位进程的虚拟地址空间仅有 <code>4GB</code>，在未开启 <code>Large Address Aware</code> 的情况下，用户程序可用的空间仅有 <code>2GB</code> 空间可用。</p><p>用 <code>windbg</code> 附加到该进程，执行 <code>!address -summary</code> 查看地址空间情况，发现 <code>Free</code> 占比有点太大了（<code>88.90%</code>），这不符合预期。程序在不停的分配空间，虽然没有 <code>commit</code>，但是已经 <code>reserve</code> 了，不应该有这么多 <code>Free</code> 空间才对。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/address-summary.png" alt="address-summary"></p><p><code>VMMap</code> 是查看虚拟内存空间的神器，可以非常详细的查看某个进程的内存空间布局。何不用 <code>VMMap</code> 查看一下？</p><h2 id="请出-VMMap"><a href="#请出-VMMap" class="headerlink" title="请出 VMMap"></a>请出 VMMap</h2><p>打开 <code>VMMap</code> 并选择 <code>TestVirtualAlloc.exe</code>，查看其虚拟内存空间。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/vmmap-view-memory.png" alt="vmmap-view-memory"></p><blockquote><p><strong>说明：</strong>切记勾选 <code>Options</code> 选项下的 <code>Show Free and Unsuable Regions</code></p></blockquote><p>当我看到 <code>60 K</code> 的 <code>Unusable</code> 跟在 <code>4 K</code> 的 <code>Private Data</code> 后时，沉睡的记忆终于被唤醒了，<code>VirtualAlloc</code> 的分配粒度是 <code>64kb</code> ！！！</p><p>在 <code>windbg</code> 中使用 <code>!address</code> 命令查看地址 <code>0x00490000</code> 和 <code>0x00491000</code> 的情况，如下图：</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/windbg-address-490000-491000.png" alt="windbg-address-490000-491000"></p><p>地址 <code>0x00491000</code> 所属的区域是 <code>MEM_FREE</code> 的。需要注意的是虽然从 <code>0x00491000</code> 开始的 <code>60kb</code> 是 <code>Free</code> 的，但是这块地址不能被分配使用了，这就是为什么 <code>VMMap</code> 中显示为 <code>Unusable</code> 的原因。</p><p>如果我分配的是 <code>64kb</code>，那么就不会有这么大的 <code>Free</code> 空间了。是不是呢？简单验证一下就知道了。</p><h2 id="继续验证"><a href="#继续验证" class="headerlink" title="继续验证"></a>继续验证</h2><p>执行 <code>TestVirtualAlloc.exe 64</code>（每次会分配 <code>64kb</code>），然后使用 <code>windbg</code> 观察内存空间的情况。</p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/address-summary-no-much-free-memory.png" alt="address-summary-no-much-free-memory"><p>可以发现 <code>MEM_FREE</code> 类型的内存空间很小了，基本上全是 <code>MEM_RESERVE</code> 类型的内存空间。使用 <code>VMMap</code> 查看的话，也差不多，这里就不截图了。感兴趣的小伙伴可以自己动手实验。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>折腾完，我突然意识到一个致命问题 —— 我的系统是 <code>64</code> 位的啊。<code>32</code> 位程序在 <code>64</code> 位操作系统下，用户态内存空间应该是 <code>4GB</code> 才对，这里为啥才 <code>2GB</code> 呢？想必聪明的你也一定知道其中的缘由了，想要使用 <code>4GB</code> 的内存空间，必须开启 <code>Large Address Aware</code> 才行。</p><p>经过确认，编译程序的时候，默认是没开启这个选项的。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/enable-large-address-aware.png" alt="enable-large-address-aware"></p><p>开启后，再次执行程序，可以发现可分配的内存地址是大于 <code>2gb</code> 的，接近 <code>4gb</code>。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/allocate-at-address-higher-than-2gb.png" alt="allocate-at-address-higher-than-2gb"></p><h2 id="Fragmentation-View"><a href="#Fragmentation-View" class="headerlink" title="Fragmentation View"></a>Fragmentation View</h2><p>其实，<code>VMMap</code> 还有一个非常强悍的功能，叫 <code>Fragmentation View</code>。此功能可以鸟瞰进程的整个内存空间，也可以放大到对应的区域查看，点击对应区域还可以查看具体的地址范围。从下图可以很明显的看到每次分配 <code>4kb</code> 的内存分布模式 —— <code>4kb</code> 的 <code>reserve</code> 空间（黄色方块）后跟着 <code>60kb</code> 的 <code>Unusable</code> 空间（灰色区域）。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/vmmap-fragment-view.png" alt="vmmap-fragment-view"></p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>我已经把对应的示例代码上传到了 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/TestVirtualAlloc" target="_blank" rel="noopener">github</a>，感兴趣的小伙伴可以自行实验。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>VMMap</code> 是查看虚拟内存空间的神兵利器</li><li><code>VirtualAlloc</code> 分配粒度是 <code>64kb</code>，如果分配的过小，会产生浪费，甚至是内存碎片</li><li>开启 <code>Large Address Aware</code> 后，<code>32</code> 位程序才能使用更大的内存空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录了一次因  &lt;code&gt;VirtualAlloc&lt;/code&gt; 分配失败引发的 &lt;code&gt;OOM&lt;/code&gt; 问题排查过程。通过编写测试程序模拟内存分配，发现 &lt;code&gt;32&lt;/code&gt; 位进程在未开启 &lt;code&gt;Large Address Aware&lt;/code&gt; 时，用户空间仅 &lt;code&gt;2GB&lt;/code&gt; 可用，且 &lt;code&gt;VirtualAlloc&lt;/code&gt; 实际分配粒度均为 &lt;strong&gt;64KB&lt;/strong&gt;——若申请 &lt;code&gt;4KB&lt;/code&gt;，剩余 &lt;code&gt;60KB&lt;/code&gt; 将变为不可用空间，导致地址空间碎片化与大量浪费。借助 &lt;code&gt;VMMap&lt;/code&gt; 碎片视图与 &lt;code&gt;Windbg&lt;/code&gt; 分析，直观展示了分配粒度对内存布局的影响，并验证了按 &lt;code&gt;64KB&lt;/code&gt; 对齐分配可避免该问题。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="vmmap" scheme="https://bianchengnan.github.io/tags/vmmap/"/>
    
  </entry>
  
  <entry>
    <title>排错实战 | 当编译器&quot;吃掉&quot;函数声明：一次由宏冲突引发的离奇编译错误</title>
    <link href="https://bianchengnan.github.io//articles/troubleshoot-another-compile-error/"/>
    <id>https://bianchengnan.github.io//articles/troubleshoot-another-compile-error/</id>
    <published>2025-12-06T13:43:53.000Z</published>
    <updated>2025-12-23T13:51:14.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在编译 <code>.NET Runtime</code> 源码研究 <code>GC</code> 机制时，我遇到了一个离奇的编译错误：函数 <code>__asan_handle_no_return</code> 的声明被编译器报错为”类函数宏的调用”。通过将源文件预处理输出到中间文件，我发现这个函数声明竟然变成了 <code>void ;</code>——它被”吃掉”了！追踪发现，在 <code>utils.h</code> 中定义了一个同名宏，当 <code>__SANITIZE_ADDRESS__</code> 宏未定义时，该宏被展开为空，导致函数声明被意外删除。这个案例再次证明：<strong>宏命名冲突是编译错误的常见陷阱</strong>，而<strong>预处理输出文件</strong>是诊断这类问题的利器。同时，<code>FileLocator</code> 这类文件搜索工具在源码分析中不可或缺。</p><a id="more"></a><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>从 <a href="https://github.com/dotnet/runtime" target="_blank" rel="noopener">https://github.com/dotnet/runtime</a> 下载源代码到本地，打开 <code>powershell</code> 执行 <code>.\build.cmd -vs coreclr.sln -a x64 -c Debug</code>，一切顺利的话会生成对应的 <code>sln</code> 文件。打开 <code>sln</code> 文件，重新生成解决方案，就遇到了下面的错误。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/compile-error.png" alt="compile-error"></p><p>从图中看，这就是一个很简单的函数声明啊，这还能出错？如果仔细看提示，<code>类函数宏的调用</code>。可以猜想这个错误跟宏有关系。难道又是一个宏冲突导致的问题？不管怎么样，还是老一套，把对应的源文件输出到中间文件，可以参考<a href="https://bianchengnan.github.io/articles/troubleshoot-vs-compile-error-C2589-illegal-token-on-right-side-of/">之前的文章</a>。</p><h2 id="初步调查"><a href="#初步调查" class="headerlink" title="初步调查"></a>初步调查</h2><p>错误工程是 <code>minipal_sanitizer_support</code>，出错的源文件是 <code>sansupport.c</code>。把 <code>sansupport.c</code> 经过预处理的文件输出到中间文件中，设置如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/preprocess-to-file-and-keep-comments.png" alt="preprocess-to-file-and-keep-comments"></p><p>设置好后，在 <code>sansupport.c</code> 上右键，编译，编译完成后，会生成一个名为 <code>sansupport.i</code> 的中间文件，打开此文件，并搜索 <code>__asan_handle_no_return</code>，仅发现了一条无关紧要的记录（在注释中出现），如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/search-keyword-and-find-one-useless.png" alt="search-keyword-and-find-one-useless"></p><p>呦吼，直接消失了？有点意思，搜索一下它上面的函数 <code>__asan_addr_is_in_fake_stack</code>。搜到了，而且有了意外收获 —— 目标函数变成了 <code>void ;</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/search-previous-function-and-find-target-function-missing.png" alt="search-previous-function-and-find-target-function-missing"></p><p>至此，已经可以基本确定是宏导致的了，在某处一定有一个与目标函数重名的宏，接下来该怎么办呢？还是搜。</p><h2 id="找出真凶"><a href="#找出真凶" class="headerlink" title="找出真凶"></a>找出真凶</h2><p>清楚 <code>FileLocator</code> 在下载的 <code>.net runtime</code> 源码目录下搜 <code>__asan_handle_no_return</code>，发现在 <code>utils.h</code> 中定义了这个宏。打开 <code>utils.h</code> 查看，果然发现 <code>146</code> 行的宏定义，如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/macro-defined-in-utils-h.png" alt="macro-defined-in-utils-h"></p><p>根据此处的逻辑可知，应该是 <code>126</code> 行的宏（<code>HAS_ADDRESS_SANITIZER</code>）没定义，导致了这个错误。而 <code>126</code> 行用到的宏又是由 <code>91~107</code> 行的宏定义决定的。如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/macro-HAS_ADDRESS_SANITIZER-definition.png" alt="macro-HAS_ADDRESS_SANITIZER-definition"></p><p>显然是没定义 <code>__SANITIZE_ADDRESS__</code> 宏导致的。知道原因了，简单粗暴的加上一句 <code>#define __SANITIZE_ADDRESS__</code>，再次编译，果然顺利通过了。</p><p>至于为什么编译失败，我就不关心了。因为我有更感兴趣的事情要处理 —— 查看 <code>gc</code> 相关的逻辑。本篇总结就水到这里啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>遇到奇怪的编译错误不要慌，秘密武器就是输出到中间文件，查看编译器眼中的文件到底长什么样</li><li>一定要有自己顺手的一套工具，搜索文件内容强烈推荐 <code>FileLocator</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在编译 &lt;code&gt;.NET Runtime&lt;/code&gt; 源码研究 &lt;code&gt;GC&lt;/code&gt; 机制时，我遇到了一个离奇的编译错误：函数 &lt;code&gt;__asan_handle_no_return&lt;/code&gt; 的声明被编译器报错为”类函数宏的调用”。通过将源文件预处理输出到中间文件，我发现这个函数声明竟然变成了 &lt;code&gt;void ;&lt;/code&gt;——它被”吃掉”了！追踪发现，在 &lt;code&gt;utils.h&lt;/code&gt; 中定义了一个同名宏，当 &lt;code&gt;__SANITIZE_ADDRESS__&lt;/code&gt; 宏未定义时，该宏被展开为空，导致函数声明被意外删除。这个案例再次证明：&lt;strong&gt;宏命名冲突是编译错误的常见陷阱&lt;/strong&gt;，而&lt;strong&gt;预处理输出文件&lt;/strong&gt;是诊断这类问题的利器。同时，&lt;code&gt;FileLocator&lt;/code&gt; 这类文件搜索工具在源码分析中不可或缺。&lt;/p&gt;
    
    </summary>
    
      <category term="排错" scheme="https://bianchengnan.github.io/categories/%E6%8E%92%E9%94%99/"/>
    
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="排错" scheme="https://bianchengnan.github.io/tags/%E6%8E%92%E9%94%99/"/>
    
      <category term="troubleshoot" scheme="https://bianchengnan.github.io/tags/troubleshoot/"/>
    
      <category term="编译" scheme="https://bianchengnan.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="宏" scheme="https://bianchengnan.github.io/tags/%E5%AE%8F/"/>
    
      <category term="compile" scheme="https://bianchengnan.github.io/tags/compile/"/>
    
  </entry>
  
  <entry>
    <title>深入.NET Runtime：一次 OOM 异常的分析与源码追踪之旅</title>
    <link href="https://bianchengnan.github.io//articles/analyze-oom-and-dive-into-dotnet-source/"/>
    <id>https://bianchengnan.github.io//articles/analyze-oom-and-dive-into-dotnet-source/</id>
    <published>2025-11-29T12:42:23.000Z</published>
    <updated>2025-12-23T13:51:13.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录了一次对 <code>.NET</code> 应用程序发生的“内存不足”（<code>OOM</code>）异常进行的深度源码级调查。问题始于一个看似矛盾的现象：诊断工具显示有足够大的空闲内存块（约 <code>50MB</code>），但垃圾回收（<code>GC</code>）过程却在尝试预留较小内存段（约 <code>16MB</code>）时失败。</p><p>为了探究根源，笔者<strong>逆向追踪了诊断工具（如SOS）输出的数据链路</strong>：从高层诊断命令（<code>AnalyzeOOMCommand</code>）入手，逐步深入<code>Microsoft.Diagnostics.Runtime (CLRMD)</code>库、托管辅助类、<code>Dac</code> 接口，最终直达 <code>.NET Runtime(CoreCLR)</code> 底层的 <code>GC</code> 相关 <code>Native</code> 代码（如 <code>ClrDataAccess</code>、<code>gc_heap</code>）。</p><p>虽然最终并没能定位问题的真实原因，但是理清了 <code>GC</code> 在 <code>virtual_alloc</code>过程中因<strong>内存限制检查、地址空间布局考量等因素</strong>导致预留失败的具体逻辑，并对 <code>.NET</code> 源码有了一定的认识，还是非常值得记录分享的。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前些日子，在 <code>.NET</code> 调试群里有位网友的 <code>.NET</code> 程序触发了 <code>OOM (Out Of Memory)</code> 异常，他在群里发了一些截图，询问大家是什么原因导致的。其中一张分析结果图如下：</p><p><img src="http://resources.bianchengnan.tech/analyze-oom-and-dive-into-dotnet-source/oom.png" alt="oom"></p><p>看着是 <code>gc</code> 过程中发生了内存不足的问题。大概率是要分配 <code>16MB</code> 左右的内存空间时失败了，但是另外一张截图显示，最大空闲块还有 <code>50MB</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/analyze-oom-and-dive-into-dotnet-source/address-summary.png" alt="address-summary"></p><p>由于没看过 <code>.net</code> 源码，只能根据自己的认知进行了回复，这种心里没底的感觉很不爽。正好最近想多研究下 <code>.net</code>，而且有源代码可查，为啥不看看呢？</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>可以通过 <code>git clone https://github.com/dotnet/runtime.git</code> 命令把 <code>.NET runtime</code> 源码克隆到本地。还可以下载对应的诊断工具源码，包括但不限于 <code>SOS</code>。可以通过 <code>git clone https://github.com/dotnet/diagnostics.git</code> 克隆到本地。</p><blockquote><p><strong>说明：</strong> 最开始的想法是编译一份进行调试，折腾了半天，还遇到一些编译错误，这里就不展开了，后面会有一篇文章单独总结。</p><p>下载的版本与我我本地的运行时版本（<code>8.0.7</code>）不匹配，切换到对应的版本（<code>git tag --list</code> 然后 <code>git checkout v8.0.7</code> ）。</p></blockquote><p>如何开始呢？截图中的关键信息描述就是入手点，当然从搜索入手了。</p><h2 id="追踪-OOM-来源"><a href="#追踪-OOM-来源" class="headerlink" title="追踪 OOM 来源"></a>追踪 OOM 来源</h2><p>打开文件内容搜索神器 <code>FileLocator</code>，搜索 <code>Failed to reserve memory</code>，在 <code>AnalyzeOOMCommand.cs</code> 中发现了匹配项。 </p><p><img src="http://resources.bianchengnan.tech/analyze-oom-and-dive-into-dotnet-source/search-keyword.png" alt="search-keyword"></p><p>关键类摘录如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnalyzeOOMCommand</span> : <span class="title">ClrRuntimeCommandBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">bool</span> foundOne = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (ClrOutOfMemoryInfo oom <span class="keyword">in</span> Runtime.Heap.SubHeaps.Select(h =&gt; h.OomInfo).Where(oom =&gt; oom != <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            foundOne = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(oom.Reason <span class="keyword">switch</span></span><br><span class="line">            &#123;</span><br><span class="line">                OutOfMemoryReason.Budget or OutOfMemoryReason.CantReserve =&gt; <span class="string">"OOM was due to an internal .Net error, likely a bug in the GC"</span>,</span><br><span class="line">                OutOfMemoryReason.CantCommit =&gt; <span class="string">"Didn't have enough memory to commit"</span>,</span><br><span class="line">                OutOfMemoryReason.LOH =&gt; <span class="string">"Didn't have enough memory to allocate an LOH segment"</span>,</span><br><span class="line">                OutOfMemoryReason.LowMem =&gt; <span class="string">"Low on memory during GC"</span>,</span><br><span class="line">                OutOfMemoryReason.UnproductiveFullGC =&gt; <span class="string">"Could not do a full GC"</span>,</span><br><span class="line">                _ =&gt; oom.Reason.ToString() <span class="comment">// shouldn't happen, we handle all cases above</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oom.GetMemoryFailure != GetMemoryFailureReason.None)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> message = oom.GetMemoryFailure <span class="keyword">switch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    GetMemoryFailureReason.ReserveSegment =&gt; <span class="string">"Failed to reserve memory"</span>,</span><br><span class="line">                    GetMemoryFailureReason.CommitSegmentBegin =&gt; <span class="string">"Didn't have enough memory to commit beginning of the segment"</span>,</span><br><span class="line">                    GetMemoryFailureReason.CommitEphemeralSegment =&gt; <span class="string">"Didn't have enough memory to commit the new ephemeral segment"</span>,</span><br><span class="line">                    GetMemoryFailureReason.GrowTable =&gt; <span class="string">"Didn't have enough memory to grow the internal GC data structures"</span>,</span><br><span class="line">                    GetMemoryFailureReason.CommitTable =&gt; <span class="string">"Didn't have enough memory to commit the internal GC data structures"</span>,</span><br><span class="line">                    _ =&gt; oom.GetMemoryFailure.ToString() <span class="comment">// shouldn't happen, we handle all cases above</span></span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(<span class="string">$"Details: <span class="subst">&#123;(oom.IsLargeObjectHeap ? <span class="string">"LOH"</span> : <span class="string">"SOH"</span>)&#125;</span> <span class="subst">&#123;message&#125;</span> <span class="subst">&#123;oom.Size:n0&#125;</span> bytes"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If it's a commit error (GetMemoryFailureReason.GrowTable can indicate a reserve</span></span><br><span class="line">                <span class="comment">// or a commit error since we make one VirtualAlloc call to reserve and commit),</span></span><br><span class="line">                <span class="comment">// we indicate the available commit space if we recorded it.</span></span><br><span class="line">                <span class="keyword">if</span> (oom.AvailablePageFileMB != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">$" - on GC entry available commit space was <span class="subst">&#123;oom.AvailablePageFileMB:n0&#125;</span> MB"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!foundOne)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"There was no managed OOM due to allocations on the GC heap"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看，与网友截图中的输出高度匹配，看样子是找对地方了。从代码逻辑可知，<code>AnalyzeOOMCommand</code> 命令会遍历堆，输出每个堆上的 <code>ClrOutOfMemoryInfo</code> 信息。关键代码如下：</p><p><code>foreach (ClrOutOfMemoryInfo oom in Runtime.Heap.SubHeaps.Select(h =&gt; h.OomInfo).Where(oom =&gt; oom != null))</code></p><p>至此可推断，发生 <code>OOM</code> 异常时，<code>runtime</code> 会把相关信息保存到堆上。<code>SOS</code> 等插件直接从对上取出对应信息，展示出来即可。看完这个类的实现，感觉我又行了，也能写一个类似的插件了，哈哈哈。不废话了，回到正题。单击 <code>h.OomInfo</code> 跳转到 <code>OomInfo</code> 的实现，可以发现其是类 <code>ClrSubHeap</code> 的一个属性字段。</p><blockquote><p><strong>说明：</strong><code>ClrSubHeap</code> 并没有实现在 <code>diagnostics</code> 工程中，而是实现在 <code>Microsoft.Diagnostics.Runtime</code> 中，可以通过 <code>git clone https://github.com/microsoft/clrmd.git</code> 下载。</p></blockquote><p>打开 <code>Microsoft.Diagnostics.Runtime.sln</code>，可以搜到 <code>OomInfo</code> 的实现，如下：</p><p><code>public ClrOutOfMemoryInfo? OomInfo =&gt; Heap.Helpers.GetOOMInfo(Address, out OomInfo oomInfo) ? new(oomInfo) : null;</code></p><p><code>OomInfo</code> 来自 <code>Heap.Helpers.GetOOMInfo()</code> 函数。而 <code>Heap</code> 是 <code>ClrSubHeap</code> 的一个字段，在 <code>ClrSubHeap</code> 构造的时候传进来。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClrSubHeap</span> : <span class="title">IClrSubHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrSubHeap</span>(<span class="params">ClrHeap clrHeap, <span class="keyword">in</span> SubHeapInfo subHeap</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Heap = clrHeap;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClrHeap Heap &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    IClrHeap IClrSubHeap.Heap =&gt; Heap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转到 <code>ClrHeap</code> 的实现看下 <code>Helpers</code> 的来源</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrHeap</span> : <span class="title">IClrHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrHeap</span>(<span class="params">ClrRuntime runtime, IMemoryReader memoryReader, IAbstractHeapProvider helpers, IAbstractTypeProvider typeHelpers, <span class="keyword">in</span> GCState gcInfo</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Runtime = runtime;</span><br><span class="line">        _memoryReader = memoryReader;</span><br><span class="line">        Helpers = helpers; <span class="comment">//&lt;----</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        SubHeaps = Helpers.EnumerateSubHeaps().Select(r =&gt; <span class="keyword">new</span> ClrSubHeap(<span class="keyword">this</span>, r)).ToImmutableArray();</span><br><span class="line">        Segments = SubHeaps.SelectMany(r =&gt; r.Segments).OrderBy(r =&gt; r.FirstObjectAddress).ToImmutableArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> IAbstractHeap Helpers &#123; <span class="keyword">get</span>; &#125; <span class="comment">//&lt;---</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClrRuntime Runtime &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 <code>Helpers</code> 是在 <code>ClrHeap</code> 构造的时候通过参数传进来的，而且 <code>SubHeaps</code> 也会在 <code>ClrHeap</code> 构造的时候被创建出来。</p><p>再看下 <code>ClrHeap</code> 是怎么被构造出来的。在 <code>ClrHeap</code> 的构造函数上方点击引用数量，跳转到对应的位置。可以发现其来自 <code>ClrRuntime</code> 的 <code>Heap</code> 属性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrRuntime</span> : <span class="title">IClrRuntime</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClrHeap Heap</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            ClrHeap? heap = _heap;</span><br><span class="line">            <span class="keyword">while</span> (heap <span class="keyword">is</span> <span class="literal">null</span>) <span class="comment">// Flush can cause a race.</span></span><br><span class="line">            &#123;</span><br><span class="line">                IAbstractHeap? heapHelpers = GetService&lt;IAbstractHeap&gt;(); <span class="comment">//&lt;---</span></span><br><span class="line">                IAbstractTypeHelpers? typeHelpers = GetService&lt;IAbstractTypeHelpers&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// These are defined as non-nullable but just in case, double check we have a non-null instance.</span></span><br><span class="line">                <span class="keyword">if</span> (heapHelpers <span class="keyword">is</span> <span class="literal">null</span> || typeHelpers <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException(<span class="string">"Unable to create a ClrHeap for this runtime."</span>);</span><br><span class="line"></span><br><span class="line">                heap = <span class="keyword">new</span>(<span class="keyword">this</span>, DataTarget.DataReader, heapHelpers, typeHelpers);</span><br><span class="line">                Interlocked.CompareExchange(<span class="keyword">ref</span> _heap, heap, <span class="literal">null</span>);</span><br><span class="line">                heap = _heap;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> heap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 <code>heapHelpers</code> 参数来自 <code>IAbstractHeap? heapHelpers = GetService&lt;IAbstractHeap&gt;();</code></p><p>跳转到 <code>GetService()</code> 的实现，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> T? GetService&lt;T&gt;() <span class="keyword">where</span> T: <span class="keyword">class</span> =&gt; (T?)_services.GetService(<span class="keyword">typeof</span>(T));</span><br></pre></td></tr></table></figure><p>可以发现，<code>GetService&lt;T&gt;()</code> 是通过 <code>_services.GetService(typeof(T))</code> 实现的，再看下 <code>_services</code> 的来源。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrRuntime</span> : <span class="title">IClrRuntime</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _services;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ClrHeap? _heap;</span><br><span class="line">    <span class="keyword">private</span> ImmutableArray&lt;ClrThread&gt; _threads;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> DomainAndModules? _domainAndModules;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAbstractRuntime? _runtime;</span><br><span class="line">    <span class="keyword">private</span> IAbstractComHelpers? _comHelpers;</span><br><span class="line">    <span class="keyword">private</span> IAbstractMethodLocator? _methodLocator;</span><br><span class="line">    <span class="keyword">private</span> IAbstractDacController? _controller;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrRuntime</span>(<span class="params">ClrInfo clrInfo, IServiceProvider services</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ClrInfo = clrInfo;</span><br><span class="line">        DataTarget = clrInfo.DataTarget;</span><br><span class="line">        _services = services; <span class="comment">//&lt;---</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 <code>_services</code> 是在 <code>ClrRuntime</code> 构造的时候传进来的。点击 <code>ClrRuntime</code> 的构造函数上方的引用计数，可以发现  <code>ClrRuntime</code>  在<code>ClrInfo</code> 的 <code>CreateRuntimeWorker()</code> 函数中被创建，<code>services</code> 参数来自 <code>ClrInfoProvider.GetDacServices()</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrInfo</span> : <span class="title">IClrInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ClrRuntime <span class="title">CreateRuntimeWorker</span>(<span class="params"><span class="keyword">string</span>? dacPath, <span class="keyword">bool</span> ignoreMismatch, <span class="keyword">bool</span> verifySignature</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        IServiceProvider services = ClrInfoProvider.GetDacServices(<span class="keyword">this</span>, dacPath, ignoreMismatch, verifySignature);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClrRuntime(<span class="keyword">this</span>, services);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下 <code>ClrInfoProvider</code> 的来源，发现其是 <code>ClrInfo</code> 的属性成员，在 <code>ClrInfo</code> 构造的时候被初始化。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrInfo</span> : <span class="title">IClrInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrInfo</span>(<span class="params">DataTarget dt, ModuleInfo module, Version clrVersion, IClrInfoProvider provider</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DataTarget = dt ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(dt));</span><br><span class="line">        ModuleInfo = module ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(module));</span><br><span class="line">        ClrInfoProvider = provider ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(provider)); <span class="comment">//&lt;---</span></span><br><span class="line">        Version = clrVersion ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(clrVersion));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The DataTarget containing this ClrInfo.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> DataTarget DataTarget &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The IClrInfoProvider which created this ClrInfo.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> IClrInfoProvider ClrInfoProvider &#123; <span class="keyword">get</span>; &#125; <span class="comment">//&lt;---</span></span><br><span class="line"></span><br><span class="line">    IDataTarget IClrInfo.DataTarget =&gt; DataTarget;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看 <code>ClrInfo</code> 是在哪里被创建的，点击 <code>ClrInfo</code> 的构造函数上方的引用计数，可以发现其来自 <code>DotNetClrInfoProvider</code> 的 <code>CreateClrInfo()</code> 函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DotNetClrInfoProvider</span> : <span class="title">IClrInfoProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClrInfo <span class="title">CreateClrInfo</span>(<span class="params">DataTarget dataTarget, ModuleInfo module, <span class="keyword">ulong</span> runtimeInfo, ClrFlavor flavor</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        ClrInfo result = <span class="keyword">new</span>(dataTarget, module, version, <span class="keyword">this</span>) <span class="comment">//&lt;---</span></span><br><span class="line">        &#123;</span><br><span class="line">            Flavor = flavor,</span><br><span class="line">            DebuggingLibraries = orderedDebugLibraries.ToImmutableArray(),</span><br><span class="line">            ContractDescriptorAddress = contractDescriptor,</span><br><span class="line">            IndexFileSize = indexFileSize,</span><br><span class="line">            IndexTimeStamp = indexTimeStamp,</span><br><span class="line">            BuildId = buildId,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知，<code>ClrInfo</code> 构造函数的最后一个参数是 <code>this</code>，所以 <code>ClrInfo</code> 中的 <code>ClrInfoProvider</code> 是 <code>DotNetClrInfoProvider</code> 类型的对象。再来查看一下 <code>DotNetClrInfoProvider::GetDacServices()</code> 函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IServiceProvider <span class="title">GetDacServices</span>(<span class="params">ClrInfo clrInfo, <span class="keyword">string</span>? providedPath, <span class="keyword">bool</span> ignoreMismatch, <span class="keyword">bool</span> verifySignature</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DacLibrary library = GetDacLibraryFromPath(clrInfo, providedPath, ignoreMismatch, verifySignature);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DacServiceProvider(clrInfo, library);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会返回 <code>DacServiceProvider</code> 类型的对象，所以 <code>ClrRuntime._services</code> 实际是 <code>DacServiceProvider</code> 类型的对象。<code>ClrRuntime</code> 的 <code>Heap</code> 属性中调用的 <code>IAbstractHeap? heapHelpers = GetService&lt;IAbstractHeap&gt;()</code> 就相当于调用的是 <code>DacServiceProvider.GetService(IAbstractHeap)</code>。</p><p>看看 <code>DacServiceProvider.GetService(Type)</code> 的实现，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DacServiceProvider</span> : <span class="title">IServiceProvider</span>, <span class="title">IDisposable</span>, <span class="title">IAbstractDacController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span>? GetService(Type serviceType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (serviceType == <span class="keyword">typeof</span>(IAbstractRuntime))</span><br><span class="line">            <span class="keyword">return</span> _runtime ??= <span class="keyword">new</span> DacRuntime(_clrInfo, _process, _sos, _sos13);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serviceType == <span class="keyword">typeof</span>(IAbstractHeap)) <span class="comment">//&lt;---</span></span><br><span class="line">        &#123;</span><br><span class="line">            IAbstractHeap? heap = _heapHelper;</span><br><span class="line">            <span class="keyword">if</span> (heap <span class="keyword">is</span> not <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> heap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_sos.GetGCHeapData(<span class="keyword">out</span> GCInfo data) &amp;&amp; _sos.GetCommonMethodTables(<span class="keyword">out</span> CommonMethodTables mts) &amp;&amp; mts.ObjectMethodTable != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> _heapHelper = <span class="keyword">new</span> DacHeap(_sos, _sos8, _sos12, _sos16, _dataReader, data, mts);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>ClrHeap</code> 中的 <code>Helpers</code> 成员的类型是 <code>DacHeap</code>，看看其 <code>GetOOMInfo()</code> 的实现。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DacHeap</span> : <span class="title">IAbstractHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">GetOOMInfo</span>(<span class="params"><span class="keyword">ulong</span> subHeapAddress, <span class="keyword">out</span> OomInfo oomInfo</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DacOOMData oomData;</span><br><span class="line">        <span class="keyword">if</span> (subHeapAddress != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_sos.GetOOMData(subHeapAddress, <span class="keyword">out</span> oomData) || oomData.Reason == OutOfMemoryReason.None &amp;&amp; oomData.GetMemoryFailure == GetMemoryFailureReason.None)</span><br><span class="line">            &#123;</span><br><span class="line">                oomInfo = <span class="keyword">default</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_sos.GetOOMData(<span class="keyword">out</span> oomData) || oomData.Reason == OutOfMemoryReason.None &amp;&amp; oomData.GetMemoryFailure == GetMemoryFailureReason.None)</span><br><span class="line">            &#123;</span><br><span class="line">                oomInfo = <span class="keyword">default</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oomInfo = <span class="keyword">new</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            AllocSize = oomData.AllocSize,</span><br><span class="line">            AvailablePageFileMB = oomData.AvailablePageFileMB,</span><br><span class="line">            GCIndex = oomData.GCIndex,</span><br><span class="line">            GetMemoryFailure = oomData.GetMemoryFailure,</span><br><span class="line">            IsLOH = oomData.IsLOH != <span class="number">0</span>,</span><br><span class="line">            Reason = oomData.Reason,</span><br><span class="line">            Size = oomData.Size,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了 <code>_sos.GetOOMData(out oomData)</code>。<code>_sos</code> 是 <code>DacHeap</code> 的成员变量，来自 <code>DacHeap</code> 构造函数的第一个参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DacHeap</span> : <span class="title">IAbstractHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac _sos; <span class="comment">//&lt;--</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac8? _sos8;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DacHeap</span>(<span class="params">SOSDac sos, SOSDac8? sos8, SosDac12? sos12, ISOSDac16? sos16, IMemoryReader reader, <span class="keyword">in</span> GCInfo gcInfo, <span class="keyword">in</span> CommonMethodTables commonMethodTables</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _sos = sos; <span class="comment">//&lt;--</span></span><br><span class="line">        _sos8 = sos8;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>DacHeap</code> 又是在 <code>DacServiceProvider.GetService(Type)</code> 中创建的，关键代码是</p><p><code>return _heapHelper = new DacHeap(_sos, _sos8, _sos12, _sos16, _dataReader, data, mts);</code></p><p>传递给 <code>DacHeap</code> 的第一个参数是 <code>DacServiceProvider</code> 的成员变量 <code>_sos</code>。该成员变量是在 <code>DacServiceProvider</code> 的构造函数中初始化的。构造函数如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DacServiceProvider</span> : <span class="title">IServiceProvider</span>, <span class="title">IDisposable</span>, <span class="title">IAbstractDacController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ClrInfo _clrInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IDataReader _dataReader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DacLibrary _dac;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ClrDataProcess _process;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac _sos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac6? _sos6;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DacServiceProvider</span>(<span class="params">ClrInfo clrInfo, DacLibrary library</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _clrInfo = clrInfo;</span><br><span class="line">        _dataReader = _clrInfo.DataTarget.DataReader;</span><br><span class="line"></span><br><span class="line">        _dac = library;</span><br><span class="line">        _process = library.CreateClrDataProcess();</span><br><span class="line">        _sos = _process.CreateSOSDacInterface() ?? <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">$"Could not create ISOSDacInterface."</span>); <span class="comment">//&lt;--</span></span><br><span class="line">        _sos6 = _process.CreateSOSDacInterface6();</span><br><span class="line"></span><br><span class="line">        library.DacDataTarget.SetMagicCallback(_process.Flush);</span><br><span class="line">        IsThreadSafe = _sos13 <span class="keyword">is</span> not <span class="literal">null</span> || RuntimeInformation.IsOSPlatform(OSPlatform.Windows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_sos</code> 是由 <code>_process.CreateSOSDacInterface()</code> 创建的，而 <code>_process</code> 的类型是 <code>ClrDataProcess</code>，看一下 <code>_process.CreateSOSDacInterface()</code> 的实现，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">ClrDataProcess</span> : <span class="title">CallableCOMWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Guid IID_IXCLRDataProcess = <span class="keyword">new</span>(<span class="string">"5c552ab6-fc09-4cb3-8e36-22fa03c798b7"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DacLibrary _library;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SOSDac? CreateSOSDacInterface()</span><br><span class="line">    &#123;</span><br><span class="line">        IntPtr result = QueryInterface(SOSDac.IID_ISOSDac);</span><br><span class="line">        <span class="keyword">if</span> (result == IntPtr.Zero)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SOSDac(_library, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvalidOperationException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数会返回 <code>SOSDac</code> 类型的对象，该类型构造函数的第二个参数是通过 <code>QueryInterface(SOSDac.IID_ISOSDac)</code> 得到的，<code>SOSDac.IID_ISOSDac</code> 的值是 <code>436f00f2-b42a-4b9f-870c-e73db66ae930</code>，是 <code>SOSDac</code> 类的静态变量，<code>SOSDac</code> 的定义如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">SOSDac</span> : <span class="title">CallableCOMWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Guid IID_ISOSDac = <span class="keyword">new</span>(<span class="string">"436f00f2-b42a-4b9f-870c-e73db66ae930"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DacLibrary _library;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt;? _regNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Dictionary&lt;<span class="keyword">ulong</span>, <span class="keyword">string</span>&gt;? _frameNames;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SOSDac</span>(<span class="params">DacLibrary? library, IntPtr ptr</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">library?.OwningLibrary, IID_ISOSDac, ptr</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _library = library ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(library));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">ref</span> <span class="keyword">readonly</span> ISOSDacVTable VTable =&gt; <span class="keyword">ref</span> Unsafe.AsRef&lt;ISOSDacVTable&gt;(_vtable);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SOSDac</span>(<span class="params">DacLibrary lib, CallableCOMWrapper toClone</span>) : <span class="title">base</span>(<span class="params">toClone</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _library = lib;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HResult <span class="title">GetOOMData</span>(<span class="params"><span class="keyword">out</span> DacOOMData oomData</span>)</span> =&gt; VTable.GetOOMStaticData(Self, <span class="keyword">out</span> oomData);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HResult <span class="title">GetOOMData</span>(<span class="params"><span class="keyword">ulong</span> address, <span class="keyword">out</span> DacOOMData oomData</span>)</span> =&gt; VTable.GetOOMData(Self, address, <span class="keyword">out</span> oomData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类什么有用的事情都没做，都是调用 <code>VTable</code> 中的实现，而且其基类是 <code>CallableCOMWrapper</code>，可以大胆猜测此类是一个 <code>COM</code> 调用类，真正的实现在 <code>native</code> 层。是不是呢？到 <code>native</code> 层搜搜就知道了。</p><h2 id="查看-clr-runtime-实现"><a href="#查看-clr-runtime-实现" class="headerlink" title="查看 clr runtime 实现"></a>查看 clr runtime 实现</h2><p>在  <code>native</code> 代码中搜索 <code>436f00f2-b42a-4b9f-870c-e73db66ae930</code>，可以在 <code>sospriv.h</code> 头文件中搜到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MIDL_INTERFACE(<span class="string">"436f00f2-b42a-4b9f-870c-e73db66ae930"</span>) <span class="comment">//&lt;---</span></span><br><span class="line">ISOSDacInterface : <span class="keyword">public</span> IUnknown</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">GetOOMData</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">        CLRDATA_ADDRESS oomAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct DacpOomData *data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">GetOOMStaticData</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">        struct DacpOomData *data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继续搜索 <code>ISOSDacInterface</code>，可以在 <code>daccess.cpp</code> 中找到使用的地方，对应的实现类是 <code>ClrDataAccess</code>。</p><blockquote><p><strong>说明：</strong> 对应的声明文件在 <code>D:\dotnet\runtime\src\coreclr\debug\daccess\dacimpl.h</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\debug\daccess\daccess.cpp</span></span><br><span class="line"></span><br><span class="line">STDMETHODIMP</span><br><span class="line">ClrDataAccess::QueryInterface(THIS_</span><br><span class="line">                              IN REFIID interfaceId,</span><br><span class="line">                              OUT PVOID* iface)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* ifaceRet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsEqualIID(interfaceId, IID_IUnknown) ||</span><br><span class="line">        IsEqualIID(interfaceId, __uuidof(IXCLRDataProcess)) ||</span><br><span class="line">        IsEqualIID(interfaceId, __uuidof(IXCLRDataProcess2)))</span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;IXCLRDataProcess2*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsEqualIID(interfaceId, __uuidof(ICLRDataEnumMemoryRegions)))</span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;ICLRDataEnumMemoryRegions*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsEqualIID(interfaceId, __uuidof(ISOSDacInterface))) <span class="comment">//&lt;---</span></span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;ISOSDacInterface*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsEqualIID(interfaceId, __uuidof(ISOSDacInterface2)))</span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;ISOSDacInterface2*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    AddRef();</span><br><span class="line">    *iface = ifaceRet;</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以查看 <code>ClrDataAccess::GetOOMData()</code> 的具体实现，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\debug\daccess\request.cpp</span></span><br><span class="line"></span><br><span class="line">HRESULT</span><br><span class="line">ClrDataAccess::GetOOMData(CLRDATA_ADDRESS oomAddr, struct DacpOomData *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (oomAddr == <span class="number">0</span> || data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> E_INVALIDARG;</span><br><span class="line"></span><br><span class="line">    SOSDacEnter();</span><br><span class="line">    *data = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!GCHeapUtilities::IsServerHeap())</span><br><span class="line">        hr = E_FAIL; <span class="comment">// doesn't make sense to call this on WKS mode</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FEATURE_SVR_GC</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hr = ServerOomData(oomAddr, data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _ASSERTE_MSG(<span class="literal">false</span>, <span class="string">"IsServerHeap returned true but FEATURE_SVR_GC not defined"</span>);</span><br><span class="line">    hr = E_NOTIMPL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//FEATURE_SVR_GC</span></span></span><br><span class="line"></span><br><span class="line">    SOSDacLeave();</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClrDataAccess::ServerOomData()</code> 的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\debug\daccess\request_svr.cpp</span></span><br><span class="line">    </span><br><span class="line">HRESULT</span><br><span class="line">ClrDataAccess::ServerOomData(CLRDATA_ADDRESS addr, DacpOomData *oomData)</span><br><span class="line">&#123;</span><br><span class="line">    TADDR heapAddress = TO_TADDR(addr);</span><br><span class="line">    dac_gc_heap heap = LoadGcHeapData(heapAddress);</span><br><span class="line">    dac_gc_heap* pHeap = &amp;heap;</span><br><span class="line"></span><br><span class="line">    oom_history pOOMInfo = pHeap-&gt;oom_info;</span><br><span class="line">    oomData-&gt;reason = pOOMInfo.reason;</span><br><span class="line">    oomData-&gt;alloc_size = pOOMInfo.alloc_size;</span><br><span class="line">    oomData-&gt;available_pagefile_mb = pOOMInfo.available_pagefile_mb;</span><br><span class="line">    oomData-&gt;gc_index = pOOMInfo.gc_index;</span><br><span class="line">    oomData-&gt;fgm = pOOMInfo.fgm;</span><br><span class="line">    oomData-&gt;size = pOOMInfo.size;</span><br><span class="line">    oomData-&gt;loh_p = pOOMInfo.loh_p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知，<code>oomData</code> 来自 <code>pHeap-&gt;oom_info</code>，看下 <code>oom_info</code> 的定义，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\gc\gcpriv.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gc_heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    PER_HEAP_FIELD_DIAG_ONLY oom_history oom_info;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其类型是 <code>oom_history</code>，查看定义，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\gc\gcinterface.dac.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reasons why an OOM might occur, recorded in the oom_history</span></span><br><span class="line"><span class="comment">// struct below.</span></span><br><span class="line"><span class="keyword">enum</span> oom_reason</span><br><span class="line">&#123;</span><br><span class="line">    oom_no_failure = <span class="number">0</span>,</span><br><span class="line">    oom_budget = <span class="number">1</span>,</span><br><span class="line">    oom_cant_commit = <span class="number">2</span>,</span><br><span class="line">    oom_cant_reserve = <span class="number">3</span>,</span><br><span class="line">    oom_loh = <span class="number">4</span>,</span><br><span class="line">    oom_low_mem = <span class="number">5</span>,</span><br><span class="line">    oom_unproductive_full_gc = <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/</span></span><br><span class="line"><span class="comment">/* If you modify failure_get_memory and         */</span></span><br><span class="line"><span class="comment">/* oom_reason be sure to make the corresponding */</span></span><br><span class="line"><span class="comment">/* changes in ClrMD.                            */</span></span><br><span class="line"><span class="comment">/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/</span></span><br><span class="line"><span class="keyword">enum</span> failure_get_memory</span><br><span class="line">&#123;</span><br><span class="line">    fgm_no_failure = <span class="number">0</span>,</span><br><span class="line">    fgm_reserve_segment = <span class="number">1</span>,</span><br><span class="line">    fgm_commit_segment_beg = <span class="number">2</span>,</span><br><span class="line">    fgm_commit_eph_segment = <span class="number">3</span>,</span><br><span class="line">    fgm_grow_table = <span class="number">4</span>,</span><br><span class="line">    fgm_commit_table = <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A record of the last OOM that occurred in the GC, with some</span></span><br><span class="line"><span class="comment">// additional information as to what triggered the OOM.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oom_history</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    oom_reason reason;</span><br><span class="line">    <span class="keyword">size_t</span> alloc_size;</span><br><span class="line">    <span class="keyword">uint8_t</span>* reserved;</span><br><span class="line">    <span class="keyword">uint8_t</span>* allocated;</span><br><span class="line">    <span class="keyword">size_t</span> gc_index;</span><br><span class="line">    failure_get_memory fgm;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">size_t</span> available_pagefile_mb;</span><br><span class="line">    BOOL loh_p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到以上定义就太亲切了。根据目前了解到的信息，这个结构体应该是当发生 <code>OOM</code> 时，<code>runtime</code> 设置的结构体。可以在代码中搜索使用 <code>fgm_reserve_segment</code> 的地方，一共就搜到两处，一处是其定义的地方，一处是使用的地方，使用的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">heap_segment*</span><br><span class="line">gc_heap::get_segment (<span class="keyword">size_t</span> size, gc_oh_num oh)</span><br><span class="line">&#123;</span><br><span class="line">    assert(oh != gc_oh_num::unknown);</span><br><span class="line">    BOOL uoh_p = (oh == gc_oh_num::loh) || (oh == gc_oh_num::poh);</span><br><span class="line">    <span class="keyword">if</span> (heap_hard_limit)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    heap_segment* result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (segment_standby_list != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = segment_standby_list;</span><br><span class="line">        heap_segment* last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (result)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> hs = (<span class="keyword">size_t</span>)(heap_segment_reserved (result) - (<span class="keyword">uint8_t</span>*)result);</span><br><span class="line">            <span class="keyword">if</span> ((hs &gt;= size) &amp;&amp; ((hs / <span class="number">2</span>) &lt; size))</span><br><span class="line">            &#123;</span><br><span class="line">                dprintf (<span class="number">2</span>, (<span class="string">"Hoarded segment %zx found"</span>, (<span class="keyword">size_t</span>) result));</span><br><span class="line">                <span class="keyword">if</span> (last)</span><br><span class="line">                &#123;</span><br><span class="line">                    heap_segment_next (last) = heap_segment_next (result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    segment_standby_list = heap_segment_next (result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last = result;</span><br><span class="line">                result = heap_segment_next (result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span>* mem = virtual_alloc (size);</span><br><span class="line">        <span class="keyword">if</span> (!mem)</span><br><span class="line">        &#123;</span><br><span class="line">            fgm_result.set_fgm (fgm_reserve_segment, size, uoh_p); <span class="comment">//&lt;---</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，当 <code>virtual_alloc (size)</code> 的返回值是空时，会设置 <code>fgm_reserve_segment</code>。再看看 <code>virtual_alloc</code> 的实现，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">virtual_alloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> virtual_alloc(size, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">virtual_alloc</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">bool</span> use_large_pages_p, <span class="keyword">uint16_t</span> numa_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> requested_size = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">    &#123;</span><br><span class="line">        gc_heap::reserved_memory_limit =</span><br><span class="line">            GCScan::AskForMoreReservedMemory (gc_heap::reserved_memory_limit, requested_size);</span><br><span class="line">        <span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//&lt;---</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = VirtualReserveFlags::None;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP</span></span><br><span class="line">    <span class="keyword">if</span> (virtual_alloc_hardware_write_watch)</span><br><span class="line">    &#123;</span><br><span class="line">        flags = VirtualReserveFlags::WriteWatch;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;--- use_large_pages_p 是 false，会调用 GCToOSInterface::VirtualReserve</span></span><br><span class="line">    <span class="keyword">void</span>* prgmem = use_large_pages_p ?</span><br><span class="line">        GCToOSInterface::VirtualReserveAndCommitLargePages(requested_size, numa_node) :</span><br><span class="line">        GCToOSInterface::VirtualReserve(requested_size, card_size * card_word_width, flags, numa_node);</span><br><span class="line">    <span class="keyword">void</span> *aligned_mem = prgmem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want (prgmem + size) to be right at the end of the address space</span></span><br><span class="line">    <span class="comment">// because we'd have to worry about that everytime we do (address + size).</span></span><br><span class="line">    <span class="comment">// We also want to make sure that we leave loh_size_threshold at the end</span></span><br><span class="line">    <span class="comment">// so we allocate a small object we don't need to worry about overflow there</span></span><br><span class="line">    <span class="comment">// when we do alloc_ptr+size.</span></span><br><span class="line">    <span class="keyword">if</span> (prgmem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span>* end_mem = (<span class="keyword">uint8_t</span>*)prgmem + requested_size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((end_mem == <span class="number">0</span>) || ((<span class="keyword">size_t</span>)(MAX_PTR - end_mem) &lt;= END_SPACE_AFTER_GC))</span><br><span class="line">        &#123;</span><br><span class="line">            GCToOSInterface::VirtualRelease (prgmem, requested_size);</span><br><span class="line">            dprintf (<span class="number">2</span>, (<span class="string">"Virtual Alloc size %zd returned memory right against 4GB [%zx, %zx[ - discarding"</span>,</span><br><span class="line">                        requested_size, (<span class="keyword">size_t</span>)prgmem, (<span class="keyword">size_t</span>)((<span class="keyword">uint8_t</span>*)prgmem+requested_size)));</span><br><span class="line">            prgmem = <span class="number">0</span>;</span><br><span class="line">            aligned_mem = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prgmem)</span><br><span class="line">    &#123;</span><br><span class="line">        gc_heap::reserved_memory += requested_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dprintf (<span class="number">2</span>, (<span class="string">"Virtual Alloc size %zd: [%zx, %zx["</span>,</span><br><span class="line">                 requested_size, (<span class="keyword">size_t</span>)prgmem, (<span class="keyword">size_t</span>)((<span class="keyword">uint8_t</span>*)prgmem+requested_size)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aligned_mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，一共有三个地方会导致返回空，第一处代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">&#123;</span><br><span class="line">    gc_heap::reserved_memory_limit =</span><br><span class="line">        GCScan::AskForMoreReservedMemory (gc_heap::reserved_memory_limit, requested_size);</span><br><span class="line">    <span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//&lt;---</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概逻辑是，如果<strong>保留内存限值</strong>（<code>gc_heap::reserved_memory_limit</code>）- <strong>已保留的内存</strong>（<code>gc_heap::reserved_memory</code>）小于 <strong>请求字节数</strong>（<code>requested_size</code>），就调用 <code>GCScan::AskForMoreReservedMemory()</code> 请求保留更多内存，该函数会返回新的限值。如果 <strong>新限值</strong> - <strong>已保留的内存</strong> 还是小于 <strong>请求字节数</strong> 就返回空。</p><p>第二处代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* prgmem = use_large_pages_p ?</span><br><span class="line">        GCToOSInterface::VirtualReserveAndCommitLargePages(requested_size, numa_node) :</span><br><span class="line">        GCToOSInterface::VirtualReserve(requested_size, card_size * card_word_width, flags, numa_node);</span><br><span class="line">    <span class="keyword">void</span> *aligned_mem = prgmem;</span><br></pre></td></tr></table></figure><p>由于，<code>use_large_pages_p</code> 是 <code>false</code>，会调用 <code>GCToOSInterface::VirtualReserve()</code>，该函数底层又会直接调用 <code>VirtualAlloc()</code>。</p><p>第三处代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prgmem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span>* end_mem = (<span class="keyword">uint8_t</span>*)prgmem + requested_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((end_mem == <span class="number">0</span>) || ((<span class="keyword">size_t</span>)(MAX_PTR - end_mem) &lt;= END_SPACE_AFTER_GC))</span><br><span class="line">    &#123;</span><br><span class="line">        GCToOSInterface::VirtualRelease (prgmem, requested_size);</span><br><span class="line">        dprintf (<span class="number">2</span>, (<span class="string">"Virtual Alloc size %zd returned memory right against 4GB [%zx, %zx[ - discarding"</span>,</span><br><span class="line">                     requested_size, (<span class="keyword">size_t</span>)prgmem, (<span class="keyword">size_t</span>)((<span class="keyword">uint8_t</span>*)prgmem+requested_size)));</span><br><span class="line">        prgmem = <span class="number">0</span>;</span><br><span class="line">        aligned_mem = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MAX_PTR</code> 为最大的无符号整数，<code>end_mem</code> 是此次分配的内存段的结束位置，如果结束位置后面的空间不能容纳大对象堆，也返回空。</p><p>至此，本次折腾就告一段路了，第一张图片中的报错信息，基本上是 <code>virtual_alloc</code> 失败导致的问题。为什么 <code>virtual_alloc</code> 会失败，我到现在也没想明白。因为只尝试保留内存空间，并没有进行提交，按理说在有足够大的空闲内存空间时，不应该失败才对。什么情况下 <code>VirtualAlloc()</code> 会失败，还望各位大牛不吝赐教！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>再次强烈推荐一下 <code>FileLocator</code> 文件内容搜索神器，你值得拥有</li><li></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><code>.net</code> 源码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录了一次对 &lt;code&gt;.NET&lt;/code&gt; 应用程序发生的“内存不足”（&lt;code&gt;OOM&lt;/code&gt;）异常进行的深度源码级调查。问题始于一个看似矛盾的现象：诊断工具显示有足够大的空闲内存块（约 &lt;code&gt;50MB&lt;/code&gt;），但垃圾回收（&lt;code&gt;GC&lt;/code&gt;）过程却在尝试预留较小内存段（约 &lt;code&gt;16MB&lt;/code&gt;）时失败。&lt;/p&gt;
&lt;p&gt;为了探究根源，笔者&lt;strong&gt;逆向追踪了诊断工具（如SOS）输出的数据链路&lt;/strong&gt;：从高层诊断命令（&lt;code&gt;AnalyzeOOMCommand&lt;/code&gt;）入手，逐步深入&lt;code&gt;Microsoft.Diagnostics.Runtime (CLRMD)&lt;/code&gt;库、托管辅助类、&lt;code&gt;Dac&lt;/code&gt; 接口，最终直达 &lt;code&gt;.NET Runtime(CoreCLR)&lt;/code&gt; 底层的 &lt;code&gt;GC&lt;/code&gt; 相关 &lt;code&gt;Native&lt;/code&gt; 代码（如 &lt;code&gt;ClrDataAccess&lt;/code&gt;、&lt;code&gt;gc_heap&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;虽然最终并没能定位问题的真实原因，但是理清了 &lt;code&gt;GC&lt;/code&gt; 在 &lt;code&gt;virtual_alloc&lt;/code&gt;过程中因&lt;strong&gt;内存限制检查、地址空间布局考量等因素&lt;/strong&gt;导致预留失败的具体逻辑，并对 &lt;code&gt;.NET&lt;/code&gt; 源码有了一定的认识，还是非常值得记录分享的。&lt;/p&gt;
    
    </summary>
    
      <category term="NET" scheme="https://bianchengnan.github.io/categories/NET/"/>
    
    
      <category term="源码" scheme="https://bianchengnan.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term=".net" scheme="https://bianchengnan.github.io/tags/net/"/>
    
      <category term="OOM" scheme="https://bianchengnan.github.io/tags/OOM/"/>
    
      <category term="clr" scheme="https://bianchengnan.github.io/tags/clr/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 使用 GFlags 与 WinDbg 定位 VS2022 “重复释放” 引发的崩溃</title>
    <link href="https://bianchengnan.github.io//articles/debug-vs2022-double-free-crash-with-gflags-windbg/"/>
    <id>https://bianchengnan.github.io//articles/debug-vs2022-double-free-crash-with-gflags-windbg/</id>
    <published>2025-11-29T02:21:23.000Z</published>
    <updated>2025-12-23T13:51:13.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录了一次独特的调试经历：作为开发利器的 <code>Visual Studio 2022</code>，其在切换调用栈时频繁崩溃。面对这一问题，利用 <code>procdump</code> 自动捕获崩溃转储文件，并通过 <code>WinDbg</code> 初步排查将问题指向堆内存的异常操作，可能是堆损坏或重复释放。为了精准定位，我启用 <code>gflags</code> 工具开启页堆检测，最终成功捕获到首次释放操作的完整调用栈，明确问题根源在于<code>VSDebug!treegrid::CTreeGridItemContainerGenerator::Refresh</code>过程中的<strong>内存重复释放</strong>。虽然因缺少源码无法直接修复，但通过环境隔离（关闭特定程序）避免了问题复现。此次实战再次证明了 <code>procdump</code>、<code>gflags</code> 等工具在诊断复杂内存问题中的巨大价值，也提醒我们即使面对没有源码的“黑盒”组件，系统化的调试方法依然能指引我们找到问题的本质。</p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近，用 <code>vs2022</code> 在调试的时候，切换调用栈，会有很大概率崩溃。一次两次就忍了，不停的崩溃就有点说不过去了。 话不多说，先放张动图看看 <code>vs2022</code> 是怎么崩溃的。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/vs2022%E5%B4%A9%E6%BA%83.gif" alt="vs2022崩溃"></p><a id="more"></a><p>好在我已经设置了 <code>procdump</code> 为事后调试器，每当有进程崩溃的时候，都会在 <code>d:\dumps\</code> 目录下保存一份转储文件。下图是最近保存的一些转储文件（已经清理过几次了）。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/recent-dump-files.png" alt="recent-dump-files"></p><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>老规矩，使用 <code>windbg</code> 打开对应的转储文件，先无脑 <code>!analyze -v</code> 一波，没看到有用的信息。执行 <code>k</code> 命令查看调用栈，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/delete-exception.png" alt="delete-exception"></p><p>看到熟悉的 <code>delete</code> 基本就猜到是堆出问题了，或者是堆破坏或者是重复释放。如果能找到 <code>delete</code> 的地址，然后使用地址相关命令（比如， <code>!address</code> 或者 <code>!heap -x addr</code> 命令）应该是可以看到一些信息的。那么该如何找到这个地址呢？</p><h2 id="查找关键地址"><a href="#查找关键地址" class="headerlink" title="查找关键地址"></a>查找关键地址</h2><p><code>64</code> 位程序一般是 <code>__stdcall</code>，一般第一个参数是通过 <code>rcx</code> 传递的，但是寄存器的值随着调用其它函数是会改变的，除非保存到栈上过。为了查看传递给 <code>delete</code> 的参数，找到调用它的栈帧。找到栈帧 <code>10</code> （<code>VSDebug!operator delete+0x9</code>）对应的返回地址(<code>00007fff98f13082</code>)，使用 <code>ub</code> 查看对应的反汇编。查看是否有保存 <code>rcx</code> 的操作，没有的话，继续向调用方向找（当然也可以向被调用方向查找是否有保存 <code>rcx</code> 的操作）。直到找到栈帧 <code>12</code> 的返回值地址，</p><p><code>12 0000002899dad690 00007fff99103111     VSDebug!CClassFactory&lt;CRefCount&gt;::Release+0x27</code></p><p>使用 <code>ub 00007fff99103111 L28</code>（为什么 <code>L28</code>，因为好截图）</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/find-the-addres-being-deleted.png" alt="find-the-addres-being-deleted"></p><p>从图中可知，<code>rcx</code> 来自 <code>rbx</code>，而 <code>rbx</code> 的值被保存到当前栈帧（栈帧 <code>13</code>） <code>rsp+0x40</code> 的位置上过。</p><p>执行 <code>dq 0000002899dad6c0 + 0x40 L2</code> 然后执行 <code>!address 0000014185ce4360</code>，然后执行 <code>!heap -x 0x14185ce4360</code>，可以发现这个地址确实是 <code>free</code> 的。如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/verify-the-adress-has-been-deleted.png" alt="verify-the-adress-has-been-deleted"></p><p>虽然这里的值不是 <code>100%</code> 靠谱，但是也能在一定程度上证实我们的猜测。其实，解决堆相关问题，可以使用神器 <code>gflags</code>，可以在尽可能早的时候把问题暴露出来。</p><h2 id="设置-gflags"><a href="#设置-gflags" class="headerlink" title="设置 gflags"></a>设置 gflags</h2><p>打开 <code>gflags.exe</code>，切换到 <code>Image File</code> 页，在 <code>Image:(TAB to refresh)</code> 后面的编辑框内输入 <code>vs</code> 的进程名 <code>devenv.exe</code>，然后按 <code>TAB</code> 键。可以无脑勾选跟堆相关的所有选项。每一项的具体意义可以询问 AI，给出的解释比较靠谱。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/set-gflags-for-devenv.png" alt="set-gflags-for-devenv"></p><p>当然，也可以通过命令行执行，最终都是操作注册表（下表摘自<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/gflags-details" target="_blank" rel="noopener">微软官方文档</a>）：</p><table><thead><tr><th align="left">设置类型</th><th align="left">注册表位置</th></tr></thead><tbody><tr><td align="left">系统级设置（注册表）</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\GlobalFlag</td></tr><tr><td align="left">特定程序的设置（“映像文件”）适用于计算机的所有用户。</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\GlobalFlag</td></tr><tr><td align="left">特定程序的无提示退出设置（“无提示进程退出”）适用于计算机的所有用户。</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\ImageFileName</td></tr><tr><td align="left">计算机的所有用户的图像文件的页堆选项</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\PageHeapFlags</td></tr><tr><td align="left">用户模式堆栈跟踪数据库大小 （<strong>tracedb</strong>）</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\StackTraceDatabaseSizeInMb</td></tr><tr><td align="left">为图像文件创建用户模式堆栈跟踪数据库（ust、0x1000）</td><td align="left">Windows 将映像文件名添加到 USTEnabled 注册表项的值（HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\USTEnabled）。</td></tr><tr><td align="left">在可能的情况下大型页加载映像</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\UseLargePages。</td></tr><tr><td align="left">特殊池（内核特殊池标记）</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PoolTag</td></tr><tr><td align="left">验证开始/验证结束</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PoolTagOverruns。 “ <strong>验证开始</strong> ”选项将值设置为 0。 “ <strong>验证结束</strong> ”选项将值设置为 1。</td></tr><tr><td align="left">映像文件的调试器</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\调试器</td></tr><tr><td align="left">对象引用跟踪</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Kernel\ObTraceProcessName  ObTracePermanent 和 ObTracePoolTags</td></tr></tbody></table><p>配置好后，再次重现问题，打开转储文件，再次进行分析。</p><h2 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h2><p>执行 <code>k</code> 命令，可以发现在 <code>GetParent</code> 函数内部触发了异常。如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/callstack-after-turn-on-gflags.png" alt="callstack-after-turn-on-gflags"></p><p>执行 <code>.ecxr</code> 查看异常发生时的上下文，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/ecxr-after-turn-on-gflags.png" alt="ecxr-after-turn-on-gflags"></p><p>第一眼就感觉 <code>rax</code> 的值好特殊啊。看看它的来源，很幸运，在崩溃代码附近（<code>00007fff984e309a</code>）执行 <code>ub</code> 和 <code>u</code> 操作可以找到完整信息，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/virtual-function-call-when-crash.png" alt="virtual-function-call-when-crash"></p><p>红色高亮部分是非常典型的虚函数调用代码。<code>rax</code> 指向虚表，<code>rbx</code> 是对象地址。非常幸运的是在红框上方，把 <code>rbx</code> 保存到了栈 <code>rsp+40h</code> 的地方。其实，没必要，因为当前上下文是异常发生时的上下文（执行了 <code>.ecxr</code> 命令），直接可以获取 <code>rbx</code> 的值。通过查看栈上的值，也佐证了这个观点。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/verify-rbx-by-rsp.png" alt="verify-rbx-by-rsp"></p><p>拿到对象地址后，执行 <code>!address 000001a053fd31f0</code> 和 <code>!heap -x 000001a053fd31f0</code></p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/view-heap-address-info.png" alt="view-heap-address-info"></p><p>从图中没看出特别明显的错误（尤其注意 <code>Flags</code> 的值）。我们已经使用 <code>gflags</code> 开启页堆，并且开启了 <code>ust</code>，可以通过 <code>!heap -p -a 0x1a053fd31f0</code> 命令查看此地址相关的调用栈，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/heap-p-a-address.png" alt="heap-p-a-address"></p><p>从上图可知，在 <code>VSDebug!treegrid::CTreeGridItemContainerGenerator::Refresh</code> 的时候已经触发了 <code>delete</code> 操作，至此，已经可以确认这是个重复释放的问题了，而且第一次释放时的调用栈也很清楚。</p><p>虽然问题已经很明确了，但是我堆 <code>f0f0f0f0f0f0f0f0</code> 这个填充模式充满了好奇。</p><h2 id="填充模式"><a href="#填充模式" class="headerlink" title="填充模式"></a>填充模式</h2><p>我在查看 <code>windbg</code> 帮助文档关于 <code>!heap</code> 部分时，意外发现了它的意义。原来是开启轻型页堆时，内存被释放后，会用此模式填充。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/fill-pattern-explanation-from-windbg-help-document.png" alt="fill-pattern-explanation-from-windbg-help-document"></p><p>而且，我还发现了其它几个有意思的填充值，赶紧实战验证下，通过上面的 <code>!heap -x 000001a053fd31f0</code> 命令已经得到了对应的 <code>Heap Entry</code> 的地址是 <code>000001a053fd31a0</code>。使用 <code>dd 000001a053fd31a0 L80</code> 命令看一下这段内存数据的值。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/view-memory-patttern.png" alt="view-memory-patttern"></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>虽然查到问题了，但是没有代码，也没法解决。但是在整个折腾的过程中发现只有开着某个特定程序的时候，<code>vs</code> 才会崩溃，关闭这个特定程序后 <code>vs</code> 就不再崩溃了。应该是那个程序使用了 <code>UIA</code> 相关接口，做了一些事情，导致 <code>vs</code>  崩溃。</p><p>就不再继续折腾了，有时候不是所有问题都要有一个明确的答案，这也算是解决问题的一种方式吧。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>我已经把对应的转储文件上传到百度云盘了，感兴趣的小伙伴可以下载，亲自实战一番。</p><p>链接: <a href="https://pan.baidu.com/s/15Xa-pCeezeHNwNVwJfGzxA" target="_blank" rel="noopener">https://pan.baidu.com/s/15Xa-pCeezeHNwNVwJfGzxA</a> 提取码: puv8</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/gflags-details" target="_blank" rel="noopener">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/gflags-details</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>procdump</code> 是收集转储文件的神兵利器，一定要放到自己的武器库里</li><li><code>gflags</code> 是解决内存破坏问题的神器，一定要放到自己的武器库里</li><li><code>gflags</code> 最终结果是设置注册表，必要时可以手动设置</li><li><code>x64</code> 位程序默认调用约定是 <code>__stdcall</code>，第一个参数一般会通过 <code>rcx</code> 传递</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录了一次独特的调试经历：作为开发利器的 &lt;code&gt;Visual Studio 2022&lt;/code&gt;，其在切换调用栈时频繁崩溃。面对这一问题，利用 &lt;code&gt;procdump&lt;/code&gt; 自动捕获崩溃转储文件，并通过 &lt;code&gt;WinDbg&lt;/code&gt; 初步排查将问题指向堆内存的异常操作，可能是堆损坏或重复释放。为了精准定位，我启用 &lt;code&gt;gflags&lt;/code&gt; 工具开启页堆检测，最终成功捕获到首次释放操作的完整调用栈，明确问题根源在于&lt;code&gt;VSDebug!treegrid::CTreeGridItemContainerGenerator::Refresh&lt;/code&gt;过程中的&lt;strong&gt;内存重复释放&lt;/strong&gt;。虽然因缺少源码无法直接修复，但通过环境隔离（关闭特定程序）避免了问题复现。此次实战再次证明了 &lt;code&gt;procdump&lt;/code&gt;、&lt;code&gt;gflags&lt;/code&gt; 等工具在诊断复杂内存问题中的巨大价值，也提醒我们即使面对没有源码的“黑盒”组件，系统化的调试方法依然能指引我们找到问题的本质。&lt;/p&gt;
&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近，用 &lt;code&gt;vs2022&lt;/code&gt; 在调试的时候，切换调用栈，会有很大概率崩溃。一次两次就忍了，不停的崩溃就有点说不过去了。 话不多说，先放张动图看看 &lt;code&gt;vs2022&lt;/code&gt; 是怎么崩溃的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/vs2022%E5%B4%A9%E6%BA%83.gif&quot; alt=&quot;vs2022崩溃&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="gflags" scheme="https://bianchengnan.github.io/tags/gflags/"/>
    
      <category term="vs222" scheme="https://bianchengnan.github.io/tags/vs222/"/>
    
      <category term="debugger" scheme="https://bianchengnan.github.io/tags/debugger/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 一个隐蔽的崩溃：当 this 指针在构造函数中“杀死”自己</title>
    <link href="https://bianchengnan.github.io//articles/debug-unexpected-crash-due-to-misuse-of-refcountedptr/"/>
    <id>https://bianchengnan.github.io//articles/debug-unexpected-crash-due-to-misuse-of-refcountedptr/</id>
    <published>2025-11-22T11:21:23.000Z</published>
    <updated>2025-12-23T13:51:13.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在最近的项目开发中，我遇到了一个由智能指针误用导致的程序崩溃问题。问题的根源在于 <code>SheetDataHandler</code> 类的构造函数中，将 <code>this</code> 指针传递给了一个接收 <code>SheetDataHandlerPtr</code>（智能指针类型）参数的静态函数 <code>HandleMissingColumn</code>。这个看似简单的操作，却导致了对象在构造函数执行期间被意外释放，最终引发空指针访问异常。</p><p>通过深入调试和反汇编分析，我发现当 <code>this</code> 指针被隐式转换为智能指针时，引用计数会从 <code>0</code> 增加到 <code>1</code>，而在函数调用结束后，智能指针对象析构时引用计数又减回 <code>0</code>，从而触发了对象的 <code>delete</code> 操作。这导致构造函数尚未执行完毕，对象就已经被销毁，后续对成员变量的访问变成了访问已释放内存的非法操作。</p><a id="more"></a><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>以下是我精简整理后的模拟代码，大家可以先锻炼一下眼力，看看是否可以一眼看出问题所在。关于 <code>RefCountedPtr</code> 的代码就不列出来了，可以参考<a href="https://bianchengnan.github.io/articles/mixed-use-of-different-shared-ptr/">之前的文章</a>。</p><blockquote><p><strong>提示</strong>：问题出在 <code>SheetDataHandler.cpp</code> 中。</p></blockquote><ul><li>表格数据处理类头文件 <code>SheetDataHandler.h</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SheetDataHandler.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RefCountedPtr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::wstring&gt; headers;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt;&gt; datasVec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataHandler</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> RefCountedPtr&lt;SheetDataHandler&gt; SheetDataHandlerPtr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataHandler</span> :</span> <span class="keyword">public</span> RefCounted&lt;IRefCounted&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SheetDataHandler(<span class="keyword">const</span> SheetData&amp; sheetData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleMissingColumn</span><span class="params">(SheetDataHandlerPtr helper, <span class="keyword">const</span> SheetData&amp; sheetData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetRowDataPtr&gt; rowDatas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::wstring&gt; headers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>表格数据处理类实现文件 <code>SheetDataHandler.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SheetDataHandler.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"></span><br><span class="line">SheetDataHandler::SheetDataHandler(<span class="keyword">const</span> SheetData&amp; sheetData)</span><br><span class="line">&#123;</span><br><span class="line">    HandleMissingColumn(<span class="keyword">this</span>, sheetData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SheetDataHandler::HandleMissingColumn(SheetDataHandlerPtr helper, <span class="keyword">const</span> SheetData&amp; sheetData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> headers = sheetData.headers;</span><br><span class="line">    <span class="keyword">auto</span> datasVec = sheetData.datasVec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle logic</span></span><br><span class="line"></span><br><span class="line">    helper-&gt;headers = headers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; rowData : datasVec)</span><br><span class="line">    &#123;</span><br><span class="line">        helper-&gt;rowDatas.push_back(<span class="built_in">std</span>::make_shared&lt;SheetRowData&gt;(helper, rowData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>表格数据类头文件 <code>SheetRowData.h</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SheetRowData.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RefCountedPtr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetCellData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SheetCellData() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    SheetCellData(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; data_) : data(data_), type(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::wstring data;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataHandler</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> RefCountedPtr&lt;SheetDataHandler&gt; SheetDataHandlerPtr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetRowData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SheetRowData() = <span class="keyword">default</span>;</span><br><span class="line">    SheetRowData(SheetDataHandlerPtr sdhPtr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt; cells);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt; cells;</span><br><span class="line">    SheetDataHandlerPtr sdhPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SheetRowData&gt; SheetRowDataPtr;</span><br></pre></td></tr></table></figure><ul><li>表格数据类实现文件 <code>SheetRowData.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SheetRowData.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"></span><br><span class="line">SheetRowData::SheetRowData(SheetDataHandlerPtr sdhPtr_, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt; cells_) : sdhPtr(sdhPtr_), cells(cells_)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>表格数据处理流程管理类头文件 <code>SheetDataProcessManager.h</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SheetDataProcessManager.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataProcessManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SheetDataProcessManager&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetData&gt; ReadSheetDatas(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetDataHandlerPtr&gt; sdhMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>表格数据处理流程管理类实现文件 <code>SheetDataProcessManager.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SheetDataProcessManager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataProcessManager.h"</span></span></span><br><span class="line"></span><br><span class="line">SheetDataProcessManager&amp; SheetDataProcessManager::Instance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> SheetDataProcessManager s_instance;</span><br><span class="line">    <span class="keyword">return</span> s_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetData&gt; SheetDataProcessManager::ReadSheetDatas(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetData&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read from excel</span></span><br><span class="line"></span><br><span class="line">    SheetData sheet1;</span><br><span class="line">    sheet1.headers = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::wstring&gt;&#123; <span class="string">L"ID"</span>, <span class="string">L"Name"</span>, <span class="string">L"Age"</span> &#125;;</span><br><span class="line">    sheet1.datasVec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt;&gt;&#123; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt;&#123; SheetCellData(<span class="string">L"001"</span>), SheetCellData(<span class="string">L"test"</span>), SheetCellData(<span class="string">L"18"</span>) &#125;&#125;;</span><br><span class="line">    result[<span class="string">L"Sheet1"</span>] = sheet1;</span><br><span class="line"></span><br><span class="line">    result[<span class="string">L"Sheet2"</span>] = SheetData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SheetDataProcessManager::Init(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> sheetDatas = ReadSheetDatas(path);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : sheetDatas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> handler = <span class="keyword">new</span> SheetDataHandler(it.second);</span><br><span class="line">        sdhMap[it.first] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SheetDataProcessManager::Handle()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主文件 <code>TestRefCountedPtrCrash.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TestRefCountedPtrCrash.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataProcessManager.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SheetDataProcessManager::Instance().Init(<span class="string">L"test.xlsx"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>优化完代码，执行测试时，遇到了一个崩溃问题，从错误提示看是读取非法地址（<code>0xFFFFFFFFFFFFFFF7</code>）导致的异常。从调用栈看是在执行 <code>RefCountedPtr</code> 的构造函数时发生的异常，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/refcountedptr-assignment-error.png" alt="refcountedptr-assignment-error"></p><p>好奇怪，其基类成员 <code>m_refCount</code> 的值是 <code>-572662307</code>，一个负数，按理说不应该是负数才对。<code>this-&gt;p_</code> 的值是 <code>0x000002519d2d2960</code>，并不是 <code>0xFFFFFFFFFFFFFFF7</code>，为什么会提示 <code>this-&gt;_p-&gt;</code> 是 <code>0xFFFFFFFFFFFFFFF7</code> 呢？先不管了，翻看一下上下文相关代码，没看到明显错误，应该是执行以下代码导致的异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdhMap[it.first] = handler;</span><br></pre></td></tr></table></figure><p>可是这行代码简单到不能再简单了——把对象保存到 <code>map</code> 中，这能出什么问题？既然代码看不出什么问题，那就还是回到发生异常的代码处看看吧。</p><h2 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h2><p>查看最顶层栈帧对应的代码，根据经验，最可能发生异常的是这句话 <code>p_-&gt;AddRef()</code>。具体查看一下发生异常时的汇编指令，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/call-virtual-function-AddRef.png" alt="call-virtual-function-AddRef"></p><p>红色高亮部分是明显的虚函数调用汇编代码、<code>rcx</code> 指向 <code>p_</code>，<code>rax</code> 指向虚表。<code>rax+8</code> 指向虚表第一个函数。等等，<code>rax</code> 的值怎么这么大？而且好像是十进制的，这时候我才发现我没开启十六进制显示。那赶紧看看对应的十六进制是什么？如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/view-values-in-hex.png" alt="view-values-in-hex"></p><p>真是不看不知道，一看吓一跳啊！！！ <code>rax</code> 的值是 <code>0xdddddddddddddddd</code>。而且注意看，<code>m_refCount</code> 的值也是 <code>0xdddddddd</code>。这个值可太熟悉了，当一个对象被删除时，<code>debug</code> 模式下会用 <code>0xdddddddd</code> 填充。难道这个指针被删除后，还在继续使用？查看一下这个指针的来源。查看代码可知，指针来源于 <code>auto handler = new SheetDataHandler(it.second);</code>。难道 <code>new</code> 返回的指针被释放了？代码如此简单，难道是构造函数内部出问题了？赶紧查看构造函数的实现。</p><h2 id="构造函数惹的祸"><a href="#构造函数惹的祸" class="headerlink" title="构造函数惹的祸"></a>构造函数惹的祸</h2><p>构造函数内部只调用了静态函数 <code>HandleMissingColumn(this, sheetData);</code>，并且把当前对象地址当作第一个参数传过去了。再看下这个静态函数的声明，<code>void SheetDataHandler::HandleMissingColumn(SheetDataHandlerPtr helper, const SheetData&amp; sheetData)</code>。第一个参数是一个基于引用计数的智能指针对象。至此，思索片刻，我明白了问题所在，正是这个函数的第一个参数导致了问题。执行构造函数时，引用计数是 <code>0</code>，通过 this 指针构造一个 <code>RefCountedPtr</code>，引用计数 <code>+1</code>，当这个 <code>RefCountedPtr</code> 对象声明周期结束时，引用计数 <code>-1</code> ，引用计数会变成 <code>0</code>，当引用计数变成 <code>0</code> 的时候，会触发执行 <code>delete</code>。怎么证明呢？直接在 <code>RefCounted::Release()</code> 函数加断点，再次运行程序，果然命中，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/delete-self-in-constructor.png" alt="delete-self-in-constructor"></p><p>找到问题根源，解决起来就简单了，只需要修改 <code>void SheetDataHandler::HandleMissingColumn(SheetDataHandlerPtr helper, const SheetData&amp; sheetData)</code> 的第一个参数为原生指针即可。或者在构造函数外部调用此函数也可以解决问题。</p><p>但是，这段代码之前运行一直没问题，为什么最近才暴雷呢？</p><h2 id="消除疑问"><a href="#消除疑问" class="headerlink" title="消除疑问"></a>消除疑问</h2><p>仔细想了一下，之前一直没问题，是因为一直能读取到数据。当有数据时，<code>HandleMissingColumn()</code> 函数内部会调用下面这行代码 <code>helper-&gt;rowDatas.push_back(std::make_shared&lt;SheetRowData&gt;(helper, rowData));</code> ，此行代码会构造一个 <code>SheetRowData</code> 对象，该对象内部有一个成员变量 <code>SheetDataHandlerPtr sdhHelper</code>，会增加引用计数。所以一直没发现这个问题。这下终于把所有疑问都搞清楚了，但是正是因为这番刨根问题，让我又意识到了这段代码中存在的另外一个问题——潜在的内存泄漏。</p><h2 id="潜在的内存泄漏"><a href="#潜在的内存泄漏" class="headerlink" title="潜在的内存泄漏"></a>潜在的内存泄漏</h2><p>为什么会导致内存泄漏呢？如果外部只是把 <code>sdhMap</code> 直接清空，当有数据时，<code>SheetDataHandler</code> 的析构函数是不会被调用的，因为 <code>SheetRowData</code> 中还持有着 <code>SheetDataHandlerPtr</code>。要想释放掉内存，就要在清空 <code>sdhMap</code> 前，先清空 <code>SheetDataHandler</code> 对象中的 <code>rowDatas</code>。这样就不会泄漏了。其实，更优雅的做法是使用标准库提供的 <code>std::weak_ptr</code>，让 <code>SheetRowData</code> 中持有 <code>std::weak_ptr&lt;SheetDataHandler&gt;</code>，使用的时候提升成 <code>std::shared_ptr</code>，如果提升成功，可以正常使用，如果失败，说明已经被删除，不能继续使用。</p><h2 id="无解的-vs-异常提示"><a href="#无解的-vs-异常提示" class="headerlink" title="无解的 vs 异常提示"></a>无解的 vs 异常提示</h2><p>当异常发生时，<code>vs</code> 中报的错误是 <code>引发了异常：读取访问权限冲突。this-&gt;p_ -&gt; 是 0xFFFFFFFFFFFFFFF7</code>。分析完整个异常，也没找到这个 <code>0xFFFFFFFFFFFFFFF7</code> 来自哪里，按理说应该访问 <code>0xdddddddddddddddd + 8</code> 这个地址触发的异常才对。于是保存了一个 <code>dump</code>，在 <code>windbg</code> 中打开，输入 <code>.ecxr</code> 指令查看异常发生时的指令及寄存器信息，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/check-exception-in-windbg.png" alt="check-exception-in-windbg"></p><p> 确实是无法访问 <code>0xdddddddddddddddd + 8</code> 地址对应的内存。不知道 <code>vs</code> 为什么会给出这么一个提示，希望有知道的朋友不吝赐教！</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>相关工程代码已经上传到 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/debug-unexpected-crash-due-to-misuse-of-refcountedptr\TestRefCountedPtrCrash" target="_blank" rel="noopener">github</a> 了，感兴趣的小伙伴儿可以下载验证。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/crtsetdbgflag?view=msvc-170" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/crtsetdbgflag?view=msvc-170</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在构造函数中一定不能把 <code>this</code> 指针当作 <code>RefCountedPtr</code> 使用</li><li><code>0xdddddddd</code> 是常用的删除后的填充数据，需要提高敏感度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在最近的项目开发中，我遇到了一个由智能指针误用导致的程序崩溃问题。问题的根源在于 &lt;code&gt;SheetDataHandler&lt;/code&gt; 类的构造函数中，将 &lt;code&gt;this&lt;/code&gt; 指针传递给了一个接收 &lt;code&gt;SheetDataHandlerPtr&lt;/code&gt;（智能指针类型）参数的静态函数 &lt;code&gt;HandleMissingColumn&lt;/code&gt;。这个看似简单的操作，却导致了对象在构造函数执行期间被意外释放，最终引发空指针访问异常。&lt;/p&gt;
&lt;p&gt;通过深入调试和反汇编分析，我发现当 &lt;code&gt;this&lt;/code&gt; 指针被隐式转换为智能指针时，引用计数会从 &lt;code&gt;0&lt;/code&gt; 增加到 &lt;code&gt;1&lt;/code&gt;，而在函数调用结束后，智能指针对象析构时引用计数又减回 &lt;code&gt;0&lt;/code&gt;，从而触发了对象的 &lt;code&gt;delete&lt;/code&gt; 操作。这导致构造函数尚未执行完毕，对象就已经被销毁，后续对成员变量的访问变成了访问已释放内存的非法操作。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="warning" scheme="https://bianchengnan.github.io/tags/warning/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 永远不要忽略编译警告：记一次由重复switch语句导致的诡异崩溃</title>
    <link href="https://bianchengnan.github.io//articles/debug-unexpected-crash-and-never-ignore-compiling-warnings/"/>
    <id>https://bianchengnan.github.io//articles/debug-unexpected-crash-and-never-ignore-compiling-warnings/</id>
    <published>2025-11-22T02:21:23.000Z</published>
    <updated>2025-12-23T13:51:13.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录并剖析了一次由看似低级的代码错误引发的、令人意想不到的程序崩溃。问题的根源在于 <code>GetErrorStr</code> 函数中一个容易被忽略的重复 <code>switch</code>语句。这个错误导致函数返回的 <code>std::wstring</code> 对象未被正确初始化，最终在构造 <code>CResult</code> 对象时引发了空指针访问异常 。</p><p>本文通过深入分析崩溃调用栈和反汇编代码，清晰地总结了从函数异常返回（未初始化字符串）到调用端使用无效数据（触发崩溃）的完整过程。希望这个案例能提醒各位，<strong>编译警告是发现潜在风险的第一道防线</strong>，而<strong>基础的汇编知识则是深入调试的利器</strong>。文末有可复现问题的代码，欢迎动手实践。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>好久没写文章了，一个是懒，一个是没有好的素材。最近在研发过程中遇到了几个崩溃问题，挺有意思的，值得总结。今天要总结的问题比较低级，而且编译的时候会报警告，但还是挺有教育意义的。一起看看吧。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>以下是我精简整理后的模拟代码，大家可以先锻炼一下眼力，看看是否可以一眼看出问题所在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CResult</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CResult(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; data_) </span><br><span class="line">        : data(data_)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::wstring data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DoModify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// a lot logic code, return error code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">wstring <span class="title">GetErrorStr</span><span class="params">(<span class="keyword">int</span> error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (error)</span><br><span class="line">    <span class="keyword">switch</span> (error)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"Ok"</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"Invalid Param"</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"Operation Failed"</span>;</span><br><span class="line">    <span class="comment">// a lot more other cases</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"N/A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> modifyResult = DoModify();</span><br><span class="line">    <span class="function">CResult <span class="title">result</span><span class="params">(GetErrorStr(modifyResult))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>优化完代码后，运行突然崩溃了，简单查看后，是非常典型的空指针异常。</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/nullptr-exception-callstacks.png" alt="nullptr-exception-callstacks"></p><p>心想这不是小菜一碟吗？空指针异常？老朋友了！但是简单翻看调用栈，好像不是普通的空指针异常，在构造字符串对象的时候抛出了异常（上图红色高亮部分调用栈）。难道字符串出问题了？当时脑子里就一句话：字符串能出什么问题？？？</p><p>但是通过调试查看，好像还真是字符串出问题了，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/string-error.png" alt="string-error"></p><p>既然是字符串出问题了，那就看下字符串的来源，来自函数 <code>std::wstring GetErrorStr(int error)</code> 的返回值。查看这个函数的实现。真是不看不知道，一看吓一跳！怎么有两行一样的 <code>switch(error)</code> ？这代码肯定是不对的，删掉一行，再次运行，果然没问题了。</p><p>为什么有重复的 <code>swtich</code> 就会崩溃呢？源码猜不出来，那就看看反汇编代码吧。</p><h2 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h2><p>反汇编代码如下，红色高亮部分是第一个 <code>switch</code> 对应的代码，什么有意义的事情都没做，直接跳转到函数结尾<code>00007FF7800F3A34</code> 了。</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/disassembly-code-of-geterrorstr.png" alt="disassembly-code-of-geterrorstr"></p><p>从图中反汇编代码可知，<code>GetErrorStr()</code> 没对字符串对象做任何初始化操作。那么调用端呢？是否初始化了字符串对象呢？我们接着看一下调用端的反汇编代码，从下图中可知，调用函数也没有初始化字符串对象。</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/disassembly-code-of-main.png" alt="disassembly-code-of-geterrorstr"></p><p>综上，该字符串对象没有被初始化，其内容完全是随机的。</p><p>至此，此次崩溃问题已经很清楚了。但是，这种低级错误，按理说应该有警告才对啊？！</p><h2 id="编译警告"><a href="#编译警告" class="headerlink" title="编译警告"></a>编译警告</h2><p>再次编译，果然有警告，当时我应该忽略了，看来一定要注意编译警告！</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/compile-warning.png" alt="compile-warning"></p><h2 id="汇编小知识"><a href="#汇编小知识" class="headerlink" title="汇编小知识"></a>汇编小知识</h2><p>简单解释以上汇编代码，对于刚接触汇编的小伙伴会有帮助。先了解一些基本知识：</p><ol><li><code>x64</code> 下的默认调用约定是 <code>stdcall</code>，前四个参数（非浮点型）通过 <code>rcx rdx r8 r9</code> 传递</li><li>对于 <code>std::wstring GetErrorStr(int error)</code> 这种返回复杂类型（非 <code>POD</code> 类型）的函数，生成的汇编代码相当于 <code>std::wstring* GetErrorStr(std::wstring*, int error)</code> 。<strong>第一个参数</strong> 指向了返回值的地址</li><li>调用结束后，返回值会保存在 <code>rax</code> 中</li></ol><p>所以，上图中第二句汇编代码 <code>00007FF7800F3924  mov qword ptr [rsp+8],rcx</code> 把字符串对象地址保存到了 <code>rsp+0x8</code> 的位置。接下来的几句汇编指令把 <code>rsp</code> 向下移动了 <code>0x8 + 0x8 + 0x108 = 0x118</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00007FF7800F3924  mov         qword ptr [rsp+8],rcx  </span><br><span class="line">00007FF7800F3929  push        rbp  </span><br><span class="line">00007FF7800F392A  push        rdi  </span><br><span class="line">00007FF7800F392B  sub         rsp,108h</span><br></pre></td></tr></table></figure><p>接下来的一条汇编指令 <code>00007FF7800F3932  lea rbp,[rsp+20h]</code> 使 <code>rbp</code> 指向了 <code>rsp+0x20</code> 的位置，那么 <code>rbp+0x100</code> 就指向了 第一个参数的地址。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>相关工程代码已经上传到 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/debug-unexpected-crash-and-never-ignore-compiling-warnings\TestSwitchCaseCrash" target="_blank" rel="noopener">github</a> 了，感兴趣的小伙伴儿可以下载验证。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>务必要关注编译器的警告</li><li>掌握汇编知识非常重要，尤其对调试更是如此</li><li><code>64</code> 位程序默认的调用约定是 <code>stdcall</code>，前四个参数（非浮点型）通过 <code>rcx rdx r8 r9</code> 传递</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录并剖析了一次由看似低级的代码错误引发的、令人意想不到的程序崩溃。问题的根源在于 &lt;code&gt;GetErrorStr&lt;/code&gt; 函数中一个容易被忽略的重复 &lt;code&gt;switch&lt;/code&gt;语句。这个错误导致函数返回的 &lt;code&gt;std::wstring&lt;/code&gt; 对象未被正确初始化，最终在构造 &lt;code&gt;CResult&lt;/code&gt; 对象时引发了空指针访问异常 。&lt;/p&gt;
&lt;p&gt;本文通过深入分析崩溃调用栈和反汇编代码，清晰地总结了从函数异常返回（未初始化字符串）到调用端使用无效数据（触发崩溃）的完整过程。希望这个案例能提醒各位，&lt;strong&gt;编译警告是发现潜在风险的第一道防线&lt;/strong&gt;，而&lt;strong&gt;基础的汇编知识则是深入调试的利器&lt;/strong&gt;。文末有可复现问题的代码，欢迎动手实践。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="warning" scheme="https://bianchengnan.github.io/tags/warning/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 5 —— 实战修复虚函数导致的编译错误</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/</id>
    <published>2024-12-01T06:37:07.000Z</published>
    <updated>2025-12-23T13:51:14.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，同事遇到了一个奇怪的编译问题，大概情况如下：</p><p><code>classA</code> 是模块 <code>A</code> 中的一个类， <code>classA</code> 没有定义构造函数，其它函数都是导出的。<code>B</code> 模块依赖了 <code>A</code> 模块，并且会调用 <code>classA</code> 的接口。当在 <code>B</code> 模块中添加了实例化 <code>classA</code> 对象的代码的时候，报链接错误，提示找不到 <code>classA</code> 类的某个虚函数。</p><p>我帮忙看过之后发现又是虚函数相关的编译问题（正好最近在总结虚函数相关的问题），这是送上门的素材啊！</p><a id="more"></a><blockquote><p><strong>说明：</strong> 项目代码不方便对外发布，本文所有的代码是我基于实际项目模拟的</p></blockquote><h2 id="示例程序简介"><a href="#示例程序简介" class="headerlink" title="示例程序简介"></a>示例程序简介</h2><p>示例程序由两个工程组成：<strong>主模块</strong>和<strong>接口模块</strong>。</p><ul><li><p>接口模块</p><p>接口模块只提供了头文件 <code>interface.h</code> 和对应的 <code>interface.lib</code> 文件及接口实现文件 <code>interface.dll</code>。头文件内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_INTERFACE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_INTERFACE InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>主模块</p><p>主模块会隐式依赖 <code>interface.lib</code>，并通过 <code>GetInterface()</code> 接口获取 <code>Interface1</code> 指针，然后调用其接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> if2 = Interface1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当在 <code>main()</code> 函数中通过 <code>auto if2 = Interface1();</code> 创建 <code>Interface1</code> 类型的对象时，编译器会报链接错误，提示无法解析的外部符号，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/LNK2001.png" alt="LNK2001"></p><h2 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h2><p>通过之前总结的几篇文章</p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/">《基础知识 | 有趣的动态转换》</a></p><p><a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a></p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/">《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/">《基础知识 | 函数基础 4 —— 又崩溃了，原来是虚函数声明顺序不一致捣的鬼 》</a></p><p>我对虚函数编译相关的问题有了比较全面的认识。</p><p>头文件中没声明 <code>Interface1</code> 的构造函数，并且 <code>Interface1</code> 包含虚函数，那么编译器会自动生成构造函数代码，与我们手动在头文件中<strong>定义</strong>一个空造函数是一样的。</p><p>在这种情况下，如果想在外部模块实例化 <code>Interface1</code> 的对象，那么 <code>Interface1</code> 所有的虚函数都需要是导出的或者需要在头文件中定义。</p><p>快速扫了一遍头文件，所有虚函数确实都是导出的。这就奇怪了，难道 <code>interface.lib</code> 文件又出问题了？</p><h2 id="查看-lib-文件"><a href="#查看-lib-文件" class="headerlink" title="查看 lib 文件"></a>查看 lib 文件</h2><p>使用 <code>vs</code> 自带的 <code>dumpbin</code> 查看 <code>interface.lib</code> 的导出符号，在命令行中分别输入以下两行命令，即可把 <code>Interface.lib</code> 中的导出符号信息导出到 <code>interface.txt</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> PATH=%PATH%;<span class="string">"C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\amd64\"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dumpbin /EXPORTS Interface.lib &gt; interface.txt</span></span><br></pre></td></tr></table></figure><p>在 <code>interface.txt</code> 中搜索 <code>Test4</code>，结果什么也没所搜到，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/cannot-search-Test4-from-interface-lib.png" alt="cannot-search-Test4-from-interface-lib"></p><p>原来又是头文件与 <code>lib</code> 文件不匹配导致的问题，头文件中包含 <code>Test4</code>，但是对应的 <code>lib</code> 文件中却没有。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>示例工程已经上传到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part5-real-sovle-a-real-virtual-function-compile-error" target="_blank" rel="noopener">这里</a>，感兴趣的小伙伴儿可以自行下载验证。</p><blockquote><p><strong>说明：</strong> 我已经上传了对应的 <code>Interface.lib</code> 及 <code>Interface.dll</code>，如果想重新编译 <code>Interface.vcxproj</code>，需要先注释掉 <code>Interface.h</code> 中包含 <code>Test4</code> 的那一行。编译成功后，如果想像我一样重现链接错误，那么需要在 <code>Interface.h</code> 中把删掉的 <code>Test4</code> 哪一行添加回来并且<strong>只重新编译</strong> <code>InterfaceExe.vcxproj</code>。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果类构造函数不是导出的，如果想在外部模块实例化类对象，那么类中所有虚函数都需要是导出的</li><li><code>dumpbin</code> 是查看 <code>.lib</code> 或 <code>.dll</code> 文件中导出符号的神兵利器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一阵子，同事遇到了一个奇怪的编译问题，大概情况如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;classA&lt;/code&gt; 是模块 &lt;code&gt;A&lt;/code&gt; 中的一个类， &lt;code&gt;classA&lt;/code&gt; 没有定义构造函数，其它函数都是导出的。&lt;code&gt;B&lt;/code&gt; 模块依赖了 &lt;code&gt;A&lt;/code&gt; 模块，并且会调用 &lt;code&gt;classA&lt;/code&gt; 的接口。当在 &lt;code&gt;B&lt;/code&gt; 模块中添加了实例化 &lt;code&gt;classA&lt;/code&gt; 对象的代码的时候，报链接错误，提示找不到 &lt;code&gt;classA&lt;/code&gt; 类的某个虚函数。&lt;/p&gt;
&lt;p&gt;我帮忙看过之后发现又是虚函数相关的编译问题（正好最近在总结虚函数相关的问题），这是送上门的素材啊！&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="part5" scheme="https://bianchengnan.github.io/tags/part5/"/>
    
      <category term="编译错误" scheme="https://bianchengnan.github.io/tags/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 4 —— 又崩溃了，原来是虚函数声明顺序不一致捣的鬼</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/</id>
    <published>2024-11-09T06:37:07.000Z</published>
    <updated>2025-12-23T13:51:14.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，同事遇到了一个崩溃问题，解决后发现这个崩溃是由于在公共类中加了一个虚函数接口，但是并没有编译相关模块导致的。这种崩溃问题是老朋友了。在此之前，我已经写了几篇关于虚函数的总结，感兴趣的小伙伴儿可以查看这几篇文章：</p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/">《基础知识 | 有趣的动态转换》</a></p><p><a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a></p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/">《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》</a></p><p>本文主要关注以下两个问题，如果你已经有了很明确的答案，可以跳过本文：</p><ul><li>如果在编译 <code>A</code> 模块的时候，<code>Test</code> 类的虚函数声明的顺序是 <code>Test1, Test2, Test3</code>，但是在 <code>B</code> 模块编译的时候，<code>Test</code> 类头文件中虚函数顺序变成了 <code>Test2, Test1, Test3</code>。在 <code>B</code> 模块中调用 <code>test-&gt;Test1()</code>，调用的是哪个函数呢？</li></ul><ul><li>假设 <code>A</code> 模块代码不变，但是在编译 <code>B</code> 模块的时候，<code>Test</code> 类的头文件中又多了一个虚函数 <code>Test4()</code>，在 <code>B</code> 模块中调用 <code>test-&gt;Test4()</code>，代码可以正常编译吗？会有链接问题吗？如果可以正常编译链接，运行的时候会有问题吗？</li></ul><a id="more"></a><p>在开始验证前先回顾一下之前的结论</p><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><ul><li><p><strong>虚表及虚表中的函数地址会与构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中</p></li><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>调用虚函数的时候会先获取虚表指针，然后根据虚函数的索引从虚表中得到最终的函数地址进行调用</p></li></ul><p>更多结论请参考 <a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">上一篇文章</a>。</p><p>回顾完结论后，让我们用测试程序探寻以上两个问题的答案，先来看看示例程序的代码</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序由两个工程组成：<strong>主模块</strong>和<strong>接口模块</strong>。</p><ul><li><p>接口模块</p><p>对应的工程是 <code>Interface.vcxproj</code>。代码很简单，实现了接口，并暴露了一个导出接口供主模块使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_INTERFACE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_INTERFACE InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT__INTERFACE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Interface1::Test1(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test2(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test3(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>主模块</p><p>对应的工程是 <code>InterfaceExe.vcxproj</code>。主模块通过<strong>导出接口</strong>和<strong>直接实例化</strong>的方式获取 <code>Interface1</code> 的对象指针，然后调用 <code>Test2()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    Interface1* if2 = <span class="keyword">new</span> Interface1();</span><br><span class="line">    if1-&gt;Test2(<span class="number">0</span>);</span><br><span class="line">    if2-&gt;Test2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以上示例程序编译运行一切正常。接下来<strong>保持接口模块不变</strong>，修改代码后<strong>只重新编译主模块</strong>。</p><h2 id="验证1"><a href="#验证1" class="headerlink" title="验证1"></a>验证1</h2><p>交换 <code>Interface.h</code> 中的 <code>Test2()</code> 和 <code>Test3()</code> 的顺序，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>只重新编译主模块</strong>，查看运行结果。结果如下：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/swap-test2-test3.png" alt="swap-test2-test3"></p><p>虽然代码里调用的都是 <code>Test2()</code>，但是从输出结果可知：<code>if1</code> 调用的是 <code>Test3()</code>，<code>if2</code> 调用的是 <code>Test2()</code>。</p><p>在 <code>windbg</code> 中分别查看这两个调用对应的反汇编，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-disassembly-of-virtual-function-call.png" alt="view-disassembly-of-virtual-function-call"></p><p>可以发现，调用的都是虚表中索引为 <code>3</code> （<code>0x18 / 0x8 = 3</code>）的函数。分别查看一下虚表</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-vtable-in-windbg.png" alt="view-vtable-in-windbg"></p><p>可以发现，</p><p><code>if1</code> 对应的虚表存储在 <code>Interface</code> 模块，第 <code>3</code> 项是 <code>Interface!Interface1::Test3</code>；</p><p><code>if2</code> 对应的虚表存储在 <code>InterfaceExe</code> 模块，第 <code>3</code> 项是 <code>InterfaceExe!Interface1::Test2</code>。</p><p>在编译 <code>Interface</code> 模块时，由于 <code>GetInterface()</code> 内部会调用 <code>new Interface1</code>，因此会在 <code>Interface</code> 模块中生成虚表，此时 <code>Test3()</code> 是最后一项。</p><p>在编译 <code>InterfaceExe</code> 模块时，由于会直接调用 <code>new Interface1()</code>，因此会在 <code>InterfaceExe</code> 模块中生成虚表，此时 <code>Test2()</code> 是最后一项。</p><p>在 <code>windbg</code> 中查看  <code>InterfaceExe!Interface1::Test2</code> 对应的反汇编，可以发现其最终会调用 <code>Interface!Interface1::Test2()</code>。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-disassembly-of-interfaceexe-interface1-test2.png" alt="view-disassembly-of-interfaceexe-interface1-test2"></p><blockquote><p><strong>思考：</strong> 如果 <code>Test2</code> 和 <code>Test3</code> 的参数个数或者参数类型不一致，是不是会有更严重的问题？</p><p>根据上面的分析可知，从 <code>if1</code> 调用的话会有问题，从 <code>if2</code> 调用的话没问题。</p></blockquote><h2 id="验证-2"><a href="#验证-2" class="headerlink" title="验证 2"></a>验证 2</h2><p>在  <code>Interface.h</code>  中增加一个名为 <code>Test4</code> 的接口，并在 <code>main()</code> 函数中调用之。修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，<strong>只重新编译主模块</strong>。可以<strong>正常编译链接</strong>，但是执行的时候遇到了一个异常。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-4th-function-in-vtable.png" alt="view-4th-function-in-vtable"></p><p>从上图可知，在 <code>main()</code> 函数调用 <code>Test4()</code> 时，<code>rip</code> 指向了地址 <code>00000003 19930522</code>。因为在重新编译主模块时，<code>Test4()</code> 是虚表中的第 <code>4</code> 项（从 <code>0</code> 开始），而虚表中第 <code>4</code> 项的值是 <code>00000003 19930522</code>。</p><p>因为在编译 <code>Interface.dll</code> 的时候，一共只有 <code>4</code> 项，最大索引是 <code>3</code>。而主模块中的调用代码却尝试访问虚表中的第 <code>4</code> 项，而第 4 项的内容是随机的，所以在执行的时候发生了异常。</p><p>根据以上验证结果可知，<strong>编译器会根据头文件中的顺序生成虚函数调用代码</strong>，如果与虚函数所属模块生成时的顺序不一致，很可能调用的是不同的函数，行为是未定义的。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>示例工程已经上传到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part4-what-will-happen-if-virtual-function-reordered" target="_blank" rel="noopener">这里</a>了，感兴趣的小伙伴儿可以自行下载，根据 <code>验证 1</code> 和 <code>验证 2</code> 中的修改方式手动修改代码，进行验证。</p><blockquote><p><strong>务必注意：</strong> 修改完代码后不要重新编译 <code>Interface</code> 工程，只重新编译 <code>InterfaceExe</code> 工程！</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>编译器会根据头文件中的顺序生成虚函数调用代码</strong>，如果与虚函数所属模块生成时的顺序不一致，很可能调用的是不同的函数，行为是未定义的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一阵子，同事遇到了一个崩溃问题，解决后发现这个崩溃是由于在公共类中加了一个虚函数接口，但是并没有编译相关模块导致的。这种崩溃问题是老朋友了。在此之前，我已经写了几篇关于虚函数的总结，感兴趣的小伙伴儿可以查看这几篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/&quot;&gt;《基础知识 | 有趣的动态转换》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/&quot;&gt;《基础知识 | C++ 虚函数简介》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/&quot;&gt;《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/&quot;&gt;《基础知识 | 函数基础 1 —— 基本概念 &amp;amp; 如何调用外部模块的函数》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/&quot;&gt;《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/&quot;&gt;《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要关注以下两个问题，如果你已经有了很明确的答案，可以跳过本文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在编译 &lt;code&gt;A&lt;/code&gt; 模块的时候，&lt;code&gt;Test&lt;/code&gt; 类的虚函数声明的顺序是 &lt;code&gt;Test1, Test2, Test3&lt;/code&gt;，但是在 &lt;code&gt;B&lt;/code&gt; 模块编译的时候，&lt;code&gt;Test&lt;/code&gt; 类头文件中虚函数顺序变成了 &lt;code&gt;Test2, Test1, Test3&lt;/code&gt;。在 &lt;code&gt;B&lt;/code&gt; 模块中调用 &lt;code&gt;test-&amp;gt;Test1()&lt;/code&gt;，调用的是哪个函数呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;假设 &lt;code&gt;A&lt;/code&gt; 模块代码不变，但是在编译 &lt;code&gt;B&lt;/code&gt; 模块的时候，&lt;code&gt;Test&lt;/code&gt; 类的头文件中又多了一个虚函数 &lt;code&gt;Test4()&lt;/code&gt;，在 &lt;code&gt;B&lt;/code&gt; 模块中调用 &lt;code&gt;test-&amp;gt;Test4()&lt;/code&gt;，代码可以正常编译吗？会有链接问题吗？如果可以正常编译链接，运行的时候会有问题吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="part4" scheme="https://bianchengnan.github.io/tags/part4/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part3-call-unexported-virtual-function-of-another-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part3-call-unexported-virtual-function-of-another-module/</id>
    <published>2024-09-14T06:37:07.000Z</published>
    <updated>2025-12-23T13:51:14.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在上篇文章 <a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a>中，我们明白了一个事实 —— 可以在不依赖外部模块的情况下通过类对象指针调用其<strong>虚函数</strong>。</p><p>但是遗留了几个问题，如下：</p><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li></ul><ul><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p></li><li><p>问题 4：如果在 <code>Interface1</code>  中声明了未导出的构造函数，上述代码能编译通过吗？</p></li><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p></li><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p></li></ul><p>本文力求把这几个问题弄清楚。如果您对以上问题已经有了答案，可以跳过本文。</p><a id="more"></a><p>我们先简单回顾一下<a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">上篇文章</a>中的代码（可以到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module" target="_blank" rel="noopener">这里</a>下载或查看）：</p><ul><li><p><code>Interface</code> 模块定义了 <code>Interface1</code> 类，并且其接口函数都是导出的。</p></li><li><p><code>GetInterface</code> 模块导出了一个接口，该接口内部会 <code>new Interface1()</code> 并返回。</p></li><li><p><code>InterfaceExe</code> 模块通过 <code>GetInterface</code> 模块的导出接口获得 <code>Interface1</code> 的指针，然后调用其虚函数。</p></li></ul><p>在解答以上几个问题前，我们先查看以下几种情况编译器生成的汇编代码。</p><blockquote><p><strong>说明：</strong> </p><ol><li>本文查看的是 <code>release</code> 版本关闭优化后的汇编代码，比 <code>debug</code> 版本更简洁明了</li><li>下文中提到的 <strong>定义</strong> 指的是函数的声明和实现在一起</li></ol></blockquote><h2 id="情况-1"><a href="#情况-1" class="headerlink" title="情况 1"></a>情况 1</h2><p>注释掉上篇文章代码中对 <code>if1-&gt;Test4(0);</code> 的调用。编译并查看反汇编代码，重点关注构造函数及虚表的存储位置。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case1-getinterface-constructor-vftable.png" alt="case1-getinterface-constructor-vftable"></p><p>可以发现 <code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中。虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><h2 id="情况-2"><a href="#情况-2" class="headerlink" title="情况 2"></a>情况 2</h2><p>在 <code>情况 1</code> 代码的基础上进行如下修改：</p><ul><li><p>在头文件<strong>定义</strong>构造函数（注意：头文件中既包含声明又包含实现）</p></li><li><p>在头文件<strong>定义</strong>一个名为 <code>Test5()</code> 的虚函数</p></li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Interface1() &#123;&#125;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="查看构造函数及虚表"><a href="#查看构造函数及虚表" class="headerlink" title="查看构造函数及虚表"></a>查看构造函数及虚表</h3><p>编译运行，跟踪反汇编代码。可以发现，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中。虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-getinterface-constructor-vftable.png" alt="case2-getinterface-constructor-vftable"></p><h3 id="查看虚函数汇编代码"><a href="#查看虚函数汇编代码" class="headerlink" title="查看虚函数汇编代码"></a>查看虚函数汇编代码</h3><p>挑几个典型的虚函数，查看其反汇编代码。</p><ul><li>先来看看 <code>InterfaceBase::scalar deleting destructor</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interfacebase-destructor.png" alt="case2-interfacebase-destructor"></li></ul><ul><li>再来看看 <code>Interface1::scalar deleting destructor</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-destructor.png" alt="case2-interface1-destructor"></li></ul><ul><li><p>再来看看 <code>Interface1::Test1()</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-test1.png" alt="case2-interface1-test1"></p><p>可以发现，<code>GetInterface</code> 模块中的 <code>Interface1::Test1()</code> 会调用 <code>Interface</code> 模块导出的  <code>Interface1::Test1()</code>。</p></li></ul><ul><li>再来看看 <code>Interface1::Test5()</code>的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-test5.png" alt="case2-interface1-test5"></li></ul><p>以上几个函数有一个共同特点：所有函数的实现代码都在 <code>GetInterface</code> 模块中。我是怎么知道的？根据输出结果判断的，输出结果中，<code>!</code> 前面的部分是模块名。比如，<code>GetInterface!Interface1::Test5</code>，对应的模块是 <code>GetInterface</code>。</p><blockquote><p><strong>小贴士：</strong> 还可以根据 <code>lma address</code> 来查找某个地址所属的模块</p></blockquote><h3 id="两种编译报错的情况"><a href="#两种编译报错的情况" class="headerlink" title="两种编译报错的情况"></a>两种编译报错的情况</h3><ul><li>去掉 <code>Test2()</code> 的导出标识，再编译，会报链接错误，如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-test2-not-export-link-error.png" alt="case2-test2-not-export-link-error"></li></ul><ul><li>如果把 <code>Interface1</code> 的构造函数的定义移动到 <code>Interface.cpp</code> 中，头文件中只保留声明，也会报链接错误，如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-constructor-implement-in-cpp-link-error.png" alt="case2-constructor-implement-in-cpp-link-error"></li></ul><p>  其实，这两个错误有共性：</p><ol><li><p>都没有导出标识</p></li><li><p>实现和声明分离</p><p>实现在 <code>Interface.cpp</code> 中，最终会编译到 <code>Interface</code> 模块，而不是 <code>GetInterface</code> 模块</p></li><li><p>都会被 <code>GetInterface</code> 模块用到</p><ul><li>在 <code>new Interface()</code> 时会调用构造函数</li><li>在构造函数调用时会初始化虚表指针，指向虚表。虚表需要记录 <code>Test2()</code> 的地址，而 <code>Test2()</code> 在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址</li></ul></li></ol><blockquote><p><strong>说明：</strong> <code>情况 1</code> 的构造函数的代码是编译器自动生成的，与 <code>情况 2</code> 的构造函数代码是一样的。</p></blockquote><h2 id="情况-3"><a href="#情况-3" class="headerlink" title="情况 3"></a>情况 3</h2><p>在 <code>情况 2</code> 代码的基础上进行如下修改：</p><ul><li>为构造函数增加导出标识，并且把实现移动到 <code>Interface.cpp</code> 中</li><li>去掉其它函数的导出标识。只保留 <code>Test3()</code> 的导出标识</li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="title">Interface1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line">Interface1::Interface1()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看构造函数及虚表-1"><a href="#查看构造函数及虚表-1" class="headerlink" title="查看构造函数及虚表"></a>查看构造函数及虚表</h3><p>编译运行，跟踪反汇编代码。可以发现，<code>GetInterface!GetInterface()</code> 调用的构造函数是从 <code>Interface</code> 模块导入的。</p><p><code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case3-getinterface-constructor-vftable.png" alt="case3-getinterface-constructor-vftable"></p><blockquote><p><strong>注意：</strong> </p><ul><li><p>虚表中的所有函数的地址都属于 <code>Interface</code> 模块，与 <code>情况 2</code> 不一样。</p></li><li><p>虽然 <code>Test3()</code> 是导出的，但是虚表中保存的 <code>Test3</code> 的地址是 <code>Interface</code> 模块的。</p></li><li><p>注意 <code>Test5()</code>。在 <code>情况 2</code> 中，虚表中保存的 <code>Test5()</code> 的地址是在 <code>GetInterface</code> 模块中的，而且不会像其它函数一样调用 <code>Interface</code> 模块中的函数。在  <code>情况 3</code> 中，虚表中保存的 <code>Test5()</code> 的地址在 <code>Interface</code> 模块中。</p></li></ul><p>可以猜测，因为构造函数被导出了，没有必要在外部模块创建虚表了。</p></blockquote><h2 id="情况-4"><a href="#情况-4" class="headerlink" title="情况 4"></a>情况 4</h2><p>在 <code>情况 3</code> 代码的基础上进行如下修改：</p><ul><li>去掉所有函数的导出标识</li><li>增加一个名为 <code>ExportInterface</code> 的导出接口，返回 <code>Interface1</code> 对象指针</li><li>修改 <code>GetInterface.cpp</code> 中的 <code>GetInterface</code> 接口，直接调用 <code>ExportInterface()</code></li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.h </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Interface1();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExportInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，跟踪反汇编代码。可以发现，与 <code>情况 3</code> 基本一致。<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case4-getinterface-constructor-vftable.png" alt="case4-getinterface-constructor-vftable"></p><h2 id="情况-5"><a href="#情况-5" class="headerlink" title="情况 5"></a>情况 5</h2><p>在 <code>情况 2</code> 代码的基础上进行如下修改：</p><ul><li>在 <code>Interface1.h</code> 中声明导出接口 <code>ExportInterface</code></li><li>在 <code>Interface1.cpp</code> 中实现 <code>ExportInterface</code></li><li>在 <code>GetInterface.h</code> 中增加导出接口 <code>GetInterface1</code></li><li>在 <code>GetInterface.cpp</code> 中实现 <code>GetInterface1</code></li><li>在 <code>InterfaceExe.cpp</code> 调用这两个接口得到接口指针</li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.h </span></span><br><span class="line"><span class="function">DLL_EXPORT InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.h </span></span><br><span class="line"><span class="function">DLL_EXPORT_GET InterfaceBase* <span class="title">GetInterface1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExportInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterfaceBase* base = GetInterface();</span><br><span class="line">    InterfaceBase* base1 = GetInterface1();</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(base);</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if1-&gt;Test4(0);</span></span><br><span class="line"></span><br><span class="line">    FreeInterface(if1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看，<code>GetInterface()</code> 相关的反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case5-getinterface-constructor-vftable.png" alt="case5-getinterface-constructor-vftable"></p><p>从上图可以发现，与 <code>情况 2</code> 是一样，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中，虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><p>再来看看 <code>GetInterface1()</code> 相关的反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case5-getinterface1-constructor-vftable.png" alt="case5-getinterface1-constructor-vftable"></p><p>从上图可以发现，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p>简单整理如下：</p><ul><li><p><code>GetInterface!GetInterface()</code> 内部会调用 <code>new Interface1</code>，进而导致 <code>Interface1</code> 的构造函数在 <code>GetInterface</code> 模块中被调用。对应的虚表及虚表中的函数地址都存储在 <code>GetInterface</code> 模块中。</p></li><li><p><code>GetInterface!GetInterface1()</code> 内部会调用 <code>Interface!ExportInterface()</code>，而 <code>Interface!ExportInterface()</code> 内部会调用 <code>new Interface1</code>， 最终 <code>Interface1</code> 的构造函数在 <code>Interface</code> 模块中被调用。对应的虚表及虚表中的函数地址都存储在 <code>Interface</code> 模块中。</p></li></ul><p>因此，可以得到这样的结论： <strong>虚表及虚表中的函数地址会跟构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中。</p><p>有了以上基础，就可以很顺利的回答之前的问题了，我们依次来看看每个问题。</p><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p><p><strong>答：</strong> 参考 <code>情况 1</code>，<code>Interface1</code> 与 <code>InterfaceBase</code> 的构造函数、虚表以及虚表中的函数都保存在  <code>GetInterface</code> 模块中。</p><blockquote><p><strong>小贴士：</strong> 可以推测，如果有另外一个类似 <code>GetInterface</code> 的模块，相应的内容在那个模块中也会生成一份。</p></blockquote></li></ul><ul><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p><p><strong>答：</strong> 参考 <code>情况 1</code>，虚表与构造函数一样保存在 <code>GetInterface</code> 模块中。</p></li></ul><ul><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p><p><strong>答：</strong> 不能。参考 <code>情况 2</code> 中提到的两种编译报错的情况。</p><p>在没有声明构造函数的情况下，编译器生成的构造函数代码和虚表都会保存在 <code>GetInterface</code> 模块中。</p><p>在构造函数调用时会初始化虚表指针，指向虚表。虚表需要记录每个虚函数的地址，而这些虚函数在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址，故报链接错误。</p></li></ul><ul><li><p>问题 4：如果在 <code>Interface1</code>  中声明了<strong>未导出</strong>的构造函数，上述代码能编译通过吗？</p><p><strong>答：</strong> 需要根据构造函数定义的位置判断</p><ul><li><p>如果构造函数的定义也在头文件中，则可以正常编译。</p><p>因为编译后构造函数的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果构造函数的定义在源文件中而且没导出，会报链接错误。</p><p>因为在 <code>GetInterface</code> 模块中调用 <code>new Interface</code> 的时候，会调用 <code>Interface</code> 的构造函数，但是在 <code>GetInterface</code> 模块中找不到其实现代码。</p></li></ul></li></ul><ul><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p><p><strong>答：</strong> 与 <code>问题 4</code> 一样，需要根据 <code>InterfaceBase::Test1()</code> 定义的位置判断</p><ul><li><p>如果 <code>InterfaceBase::Test1()</code> 的定义也在头文件中，则可以正常编译。</p><p>因为编译后 <code>InterfaceBase::Test1()</code> 的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果 <code>InterfaceBase::Test1()</code> 的定义在源文件中而且没导出，会报链接错误。</p><p><code>InterfaceBase::Test1()</code> 的实现代码保存在 <code>Interface</code> 模块中。<code>InterfaceBase</code> 的虚表需要记录 <code>InterfaceBase::Test1()</code> 的地址，而 <code>InterfaceBase::Test1()</code> 在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址，会报链接错误。</p></li></ul></li></ul><ul><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p><p>答： 与 <code>问题 4</code>、<code>问题 5</code> 一样，需要根据析构函数定义的位置判断</p><ul><li><p>如果析构函数的定义也在头文件中，则可以正常编译。</p><p>因为编译后析构函数的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果析构函数的定义在源文件中而且没导出，会报链接错误。</p><p>析构函数最终会保存在 <code>Interface</code> 模块中。当调用 <code>GetInterface</code> 模块中的  <code>FreeInterface()</code> 时，该函数内部会调用 <code>delete</code>，而 <code>delete</code> 内部会调用析构函数，但是在 <code>GetInterface</code> 模块中没有实现，会报链接错误。</p></li></ul><blockquote><p><strong>友情提示：</strong> </p><ol><li>如果基类的析构函数是虚函数，子类的析构函数即使不加 <code>virtual</code> 关键字也是虚的！</li><li>如果一个类被设计为基类并且其析构函数是非虚的，这是一个 <code>bad design</code>， 《effective c++》条款 7 中讲过，感兴趣的朋友可以参考</li></ol></blockquote></li></ul><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>我已经将以上几种情况对应的工程源码上传到个人仓库中了，可以到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part3-call-unexported-virtual-function-of-another-module" target="_blank" rel="noopener">这里</a>下载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>虚表及虚表中的函数地址会与构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中</li></ol><ol start="2"><li>如果 <code>classA</code> 所有函数都定义在头文件中，那么 <code>B</code> 模块不需要依赖 <code>A</code> 模块，因为 <code>classA</code> 的所有实现代码都在 <code>B</code> 中了</li></ol><ol start="3"><li><p>在构造函数调用时会初始化虚表指针，指向虚表。必须能解析每个虚函数的地址，否则会报链接错误。</p><p>务必注意报错的时机 —— <strong>在编译构造函数的时候报错，而不是编译虚函数调用代码的时候报错！</strong></p></li></ol><ol start="4"><li><p>如果在 <code>B</code> 模块中已经拿到了 <code>A</code> 模块中 <code>classA</code> 的对象指针，可以在 <code>B</code> 模块调用其虚函数，不需要关心虚函数是否导出。</p><p>既然已经拿到了对象指针，说明构造函数已经成功执行了，虚表已经保存好了虚函数的地址。</p></li></ol><ol start="5"><li><p>如果想在 <code>B</code> 模块中获取 <code>A</code> 模块中 <code>classA</code> 的对象，有两种方法：</p><ol><li><p><code>A</code> 模块导出一个返回 <code>classA</code> 对象的指针的接口，<code>B</code> 模块通过 <code>A</code> 模块的导出接口获取</p></li><li><p>直接在 <code>B</code> 模块中实例化 <code>classA</code> 对象。通过 <code>auto pA = new classA();</code> 或者 <code>classA a;</code></p></li></ol></li></ol><ol start="6"><li><p>如果想在 <code>B</code> 模块中<strong>直接</strong>实例化 <code>A</code> 模块中 <code>classA</code> 的对象，需要能在 <code>B</code> 模块中访问 <code>classA</code> 的构造函数，有两种方法：</p><ol><li><p><code>classA</code> 的构造函数是导出的 <strong>并且</strong> <code>B</code> 模块依赖 <code>A</code> 模块</p></li><li><p><code>classA</code> 的构造函数定义在头文件中（或者不声明构造函数，编译器会自动生成一个）</p></li></ol></li></ol><ol start="7"><li><p>如果 <code>A</code> 模块中 <code>classA</code> 的构造函数是未导出的，并且 <code>classA</code> 中有虚函数，要想在 <code>B</code> 模块中直接实例化 <code>classA</code>，需要满足：</p><ol><li><p>构造函数定义在头文件中</p></li><li><p>虚函数或者<strong>是导出的</strong>或者<strong>定义在头文件中</strong></p></li></ol></li></ol><ol start="8"><li>如果想在 <code>B</code> 模块中调用 <code>A</code> 模块中 <code>classA</code> 的成员函数（例如， <code>delete pA</code> 会调用 <code>classA</code> 的析构函数），那么 <code>classA</code> 的成员函数<ul><li>或者是虚的</li><li>或者是导出的</li><li>或者定义在头文件中</li></ul></li></ol><ol start="9"><li>如果链接错误是由找不到析构函数导致的，删除导致析构函数调用的代码，就不会报错了</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《effective c++》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在上篇文章 &lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/&quot;&gt;《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》&lt;/a&gt;中，我们明白了一个事实 —— 可以在不依赖外部模块的情况下通过类对象指针调用其&lt;strong&gt;虚函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是遗留了几个问题，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题 1：&lt;code&gt;Interface1&lt;/code&gt; 类中没有声明构造函数，编译器生成的构造函数保存在哪里？&lt;code&gt;GetInterface&lt;/code&gt; 模块还是 &lt;code&gt;Interface&lt;/code&gt; 模块？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 2：&lt;code&gt;Interface1&lt;/code&gt; 的虚表保存在哪里？&lt;code&gt;GetInterface&lt;/code&gt; 模块还是 &lt;code&gt;Interface&lt;/code&gt; 模块？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题 3：如果去掉 &lt;code&gt;Interface1&lt;/code&gt; 中虚函数的导出符号，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 4：如果在 &lt;code&gt;Interface1&lt;/code&gt;  中声明了未导出的构造函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 5：如果 &lt;code&gt;InterfaceBase::Test1()&lt;/code&gt; 不是纯虚函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 6：如果 &lt;code&gt;InterfaceBase&lt;/code&gt; 的析构函数不是虚函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文力求把这几个问题弄清楚。如果您对以上问题已经有了答案，可以跳过本文。&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="part3" scheme="https://bianchengnan.github.io/tags/part3/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/</id>
    <published>2024-07-27T06:37:07.000Z</published>
    <updated>2025-12-23T13:51:14.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一段日子，同事遇到了一个奇怪的现象 —— <code>B</code> 模块调用了 <code>A</code> 模块某个类的成员函数，没有依赖 <code>A</code> 模块，编译时没有报错。而 <code>C</code> 模块也调用了 <code>A</code> 模块中同一个类的成员函数，没有依赖 <code>A</code> 模块，编译时却报了链接错误。</p><p>简单语音沟通后觉得不太可能。用了 <code>A</code> 模块的函数，却不依赖 <code>A</code> 模块，有点儿不讲道理！</p><p>因为当时我没在电脑前，跟同事简单沟通了几个可以设置库依赖的位置，结果都没有发现对应的依赖项。</p><p>心里越发觉得不可思议，难道 <code>B</code> 模块是通过其它方式依赖 <code>A</code> 模块的？正常情况下，如果 <code>B</code> 模块依赖 <code>A</code> 模块，一定可以在 <code>B</code> 模块的导入表中看到 <code>A</code> 模块相关的记录。于是建议同事查看 <code>B</code> 模块的导入表，但是同事不太熟悉。因为项目比较急，遂建议同事在 <code>C</code> 模块中添加对 <code>A</code> 模块的依赖，先解决项目问题，后面有机会再调查具体原因。</p><p>直到最近才有时间调查这个问题，结果发现这个问题非常有意思 —— <code>B</code> 模块确实没有依赖 <code>A</code> 模块（<code>B</code> 模块的导入表中确实没发现 <code>A</code> 模块的相关项），但是 <code>B</code> 模块确实调用了 <code>A</code> 模块中的函数，而且不是通过 <code>LoadLibrary() + GetProcAddress()</code> 的方式调用的。</p><p>本文主要关注以下问题，如果你已经有了答案，可以跳过本文。</p><ul><li><code>B</code> 模块在什么情况下可以调用 <code>A</code> 模块中的函数，但是却不依赖 <code>A</code> 模块？</li></ul><a id="more"></a><blockquote><p><strong>约定：</strong></p><ol><li><p>本文不考虑通过 <code>GetProcAddress()</code> 获取函数指针后再调用的情况</p></li><li><p>虚函数表在本文中简称<strong>虚表</strong>，指向虚表的指针简称<strong>虚表指针</strong></p></li></ol></blockquote><p>为了更好的研究这个问题，我特意写了示例程序</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序由三个工程组成：接口模块、获取接口模块和主模块。</p><ul><li><p>接口模块 </p><p>对应的工程是 <code>Interface.vcxproj</code>，代码很简单，声明并实现了一些接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DLL_INTERFACE_EXPORT</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_INTERFACE_EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Interface1::Test1(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test2(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test3(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test4(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>获取接口模块</p><p>对应的工程是 <code>GetInterface.vcxproj</code>，依赖<strong>接口模块</strong>。代码非常简单，只暴露了一个接口，用来获取接口对象指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DLL_GETINTERFACE_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_GET __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_GET __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_GET InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DLL_EXPORT_GET <span class="keyword">void</span> <span class="title">FreeInterface</span><span class="params">(InterfaceBase*)</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_GETINTERFACE_EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GetInterface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeInterface</span><span class="params">(InterfaceBase* if1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> if1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>主模块</p><p>对应的工程是 <code>InterfaceExe.vcxproj</code>，只依赖<strong>获取接口模块</strong>，不依赖<strong>接口模块</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../GetInterface/GetInterface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterfaceBase* base = GetInterface();</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(base);</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    FreeInterface(if1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>示例工程已经上传到本篇博客对应的资料仓库里，感兴趣的小伙伴儿可以自行到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module" target="_blank" rel="noopener">这里</a>下载验证。</p><p>在以上代码中：</p><ol><li><p><code>if1-&gt;Test4()</code> <strong>会</strong>导致链接错误</p><p>报错信息如下：</p><p><code>LNK2019 无法解析的外部符号 &quot;__declspec(dllimport) public: void __cdecl Interface1::Test4(int)&quot; (__imp_?Test4@Interface1@@QEAAXH@Z)，该符号在函数 main 中被引用</code></p></li></ol><ol start="2"><li><p><code>if1-&gt;Test1()</code> <strong>不会</strong>导致链接错误。惊不惊喜？意不意外？</p><p>注释掉 <code>if1-&gt; Test4();</code> 即可顺利编译，所以可以确定 <code>if1-&gt;Test1()</code> 不会导致链接错误</p></li></ol><p>在解释之前，先回顾一下基础。</p><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><p>我之前写过一篇关于函数基础知识的总结—— <a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p>与当前问题相关的内容整理如下：</p><ul><li><p><code>B</code> 模块要想调用 <code>A</code> 模块中的函数，最重要的原则是：<code>B</code> 模块要能找到 <code>A</code> 模块函数的地址，一般情况下需要做两件事：</p><p><strong>首先</strong>，<code>A</code> 模块中的函数需要声明为导出的。导出的函数会记录在 <code>A</code> 模块的<strong>导出表</strong>中</p><p><strong>其次</strong>，通过头文件 + 库文件，让 <code>B</code> 模块依赖 <code>A</code> 模块。编译器会在 <code>B</code> 模块的<strong>导入表</strong>中添加对应项</p></li></ul><ul><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>虚函数调用是通过<strong>虚表</strong>实现的。大体调用过程如下：</p><ul><li><p>通过类对象找到虚表指针，进而找到虚表</p></li><li><p>根据头文件中虚函数的顺序得到索引</p></li><li><p>根据索引从虚表中取出函数地址进行调用</p></li></ul></li></ul><h2 id="简单解释"><a href="#简单解释" class="headerlink" title="简单解释"></a>简单解释</h2><p>下面我们尝试从虚函数的调用机制来理解编译器的行为：</p><ol><li><code>if1-&gt;Test4()</code> <strong>会</strong>导致链接错误<br>因为 <code>Test4()</code> 是普通成员函数，调用的时候，需要找到其地址。接口模块虽然导出了 <code>Test4()</code>，但是主模块并没有依赖接口模块。所以报链接错误很正常！</li></ol><ol start="2"><li><p><code>if1-&gt;Test1()</code> <strong>不会</strong>导致链接错误</p><p>已经得到了对象指针（<code>if1</code>），说明对象已经被构造好了，虚表指针已经指向了正确的虚表。因为 <code>Test1()</code> 是虚函数，调用 <code>Test1()</code> 是通过虚表进行的，直接到虚表对应的位置获取函数地址即可。 所以不会产生链接错误。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>如果 <code>B</code> 模块已经拿到了 <code>A</code> 模块中的类对象指针，通过该指针调用的类成员函数，</p><ul><li><p>如果调用的成员函数是<strong>普通函数</strong>，则 <code>B</code> 模块<strong>需要</strong>依赖 <code>A</code> 模块</p></li><li><p>如果调用的成员函数是<strong>虚函数</strong>，则 <code>B</code> 模块<strong>不需要</strong>依赖 <code>A</code> 模块</p></li></ul></li></ul><p>实际项目中遇到的正是这种情况：<code>B</code> 模块调用的是 <code>A</code> 模块中的虚函数，所以不需要依赖 <code>A</code> 模块；而 <code>C</code> 模块调用的是 <code>A</code> 模块中的普通成员函数，需要依赖 <code>A</code> 模块。至此，项目中的疑问算是彻底解开了。</p><p>这就完了？ 还有很多问题需要继续深挖……</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p></li><li><p>问题 4：如果在 <code>Interface1</code>  中声明了未导出的构造函数，上述代码能编译通过吗？</p></li><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p></li><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p></li></ul><p>争取在下一篇文章中把上面的坑都填上，<code>stay tuned~</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一段日子，同事遇到了一个奇怪的现象 —— &lt;code&gt;B&lt;/code&gt; 模块调用了 &lt;code&gt;A&lt;/code&gt; 模块某个类的成员函数，没有依赖 &lt;code&gt;A&lt;/code&gt; 模块，编译时没有报错。而 &lt;code&gt;C&lt;/code&gt; 模块也调用了 &lt;code&gt;A&lt;/code&gt; 模块中同一个类的成员函数，没有依赖 &lt;code&gt;A&lt;/code&gt; 模块，编译时却报了链接错误。&lt;/p&gt;
&lt;p&gt;简单语音沟通后觉得不太可能。用了 &lt;code&gt;A&lt;/code&gt; 模块的函数，却不依赖 &lt;code&gt;A&lt;/code&gt; 模块，有点儿不讲道理！&lt;/p&gt;
&lt;p&gt;因为当时我没在电脑前，跟同事简单沟通了几个可以设置库依赖的位置，结果都没有发现对应的依赖项。&lt;/p&gt;
&lt;p&gt;心里越发觉得不可思议，难道 &lt;code&gt;B&lt;/code&gt; 模块是通过其它方式依赖 &lt;code&gt;A&lt;/code&gt; 模块的？正常情况下，如果 &lt;code&gt;B&lt;/code&gt; 模块依赖 &lt;code&gt;A&lt;/code&gt; 模块，一定可以在 &lt;code&gt;B&lt;/code&gt; 模块的导入表中看到 &lt;code&gt;A&lt;/code&gt; 模块相关的记录。于是建议同事查看 &lt;code&gt;B&lt;/code&gt; 模块的导入表，但是同事不太熟悉。因为项目比较急，遂建议同事在 &lt;code&gt;C&lt;/code&gt; 模块中添加对 &lt;code&gt;A&lt;/code&gt; 模块的依赖，先解决项目问题，后面有机会再调查具体原因。&lt;/p&gt;
&lt;p&gt;直到最近才有时间调查这个问题，结果发现这个问题非常有意思 —— &lt;code&gt;B&lt;/code&gt; 模块确实没有依赖 &lt;code&gt;A&lt;/code&gt; 模块（&lt;code&gt;B&lt;/code&gt; 模块的导入表中确实没发现 &lt;code&gt;A&lt;/code&gt; 模块的相关项），但是 &lt;code&gt;B&lt;/code&gt; 模块确实调用了 &lt;code&gt;A&lt;/code&gt; 模块中的函数，而且不是通过 &lt;code&gt;LoadLibrary() + GetProcAddress()&lt;/code&gt; 的方式调用的。&lt;/p&gt;
&lt;p&gt;本文主要关注以下问题，如果你已经有了答案，可以跳过本文。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 模块在什么情况下可以调用 &lt;code&gt;A&lt;/code&gt; 模块中的函数，但是却不依赖 &lt;code&gt;A&lt;/code&gt; 模块？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="part2" scheme="https://bianchengnan.github.io/tags/part2/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/</id>
    <published>2024-07-12T20:37:07.000Z</published>
    <updated>2025-12-23T13:51:14.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近遇到了几个跟虚函数有关的问题，既有编译链接问题，又有运行问题，归根到底是基本功不扎实导致的问题。本文将会简单梳理一下函数相关的基本知识：</p><ul><li>函数是什么？</li><li>函数调用约定有哪些？有什么作用？</li><li>普通函数、类静态函数、类成员函数的区别是什么？</li><li>什么时候会调用构造函数，什么时候会调用析构函数？</li><li>调用虚函数与调用其它函数的区别是什么？</li><li><code>B</code> 模块如何调用 <code>A</code> 模块的函数？</li></ul><p>本文适合初学者，如果您已经有一定的开发经验，可以跳过本文。</p><a id="more"></a><h2 id="函数是什么？"><a href="#函数是什么？" class="headerlink" title="函数是什么？"></a>函数是什么？</h2><p>函数其实就是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>。一般情况下，函数编译后的二进制代码会被存储在可执行文件（又叫 <code>Portable Executive</code>，简称  <code>PE</code> ）的代码段中，程序启动时会加载到内存中。</p><p>有几个关键点需要牢记于心：</p><ol><li>每个函数的二进制代码都会存储在对应的模块中，相对模块基址一定的偏移处</li><li>模块加载到内存后会占据一段内存空间，这段内存空间中包含当前模块的函数、全局变量等</li><li>函数的虚拟地址是由 <strong>模块基址+函数相对于模块基址的偏移</strong> 决定的</li><li><strong>模块中函数地址相对于模块基址的偏移不会改变</strong>，模块的基址发生变化后，函数地址也会跟着变</li></ol><p>下图是用 <code>IDA</code> 查看 <code>ntoskrnl.exe</code> 中的函数情况。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/functions-in-module.png" alt="functions-in-module"></p><p><code>ntoskrnl.exe</code> 的基址是 <code>0x00000001 40000000</code>，每个函数相对于模块有一定的偏移。比如，<code>NtSetEvent</code> 相对于模块基址的偏移是 <code>0x00000001 406B2B60 - 0x00000001 40000000 = 0x006B2B60</code>。</p><p>如果下次启动的时候，<code>ntoskrnl.exe</code> 基址变了，<code>NtSetEvent</code> 的地址也会跟着变，但是相对于模块基址的偏移不会变。</p><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>函数调用约定有哪些？有什么作用？</p><p>在 <code>c++</code> 中，常用的调用约定有  <code>__cdecl</code>，<code>__stdcall</code>， <code>__fastcall</code>， <code>__thiscall</code>。</p><p><code>__cdecl</code> 是 <code>vs</code> 工程属性中默认的调用约定（可以在 <code>vs</code> 工程属性中设置，如下图），<code>__thiscall</code> 是类成员函数默认的调用约定，<code>Windows API</code> 一般会显式使用 <code>__stdcall</code>。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/set-default-calling-convention.png" alt="set-default-calling-convention"></p><p>调用约定的主要作用：</p><ul><li>影响函数名称，每种调用约定生成的函数名称不一样</li><li>影响参数传递方式</li><li>影响谁来平衡调用栈（调用者还是被调用者）</li></ul><h3 id="x86-程序"><a href="#x86-程序" class="headerlink" title="x86 程序"></a>x86 程序</h3><p>在 <code>x86</code> 程序中有各种调用约定，我简单的整理成了表格，如下：</p><table><thead><tr><th>调用约定</th><th>参数传递方式</th><th>谁来平衡堆栈</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-160" target="_blank" rel="noopener">__cdecl</a></td><td>所有参数通过栈传递，从右向左依次入栈，<code>ebp + 8</code> 指向第一个参数</td><td>调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/stdcall?view=msvc-160" target="_blank" rel="noopener">__stdcall</a></td><td>与 <code>__cdecl</code> 调用约定一样</td><td>被调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-160" target="_blank" rel="noopener">__fastcall</a></td><td>前两个 <code>DWORD</code> 类型的参数通过 <code>ecx</code>, <code>edx</code> 传递，其余参数从右向左依次入栈</td><td>被调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/thiscall?view=msvc-160" target="_blank" rel="noopener">__thiscall</a></td><td>对象指针通过 <code>ecx</code> 传递，其余参数与 <code>__cdecl</code> 调用约定一样通过栈传递</td><td>被调用者</td></tr></tbody></table><blockquote><p><strong>说明：</strong> <a href="https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a> 提到了更多种调用约定，感兴趣的小伙伴儿可以自行查看</p></blockquote><p>​                                                                                                                                                                                                                                                                                                                                         关于名字修饰规则可以参考《软件调试》第 <code>1</code> 版 第 <code>25</code> 章，<code>740</code> 页。</p><blockquote><p><strong>小贴士：</strong> 可以使用 <code>vs</code> 自带的工具 <code>undname.exe</code> 查看修饰前的函数名</p></blockquote><h3 id="x64-程序"><a href="#x64-程序" class="headerlink" title="x64 程序"></a>x64 程序</h3><p>在 <code>x64</code> 程序中只有一种调用约定 —— <code>__fastcall</code>。即使显式指定了调用约定，最后也会按 <code>__fastcall</code> 生成代码。</p><p>参数传递方式如下表（摘录自<a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a>）：</p><table><thead><tr><th align="left">Parameter type</th><th align="left">fifth and higher</th><th align="left">fourth</th><th align="left">third</th><th align="left">second</th><th align="right">leftmost</th></tr></thead><tbody><tr><td align="left">floating-point</td><td align="left">stack</td><td align="left">XMM3</td><td align="left">XMM2</td><td align="left">XMM1</td><td align="right">XMM0</td></tr><tr><td align="left">integer</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left">Aggregates (8, 16, 32, or 64 bits) and <strong><code>__m64</code></strong></td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left">Other aggregates, as pointers</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left"><strong><code>__m128</code></strong>, as a pointer</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr></tbody></table><p>各种典型情况下参数传递方式列举如下（摘录自同一个 <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a>，注释按习惯调整到上方了）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a in RCX, b in RDX, c in R8, d in R9, f then e pushed on stack</span></span><br><span class="line">func1(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in XMM0, b in XMM1, c in XMM2, d in XMM3, f then e pushed on stack</span></span><br><span class="line">func2(<span class="keyword">float</span> a, <span class="keyword">double</span> b, <span class="keyword">float</span> c, <span class="keyword">double</span> d, <span class="keyword">float</span> e, <span class="keyword">float</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in RCX, b in XMM1, c in R8, d in XMM3, f then e pushed on stack</span></span><br><span class="line">func3(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> c, <span class="keyword">float</span> d, <span class="keyword">int</span> e, <span class="keyword">float</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3,</span></span><br><span class="line"><span class="comment">// ptr to f pushed on stack, then ptr to e pushed on stack</span></span><br><span class="line">func4(__m64 a, __m128 b, struct c, <span class="keyword">float</span> d, __m128 e, __m128 f);</span><br></pre></td></tr></table></figure><h2 id="各种类型的函数比较"><a href="#各种类型的函数比较" class="headerlink" title="各种类型的函数比较"></a>各种类型的函数比较</h2><p>普通函数、类静态函数、类成员函数的区别是什么？</p><p>平时开发过程中，经常遇到的函数有普通函数、类静态成员函数、类成员函数（构造函数、析构函数等）。</p><p>它们的共同特点是：它们都是函数，编译后都是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>，都会保存在某个模块中。</p><p>它们最主要的区别在调用的写法上：</p><ul><li><p>调用普通函数，直接通过函数名即可</p></li><li><p>构造函数、析构函数会被自动调用</p><blockquote><p><strong>说明：</strong> 虽然是自动调用，其实是编译器生成了调用代码，不用我们手动写而已</p></blockquote></li><li><p>调用类成员函数的时候，需要通过类对象或类对象指针进行调用</p></li><li><p>调用类静态成员函数的时候需要加上类名限定</p><blockquote><p><strong>说明：</strong> 也可以通过类对象或类对象指针进行调用，编译器会自动推断类型</p></blockquote></li></ul><p>以下示例代码展示了这三种函数的调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">T1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">(CDemo*, <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T1(<span class="number">0</span>);</span><br><span class="line">    CDemo::T1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CDemo demo;</span><br><span class="line">    demo.T2(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    T2(&amp;demo, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>x64</code> 程序中，<code>T1()</code> 与 <code>CDemo::T1()</code> ，<code>T2()</code> 与 <code>CDemo::T2()</code> 是等价的，会生成同样的汇编代码。如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/function-call-disassembly-x64.png" alt="function-call-disassembly-x64"></p><p>在 <code>x86</code> 程序中，由于调用约定不同，<code>T2()</code> 与 <code>CDemo::T2()</code> 的参数传递方式不同，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/function-call-disassembly-x86.png" alt="function-call-disassembly-x86"></p><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>什么时候会调用构造函数，什么时候会调用析构函数？</p><ul><li><p>当一个类对象被构造出来的时候，会调用构造函数</p><p>比如有一个名为 <code>CTest</code> 的类。下面两句代码都会导致类构造函数被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTest t1;</span><br><span class="line">  CTest* p = <span class="keyword">new</span> CTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个类对象的生命周期结束的时候，会调用析构函数</p><p>一个对象的生命周期什么时候结束呢？有两种情况：</p><ol><li>变量超出作用域</li><li>显式调用 <code>delete</code> </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTest t1;</span><br><span class="line">  CTest* p = <span class="keyword">new</span> CTest();</span><br><span class="line">  <span class="keyword">delete</span> p; <span class="comment">// delete 内部会调用析构函数</span></span><br><span class="line">&#125; <span class="comment">// t1 会在这里被析构</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>敲黑板：</strong> 如果不在 <code>B</code> 模块中实例化 <code>A</code> 模块中的类对象，那么对 <code>B</code> 模块而言 <code>A</code> 模块的构造函数不必是导出的。析构函数也是一样的道理。</p></blockquote><h2 id="虚函数-vs-其它函数"><a href="#虚函数-vs-其它函数" class="headerlink" title="虚函数 vs 其它函数"></a>虚函数 vs 其它函数</h2><p>调用虚函数与调用其它函数的区别是什么？</p><p>我之前写过一篇关于虚函数的总结 —— <a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a>（如果图挂了可以看<a href="https://zhuanlan.zhihu.com/p/240765167" target="_blank" rel="noopener">这里</a>）。</p><p>介绍了虚函数的相关内容：虚表都包含哪些内容、虚表指针的初始化时机、虚函数是如何支持多态的。这里再简单总结一下：</p><ul><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>虚函数调用是通过虚表实现的。大体调用过程如下：</p><ul><li>通过类对象找到虚表指针，进而找到虚表</li><li>根据头文件中虚函数的顺序得到索引</li><li>根据索引从虚表中取出函数地址进行调用</li></ul></li></ul><p>调用虚函数与调用其它函数最主要的区别是：</p><p>调用普通函数的时候，会直接跳转到函数首地址；调用虚函数的时候，会通过虚表跳转到函数首地址。</p><h2 id="跨模块调用"><a href="#跨模块调用" class="headerlink" title="跨模块调用"></a>跨模块调用</h2><p><code>B</code> 模块如何调用 <code>A</code> 模块中的函数？</p><p><code>B</code> 模块要想调用 <code>A</code> 模块中的函数，最重要的原则是：<code>B</code> 模块要能找到 <code>A</code> 模块中的函数地址，一般情况下需要做两件事：</p><p><strong>首先</strong>，<code>A</code> 模块中的函数需要声明为导出的。导出的函数会记录在 <code>A</code> 模块的<strong>导出表</strong>中</p><p><strong>其次</strong>，通过头文件 + 库文件，让 <code>B</code> 模块依赖 <code>A</code> 模块。编译器会在 <code>B</code> 模块的<strong>导入表</strong>中添加对应项</p><blockquote><p><strong>说明：</strong> 还可以通过 <code>GetAddressProc()</code> 找到函数地址进行调用</p></blockquote><p><code>B</code> 模块依赖 <code>A</code> 模块，在 <code>vs</code> 中有三种设置方法：</p><h2 id="解决库依赖的三种方法"><a href="#解决库依赖的三种方法" class="headerlink" title="解决库依赖的三种方法"></a>解决库依赖的三种方法</h2><ol><li><p>在代码中使用 <code>#pragma comment(lib, libA)</code> 进行依赖</p><p>可以不修改工程配置，直接在代码中设置依赖</p></li></ol><ol start="2"><li><p>在 <code>B</code> 模块对应项目的链接器设置中，添加对项目 <code>A</code> 的依赖</p><p>这是比较常规的做法，设置方法如下图：<img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/add-lib-in-project-link-option.png" alt="add-lib-in-project-link-option"></p></li></ol><ol start="3"><li><p>在 <code>B</code> 模块对应项目的引用配置中添加对项目 <code>A</code> 的引用</p><p>此方法最简单，最省心，甚至都不用考虑被依赖的库文件的生成路径！<img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/add-project-reference.png" alt="add-project-reference"></p></li></ol><blockquote><p><strong>注意：</strong> 前两种方法，可能需要在附加库目录中配置 <code>libA</code> 的路径，第三种方法不用。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>函数是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>，会被存储在模块中的某个位置，<strong>相对于模块基址的偏移不会改变</strong>，模块的基址发生变化后，函数地址也会跟着变</li><li>调用约定会影响编译后的函数名、参数传递方式、谁来平衡调用栈</li><li><code>x86</code> 程序有各种调用约定，<code>x64</code> 程序只有 <code>__fastcall</code> 一种调用约定</li><li>调用函数的两个关键点是：<ul><li>找到函数地址</li><li>明确参数传递方式（由调用约定决定）</li></ul></li><li>调用外部模块的函数，需要依赖对应的库。在 <code>vs</code> 中解决库依赖有三种方法：<ul><li>在代码中使用 <code>#pragma comment(lib, libA)</code> 进行依赖</li><li>在 <code>B</code> 模块对应项目的链接器设置中，添加对项目 <code>A</code> 的依赖</li><li>在 <code>B</code> 模块对应项目的引用配置中添加对项目 <code>A</code> 的引用</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>《软件调试》第一版 </p></li><li><p>调用约定相关参考链接</p><ul><li><a href="https://learn.microsoft.com/en-us/cpp/cpp/calling-conventions?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/cpp/calling-conventions?view=msvc-160</a></li><li><a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160</a></li><li><a href="https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近遇到了几个跟虚函数有关的问题，既有编译链接问题，又有运行问题，归根到底是基本功不扎实导致的问题。本文将会简单梳理一下函数相关的基本知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数是什么？&lt;/li&gt;
&lt;li&gt;函数调用约定有哪些？有什么作用？&lt;/li&gt;
&lt;li&gt;普通函数、类静态函数、类成员函数的区别是什么？&lt;/li&gt;
&lt;li&gt;什么时候会调用构造函数，什么时候会调用析构函数？&lt;/li&gt;
&lt;li&gt;调用虚函数与调用其它函数的区别是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 模块如何调用 &lt;code&gt;A&lt;/code&gt; 模块的函数？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文适合初学者，如果您已经有一定的开发经验，可以跳过本文。&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="part1" scheme="https://bianchengnan.github.io/tags/part1/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（下）</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/</id>
    <published>2024-06-08T09:39:23.000Z</published>
    <updated>2025-12-23T13:51:13.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在前面两篇文章中，应该算是彻底理清了项目中存在的两个问题。感兴趣的小伙伴儿可以参考<a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1">《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》</a>和 <a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2">《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）》</a>。</p><p>在上篇文章的末尾提到一种情况</p><blockquote><p>如果在 <code>LoadDlls.exe</code> 中也显式加载了 <code>dll3.dll</code>，还会不会崩溃呢？答案是<strong>可能崩溃，也可能不崩溃</strong>。</p><p>因为 <code>RegisterInitCallback()</code>内部更新数据时使用的是 <code>map.insert()</code>，这会导致一个问题 —— 如果 <code>map</code> 中已经存在相同的 <code>key</code>，那么 <code>insert()</code> 会失败，不会更新数据。</p><p>试想，如果显式加载 <code>dll3.dll</code> 成功，但是 <code>dll3.dll</code> 的基址变了。<code>map</code> 中保存的还是旧的无效地址，而不是新函数地址。</p><p>如果 <code>dll3.dll</code> 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常<strong>“幸运”</strong>的正常运行。 </p></blockquote><p>本文通过实战来验证上文中的结论，什么情况下会崩溃，什么情况下不崩溃。</p><a id="more"></a><h2 id="显式加载-dll3-dll"><a href="#显式加载-dll3-dll" class="headerlink" title="显式加载 dll3.dll"></a>显式加载 dll3.dll</h2><p>修改 <code>LoadDlls</code> 工程中的 <code>main()</code> 函数代码，使其加载 <code>dll1.dll</code>、<code>dll2.dll</code> 和 <code>dll3.dll</code>。修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="string">"dll3.dll"</span>, <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本以为这样修改后，应该偶尔会崩溃（因为默认开启了 <code>ASLR</code>，模块的加载基址应该会随机才对）。结果发现，每次运行都不崩溃，而且功能一切正常，着实有些出乎意料。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/function-normal.png" alt="function-normal"></p><p>看来 <code>dll3.dll</code> 每次都能加载到上一次被加载的基址。那怎么才能让 <code>dll3.dll</code> 加载到其它基址呢？</p><h2 id="改变加载基址"><a href="#改变加载基址" class="headerlink" title="改变加载基址"></a>改变加载基址</h2><p>最朴素的想法是，如果在显式加载 <code>dll3.dll</code> 之前，又加载了很多其它 <code>dll</code>，把原本 <code>dll3.dll</code> 加载的基址占用掉，那么再次加载 <code>dll3.dll</code> 的基址肯定会发生变化，大概率会崩溃。</p><p>按照这个思路，修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="string">"dll4.dll"</span>, <span class="string">"dll3.dll"</span>, <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完成后，把 <code>dll1.dll</code> 复制一份，修改名字为 <code>dll4.dll</code>，然后运行 <code>LoadDlls.exe</code>，果然崩溃了。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/app-crashed.png" alt="app-crashed"></p><blockquote><p><strong>小提示：</strong> 如果删除 <code>dll4.dll</code>，再次运行程序，又不崩溃了</p></blockquote><p>调查一下崩溃原因，看看是不是跟我们预期的一样。</p><h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><p>用 <code>windbg</code> 打开转储文件后，点击 <code>!analyze -v</code>，分析结果如下：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/windbg-analyze-v.png" alt="windbg-analyze-v"></p><p>可以发现在执行 <code>movsxd rax,dword ptr [rax+4]</code> 的时候崩溃了，而且这段反汇编代码属于 <code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush()</code>。在 <code>windbg</code> 中查看相关反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-disassembly-of-flush.png" alt="view-disassembly-of-flush"></p><p>从上图可知，<code>rax</code> 的值最开始来源于 <code>rsp+0x50</code>（<code>mov rax, qword ptr [rsp+50h]</code>），而 <code>rsp+0x50</code> 的值又来源于 <code>rcx</code>（<code>mov qword ptr [rsp+8], rcx</code>，<code>sub rsp, 48h</code>）。</p><p>在遍历调用 <code>s_init_callbacks</code> 保存的回调函数的时候并不会使用 <code>rcx</code>，因此 <code>rcx</code> 的值是是随机的，那么使用了 <code>rcx</code> 而崩溃是可以理解的。</p><p>还有一个小问题：为什么 <code>dll2!Init()</code> 会调用 <code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush()</code> 呢？</p><h2 id="进一步调查"><a href="#进一步调查" class="headerlink" title="进一步调查"></a>进一步调查</h2><p>使用命令 <code>dx dll2!s_init_callbacks</code> 查看  <code>dll2!s_init_callbacks</code> 的内容，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-s_init_callbacks.png" alt="view-s_init_callbacks"></p><p>可以发现 <code>dll2!s_init_callbacks</code> 中保存的函数地址是 <code>0x7ffd 929e12e4</code>，对应的函数是 <code>dll4!@ILT+735(?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ)</code>，该函数最终会调用<code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush</code>。</p><p>使用 <code>lmm dll*</code> 查看相关模块加载情况，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-modules.png" alt="view-modules"></p><p>从上图可知，<code>dll4.dll</code> 的基址与已经卸载的 <code>dll3.dll</code> 的基址是一样的，都是 <code>00007ffd 929d0000</code>，新加载的 <code>dll3.dll</code> 的基址已经变成了 <code>00007ffd 8c540000</code>。</p><p><code>s_init_callbacks</code> 中保存的函数地址相对于模块基址的偏移是 <code>0x7ffd 929e12e4 - 00007ffd 929d0000 = 0x112e4</code>，换算成在 <code>dll3.dll</code> 中的地址是 <code>0x00007ffd 8c540000 + 0x112e4 = 0x00007ffd 8c5512e4</code>。在 <code>windbg</code> 中使用 <code>ln 0x00007ffd8c5512e4</code> 查看于该地址对应的符号，输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; ln <span class="number">0x00007ffd8c5512e4</span></span><br><span class="line">Browse <span class="keyword">module</span></span><br><span class="line">Set bu breakpoint</span><br><span class="line"></span><br><span class="line">(<span class="number">00007f</span>fd`<span class="number">8</span>c5512e4)   dll3!ILT+<span class="number">735</span>(?Dll3InitCallbackYAXXZ)   |  (<span class="number">00007f</span>fd`<span class="number">8</span>c5512e9)   dll3!ILT+<span class="number">740</span>(?flush?$basic_ostreamDU?$char_traitsDstdstdQEAAAEAV12XZ)</span><br><span class="line">Exact matches:</span><br></pre></td></tr></table></figure><p>可以发现与 <code>dll3!ILT+735(?Dll3InitCallbackYAXXZ)</code> 完全匹配。</p><p>至此，所有疑问都已经解开了。<code>dll3.dll</code> 加载的时候会注册回调函数，由于异常 <code>dll3.dll</code> 会被自动卸载，但是注册回调函数并没有取消注册，<code>dll4.dll</code> 紧接着被加载到了 <code>dll3.dll</code> 旧基址，再次加载 <code>dll3.dll</code>，新的 <code>dll3.dll</code> 被加载到了其他位置。<code>dll3.dll</code> 最开始注册的回调函数变成了 <code>dll4.dll</code> 中的函数。</p><p>因为这是实际项目中遇到的问题，非常有代表性，而且崩溃的代码与业务代码毫不相干，很难查！</p><p>总结下来，主要有两大问题：</p><ol><li>在全局变量的构造函数中调用 <code>LoadLibrary()</code> 加载新的 <code>dll</code>，这是很危险的操作，应该尽量避免。</li><li>当使用 <code>insert()</code> 而不是 <code>operator[]</code> 向 <code>map</code> 中插入数据时，如果对应的 <code>key</code> 已经存在，不会更新数据。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>lm</code> 可以显示模块信息（包括已经卸载的模块信息），<code>lmm dll*</code> 可以显示以 <code>dll</code> 开头的模块</li><li><code>map.insert()</code> 在插入新数据时，如果发现对应的 <code>key</code> 已经存在，会直接返回 <code>false</code>，而不会更新数据。<code>operator []</code> 会强制更新数据</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在前面两篇文章中，应该算是彻底理清了项目中存在的两个问题。感兴趣的小伙伴儿可以参考&lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1&quot;&gt;《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》&lt;/a&gt;和 &lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2&quot;&gt;《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在上篇文章的末尾提到一种情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果在 &lt;code&gt;LoadDlls.exe&lt;/code&gt; 中也显式加载了 &lt;code&gt;dll3.dll&lt;/code&gt;，还会不会崩溃呢？答案是&lt;strong&gt;可能崩溃，也可能不崩溃&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;RegisterInitCallback()&lt;/code&gt;内部更新数据时使用的是 &lt;code&gt;map.insert()&lt;/code&gt;，这会导致一个问题 —— 如果 &lt;code&gt;map&lt;/code&gt; 中已经存在相同的 &lt;code&gt;key&lt;/code&gt;，那么 &lt;code&gt;insert()&lt;/code&gt; 会失败，不会更新数据。&lt;/p&gt;
&lt;p&gt;试想，如果显式加载 &lt;code&gt;dll3.dll&lt;/code&gt; 成功，但是 &lt;code&gt;dll3.dll&lt;/code&gt; 的基址变了。&lt;code&gt;map&lt;/code&gt; 中保存的还是旧的无效地址，而不是新函数地址。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;dll3.dll&lt;/code&gt; 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常&lt;strong&gt;“幸运”&lt;/strong&gt;的正常运行。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文通过实战来验证上文中的结论，什么情况下会崩溃，什么情况下不崩溃。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="全局变量" scheme="https://bianchengnan.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/</id>
    <published>2024-05-12T08:39:23.000Z</published>
    <updated>2025-12-23T13:51:13.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在<a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1">上篇文章《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》</a>中，解决了由于全局变量初始化顺序不对导致的崩溃问题。但是代码里还有一处非常隐蔽的 <code>bug</code>，今天继续介绍一下这个问题及对应的解决方法。</p><a id="more"></a><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>在上篇文章代码的基础上，修改 <code>LoadDlls</code> 工程中的 <code>main()</code> 函数代码，使其加载 <code>dll1.dll</code> 和 <code>dll2.dll</code>（上篇文章中只加载了 <code>dll1.dll</code>）。修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="comment">/*"dll3.dll",*/</span> <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="keyword">auto</span> loaded_module_map = LoadPlugins(plugins);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin done, press any key to init plugins."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">    InitPlugins(loaded_module_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直接运行崩溃了"><a href="#直接运行崩溃了" class="headerlink" title="直接运行崩溃了"></a>直接运行崩溃了</h2><p>运行完 <code>LoadPlugins()</code> 后，点击任意按键继续运行，会继续执行 <code>InitPlugins()</code>，程序会在此函数中崩溃。因为我设置 <code>procdump</code> 为 <code>JIT</code> 调试器（具体设置方法可以参考<a href="https://bianchengnan.github.io/articles/process-dump-tools-you-should-know/">这篇文章</a>），程序崩溃后会自动调用 <code>procdump</code> 保存崩溃转储文件。</p><p>用 <code>windbg</code> 打开转储文件，无脑点击 <code>!analyze -v</code>，让 <code>windbg</code> 帮我们自动分析，分析结果如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/exception-when-excute-from-unloaded-dll3.png" alt="exception-when-excute-from-unloaded-dll3"></p><p>从上图中的<strong>调用栈</strong>基本可以确定在执行 <code>dll3.dll</code> 中的代码时发生了异常。</p><p>而且这次的异常不是因为<strong>读/写</strong>非法地址导致的，而是执行到非法地址导致的（注意红色高亮部分的提示 <code>Attempt to execute non-executable address 00007ffbdd9812e4</code>）。</p><p>可以猜测 <code>00007ffbdd9812e4</code> 是属于 <code>dll3.dll</code> 的（可以通过 <code>!address 00007ffbdd9812e4</code> 验证），而且当执行到 <code>00007ffbdd9812e4</code> 的时候，<code>dll3.dll</code> 已经被卸载了（注意底部红色高亮部分的 <code>Unloaded</code> 关键字）。</p><p>使用 <code>!address 00007ffbdd9812e4</code> 查看该地址的信息，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/address-00007ffbdd9812e4.png" alt="address-00007ffbdd9812e4"></p><p>从上图可知，<code>00007ffbdd9812e4</code> 确实是属于 <code>dll3.dll</code> 的，但是 <code>dll3.dll</code> 已经被卸载了。<code>00007ffbdd9812e4</code> 所在的页面是 <code>MEM_FREE</code> 的，而且是 <code>PAGE_NOACCESS</code> 的。</p><p>但是，程序为什么会执行到一个已经被卸载的模块中的地址呢？</p><h2 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h2><p>从调用栈可以得知，<code>dll3.dll</code> 中的函数是由 <code>dll2!Init()</code> 调用的， 通过查看  <code>dll2!Init()</code> 源码，可以发现 <code>dll2!Init()</code> 函数中会遍历 <code>s_init_callbacks</code>。在 <code>windbg</code> 中输入<code>dx dll2!s_init_callbacks</code> 查看其内容，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/view-s_init_callbacks.png" alt="view-s_init_callbacks"></p><p>可以发现，<code>s_init_callbacks</code> 中只有一项，是 <code>dll3.dll</code> 中的函数。</p><p>根据源码可知，<code>dll3.dll</code> 在加载的时候会自动调用 <code>dll2!RegisterInitCallback()</code> 注册回调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterInitCallback(<span class="string">"dll3"</span>, Dll3InitCallback);</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure><p>可以推理，<code>s_init_callbacks</code> 中的函数是 <code>dll3!Dll3InitCallback</code>。</p><p>加载 <code>dll3.dll</code> 的调试符号后，查看调用栈，可以证实我们的猜想。如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/compare-callstacks-after-reload-dll3-symbol.png" alt="compare-callstacks-after-reload-dll3-symbol"></p><p>根据源码可知，<code>dll3.dll</code> 在加载的时候还会自动调用 <code>RegisterCallback()</code>，相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterCallback(<span class="string">"dll3"</span>, Dll3Callback);</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure><p>因为调用 <code>RegisterCallback()</code> 的时候发生了异常（在<a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1">上篇文章</a>中已经分析过了），导致 <code>dll3.dll</code> 加载失败，<code>dll3.dll</code> 会被自动<strong>卸载</strong> 。但是通过 <code>RegisterInitCallback()</code> 注册的回调函数已经保存在了 <code>dll2!s_init_callbacks</code> 中，没有被清除。</p><p>当后面调用 <code>dll2!Init()</code> 时，会调用 <code>dll3.dll</code> 注册到  <code>dll2!s_init_callbacks</code> 中的函数（<code>Dll3InitCallback</code>），因为 <code>dll3.dll</code> 已经被卸载了，对应的函数地址也无效了，也就会发生上文中的异常。</p><h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h2><p>如果在 <code>LoadDlls.exe</code> 中也显式加载了 <code>dll3.dll</code>，还会不会崩溃呢？答案是<strong>可能崩溃，也可能不崩溃</strong>。</p><p>因为 <code>RegisterInitCallback()</code>内部更新数据时使用的是 <code>map.insert()</code>，这会导致一个问题 —— 如果 <code>map</code> 中已经存在相同的 <code>key</code>，那么 <code>insert()</code> 会失败，不会更新数据。</p><p>试想，如果显式加载 <code>dll3.dll</code> 成功，但是 <code>dll3.dll</code> 的基址变了。<code>map</code> 中保存的还是旧的无效地址，而不是新函数地址。</p><p>如果 <code>dll3.dll</code> 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常<strong>“幸运”</strong>的正常运行。 </p><p>要想规避这种问题，可以换一种写法，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterInitCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//s_init_callbacks.insert(std::make_pair(key, callback));</span></span><br><span class="line">    s_init_callbacks[key] = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>调试由于模块被卸载导致的异常，其实很简单 —— 直接在 <code>windbg</code> 中使用 <code>!analyze -v</code> 基本上就可以定位到问题了</p></li><li><p>这次的崩溃，直接原因在于模块被意外的卸载了，归根结底还是代码不规范导致的</p></li><li><p>如果 <code>map</code> 中想保存最新数据，那么不要使用 <code>map.insert</code>，而要使用 <code>operater []</code></p></li><li><p><code>map.insert()</code> 在插入新数据时，如果发现对应的 <code>key</code> 已经存在，会直接返回 <code>false</code>，而不会更新数据。<code>operator []</code> 会强制更新数据</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1&quot;&gt;上篇文章《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》&lt;/a&gt;中，解决了由于全局变量初始化顺序不对导致的崩溃问题。但是代码里还有一处非常隐蔽的 &lt;code&gt;bug&lt;/code&gt;，今天继续介绍一下这个问题及对应的解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="全局变量" scheme="https://bianchengnan.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/</id>
    <published>2024-03-23T07:39:23.000Z</published>
    <updated>2025-12-23T13:51:13.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近又遇到了一个程序功能不正常的问题，深入调查后发现与全局变量初始化顺序有非常大的关系，只不过这次更加隐蔽。</p><p>之前总结了两篇与全局变量初始化顺序有关的文章，感兴趣的小伙伴儿可以参考<a href="https://bianchengnan.github.io/articles/debugging-dll-load-failure-caused-by-global-variable-initialize-dependency/">《调试实战 | dll 加载失败之全局变量初始化篇》</a> 和 <a href="https://bianchengnan.github.io/articles/global-variable-initialization-order-investigation/">《调试实战 | 全局变量初始化顺序探究》</a>。</p><a id="more"></a><p>在排查错误之前先简单介绍一下相关代码。</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序一共包含 <code>4</code> 个工程：<code>LoadDlls, dll1, dll2, dll3</code>。</p><ul><li><p>主程序 <code>LoadDlls.exe</code> 会加载 <code>dll1.dll</code></p></li><li><p><code>dll1.dll</code> 隐式依赖了 <code>dll2.dll</code>，所以 <code>dll1.dll</code> 加载的时候会自动加载 <code>dll2.dll</code></p></li><li><p><code>dll2.dll</code> 中的全局变量 <code>s_culprit</code> 的构造函数会加载 <code>dll3.dll</code></p></li><li><p><code>dll3.dll</code> 加载的时候会自动调用 <code>dll2.dll</code> 的导出函数 <code>RegisterInitCallback()</code> 和 <code>RegisterCallback()</code></p></li></ul><p>下面是每个工程的关键代码</p><ul><li><p><code>src/common/autorunner.h</code> </p><p>该文件是公共头文件，实现了自动注册逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// autorunner.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoRunner</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AutoRunner(<span class="keyword">void</span> (*func)())</span><br><span class="line">    &#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_CAT(s1, s2) s1 ## s2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_WITH_LINE(name, <span class="meta-keyword">line</span>) STR_CAT(name, <span class="meta-keyword">line</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGIN_AUTO_RUN static AutoRunner NAME_WITH_LINE(s_auto_runner_, __LINE__) ([]()&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END_AUTO_RUN  &#125;);</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>LoadDlls</code> </p><p>该工程只有一个源文件，用来模拟加载各种插件。对应的源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadDlls.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFN_Init)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, HMODULE&gt; LoadPlugins(<span class="keyword">const</span> <span class="keyword">char</span>* plugins[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, HMODULE&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; ; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* plugin = plugins[idx];</span><br><span class="line">        <span class="keyword">if</span> (plugin == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HMODULE <span class="keyword">module</span> = LoadLibraryA(plugin);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD lastError = GetLastError();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load ［"</span> &lt;&lt; plugin &lt;&lt; <span class="string">"] failed with error "</span> &lt;&lt; lastError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[plugin] = <span class="keyword">module</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitPlugins</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, HMODULE&gt;&amp; loaded_plugins)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : loaded_plugins)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> init_entry = (PFN_Init)GetProcAddress(it.second, <span class="string">"Init"</span>);</span><br><span class="line">        <span class="keyword">if</span> (init_entry != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            init_entry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="comment">/*"dll2.dll", "dll3.dll",*/</span> <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> loaded_module_map = LoadPlugins(plugins);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin done, press any key to init plugins."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">    InitPlugins(loaded_module_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>dll1</code> </p><p>该工程非常简单，什么有用的事情都没做，但是会依赖 <code>dll2</code>，加载 <code>dll1.dll</code> 的时候会自动加载 <code>dll2.dll</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain1.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/autorunner.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../dll2/exports.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMajorVersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Major Version of dll2.dll is "</span> &lt;&lt; MajorVersion() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_AUTO_RUN</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm running in dll1.dll, which implicitly depends on dll2.dll."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>dll2</code></p><p>该模块提供了注册回调函数的导出接口，并实现了回调逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exports.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_DLL2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT extern <span class="meta-string">"C"</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT extern <span class="meta-string">"C"</span> __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">int</span> <span class="title">MajorVersion</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">RegisterInitCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span>;</span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">RegisterCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_DLL2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"exports.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MajorVersion</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">void</span>(*)()&gt; s_init_callbacks;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterInitCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_init_callbacks.insert(<span class="built_in">std</span>::make_pair(key, callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGlobalVariable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyGlobalVariable() &#123; <span class="keyword">auto</span> <span class="keyword">module</span> = LoadLibrary(<span class="string">L"dll3.dll"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyGlobalVariable s_culprit;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">void</span>(*)()&gt; s_callbacks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_callbacks.insert(<span class="built_in">std</span>::make_pair(key, callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : s_init_callbacks)</span><br><span class="line">    &#123;</span><br><span class="line">        it.second();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>dll3</code></p><p>该模块会<strong>自动</strong>调用 <code>dll2.dll</code> 导出的接口进行注册</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain3.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/autorunner.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../dll2/exports.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dll3InitCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm callback from dll3.dll"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterInitCallback(<span class="string">"dll3"</span>, Dll3InitCallback);</span><br><span class="line">END_AUTO_RUN</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dll3Callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm callback from dll3.dll"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterCallback(<span class="string">"dll3"</span>, Dll3Callback);</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure></li></ul><p>直接运行程序，从表面上看一切正常，但是在调试器下运行程序的时候会遇到一个意想不到的异常。</p><h2 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h2><p>打开 <code>windbg</code>，选择需要执行的程序，确定后输入 <code>g</code> 命令，目标程序会发生异常，自动中断到 <code>windbg</code> 中。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/exception-break-to-windbg.png" alt="exception-break-to-windbg"></p><p>在 <code>windbg</code> 中输入 <code>kc</code> 查看调用栈，输出结果摘录如下（为了方便查看，输出结果有所调整，注意 <code>&lt;----</code> 的部分）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; kc</span><br><span class="line"> # Call Site</span><br><span class="line"><span class="number">00</span> dll2!<span class="built_in">std</span>::_Tree&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span>)&gt;::_Insert_nohint&lt;...&gt;()</span><br><span class="line"><span class="number">01</span> dll2!<span class="built_in">std</span>::_Tree&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span>)&gt;::emplace&lt;...&gt;()</span><br><span class="line"><span class="number">02</span> dll2!<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span>)&gt;::insert&lt;...&gt;()</span><br><span class="line"><span class="number">03</span> dll2!RegisterCallback  <span class="comment">//&lt;----</span></span><br><span class="line"><span class="number">04</span> dll3!&lt;lambda_7ce22ad9d321cf7c9be3c0faf7e37347&gt;::<span class="keyword">operator</span>()</span><br><span class="line"><span class="number">05</span> dll3!&lt;lambda_7ce22ad9d321cf7c9be3c0faf7e37347&gt;::&lt;lambda_invoker_cdecl&gt;</span><br><span class="line"><span class="number">06</span> dll3!AutoRunner::AutoRunner  <span class="comment">//&lt;----</span></span><br><span class="line">07 dll3!`dynamic initializer for 's_auto_runner_23''</span><br><span class="line"><span class="number">08</span> ucrtbased!_initterm</span><br><span class="line"><span class="number">09</span> dll3!dllmain_crt_process_attach</span><br><span class="line"><span class="number">0</span>a dll3!dllmain_crt_dispatch</span><br><span class="line"><span class="number">0b</span> dll3!dllmain_dispatch</span><br><span class="line"><span class="number">0</span>c dll3!_DllMainCRTStartup</span><br><span class="line"><span class="number">0</span>d ntdll!LdrpCallInitRoutine</span><br><span class="line"><span class="number">0</span>e ntdll!LdrpInitializeNode</span><br><span class="line"><span class="number">0f</span> ntdll!LdrpInitializeGraphRecurse</span><br><span class="line"><span class="number">10</span> ntdll!LdrpPrepareModuleForExecution</span><br><span class="line"><span class="number">11</span> ntdll!LdrpLoadDllInternal</span><br><span class="line"><span class="number">12</span> ntdll!LdrpLoadDll</span><br><span class="line"><span class="number">13</span> ntdll!LdrLoadDll</span><br><span class="line"><span class="number">14</span> KERNELBASE!LoadLibraryExW</span><br><span class="line"><span class="number">15</span> dll2!MyGlobalVariable::MyGlobalVariable   <span class="comment">//&lt;----</span></span><br><span class="line">16 dll2!`dynamic initializer for 's_culprit''</span><br><span class="line"><span class="number">17</span> ucrtbased!_initterm</span><br><span class="line"><span class="number">18</span> dll2!dllmain_crt_process_attach</span><br><span class="line"><span class="number">19</span> dll2!dllmain_crt_dispatch</span><br><span class="line"><span class="number">1</span>a dll2!dllmain_dispatch</span><br><span class="line"><span class="number">1b</span> dll2!_DllMainCRTStartup</span><br><span class="line"><span class="number">1</span>c ntdll!LdrpCallInitRoutine</span><br><span class="line"><span class="number">1</span>d ntdll!LdrpInitializeNode</span><br><span class="line"><span class="number">1</span>e ntdll!LdrpInitializeGraphRecurse</span><br><span class="line"><span class="number">1f</span> ntdll!LdrpInitializeGraphRecurse</span><br><span class="line"><span class="number">20</span> ntdll!LdrpPrepareModuleForExecution</span><br><span class="line"><span class="number">21</span> ntdll!LdrpLoadDllInternal</span><br><span class="line"><span class="number">22</span> ntdll!LdrpLoadDll</span><br><span class="line"><span class="number">23</span> ntdll!LdrLoadDll</span><br><span class="line"><span class="number">24</span> KERNELBASE!LoadLibraryExW</span><br><span class="line"><span class="number">25</span> KERNELBASE!LoadLibraryExA</span><br><span class="line"><span class="number">26</span> KERNELBASE!LoadLibraryA</span><br><span class="line"><span class="number">27</span> LoadDlls!LoadPlugins  <span class="comment">//&lt;----</span></span><br><span class="line"><span class="number">28</span> LoadDlls!main</span><br><span class="line"><span class="number">29</span> LoadDlls!invoke_main</span><br><span class="line"><span class="number">2</span>a LoadDlls!__scrt_common_main_seh</span><br><span class="line"><span class="number">2b</span> LoadDlls!__scrt_common_main</span><br><span class="line"><span class="number">2</span>c LoadDlls!mainCRTStartup</span><br><span class="line"><span class="number">2</span>d KERNEL32!BaseThreadInitThunk</span><br><span class="line"><span class="number">2</span>e ntdll!RtlUserThreadStart</span><br></pre></td></tr></table></figure><p>在 <code>windbg</code> 中输入 <code>.frame 0x27</code> 切换到 <code>0x27</code> 栈帧，然后输入 <code>dv</code> 查看局部变量，可以发现确实是在加载 <code>dll1.dll</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; .frame <span class="number">0x27</span></span><br><span class="line"><span class="number">27</span> <span class="number">000000</span>d5`<span class="number">3</span>a4ff610 <span class="number">00007f</span>f7`da7debb7     LoadDlls!LoadPlugins+<span class="number">0xb3</span> [D:\MyBlogStuff\LoadDlls\src\LoadDlls\LoadDlls.cpp @ <span class="number">19</span>] </span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dv</span><br><span class="line">         <span class="keyword">module</span> = <span class="number">0xcccccccc</span>`cccccccc</span><br><span class="line">         plugin = <span class="number">0x00007ff7</span>`da7ea740 <span class="string">"dll1.dll"</span></span><br><span class="line">            idx = <span class="number">0</span>n0</span><br><span class="line">        plugins = <span class="number">0x000000d5</span>`<span class="number">3</span>a4ff868</span><br><span class="line">         result = &#123; size=<span class="number">0x0</span> &#125;</span><br></pre></td></tr></table></figure><p>结合代码可以整理整个执行流程，大概是这样的：</p><ul><li><p>主程序 <code>LoadDlls.exe</code> 会通过 <code>LoadPlugins()</code> 调用 <code>LoadLibrary()</code> 来加载 <code>dll1.dll</code>，由于 <code>dll1.dll</code> 隐式依赖了 <code>dll2.dll</code>，所以 <code>dll1.dll</code> 加载的时候会自动加载 <code>dll2.dll</code>。</p></li><li><p><code>dll2.dll</code> 中的全局变量 <code>s_culprit</code> 的构造函数（栈帧 <code>0x15</code>）内部会调用 <code>LoadLibrary()</code> 加载 <code>dll3.dll</code>（栈帧 <code>0x14</code>）</p></li><li><p><code>dll3.dll</code> 中的全局变量 <code>s_auto_runner_23</code> 的构造函数（栈帧 <code>0x6</code>）内部会调用 <code>dll2.dll</code> 的导出函数 <code>RegisterCallback()</code>（栈帧 <code>0x3</code>）</p></li><li><p><code>RegisterCallback()</code> 内部会调用 <code>s_callbacks.insert()</code> 把注册的回调函数保存起来，但是在保存过程中遇到了异常，中断到了 <code>windbg</code> 中。</p></li></ul><h2 id="查看异常"><a href="#查看异常" class="headerlink" title="查看异常"></a>查看异常</h2><p>根据 <code>windbg</code> 给出的提示，可以发现是在读取地址 <code>0x00000008</code> 的时候发生了异常，此地址明显是不可访问的。</p><p><code>00007ffd 57684ff1 488b4008    mov rax,qword ptr [rax+8] ds:00000000 00000008=????????????????</code></p><p>看上去非常像是空指针异常。这段代码是在调用  <code>s_callbacks.insert()</code> 的时候执行的，大概率是 <code>s_callbacks</code> 出了问题，在 <code>windbg</code> 中使用 <code>dx s_callbacks -r4</code> 查看  <code>s_callbacks</code> 的值，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/view-s_callbacks.png" alt="view-s_callbacks"></p><p>可以发现，<code>s_callbacks</code> 中的值很奇怪，都是空值。看上去很像还没有初始化的样子。</p><p>结合上面整理的调用流程，可以发现是在调用 <code>dll2!s_culprit</code> 的构造函数时接触发了对 <code>dll2!RegisterCallback()</code> 的调用，这时 <code>dll2!s_callbacks</code> 这个全局变量还没有初始化。</p><p>因为初始化完 <code>dll2!s_culprit</code>，才会初始化 <code>dll2!s_callbacks</code>。</p><p>至此，可以破案了。只需要调整一下这两个全局变量的顺序，问题就解决了。修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyGlobalVariable s_culprit; // 移动到 s_callbacks 下面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">void</span>(*)()&gt; s_callbacks;</span><br><span class="line"></span><br><span class="line">MyGlobalVariable s_culprit;</span><br></pre></td></tr></table></figure><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>相关工程代码已经上传到 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/LoadDlls" target="_blank" rel="noopener">github</a> 了，感兴趣的小伙伴儿可以下载验证。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次故障是因为在 <code>dll2.dll</code> 的全局变量 <code>s_culprit</code> 的构造函数中使用 <code>LoadLibrary()</code> 加载了 <code>dll3.dll</code>，而 <code>dll3.dll</code> 中的全局变量构造函数会调用 <code>dll2!RegisterCallback()</code>，这个函数内部会使用未初始化的全局变量 <code>dll2!s_callbacks</code>。因为此时正在初始化 <code>dll2!s_culprit</code> 的过程中，<code>dll2!s_culprit</code> 初始化完成后才会初始化 <code>dll2!s_callbacks</code>。</p><p>相较于之前的案例，这次的案例更复杂，涉及到了多个模块。单看每个模块，问题都不大，但是放到一起就触发了这个异常。</p><p>所以，尽量不要在全局变量的构造函数中做复杂的工作，尤其要避免类似 <code>LoadLibrary</code> 的操作。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices</a></li></ul><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>其实，这个问题背后还有一个更隐蔽的 <code>bug</code>，不知道你是否看出来了呢？<code>stay tuned!</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近又遇到了一个程序功能不正常的问题，深入调查后发现与全局变量初始化顺序有非常大的关系，只不过这次更加隐蔽。&lt;/p&gt;
&lt;p&gt;之前总结了两篇与全局变量初始化顺序有关的文章，感兴趣的小伙伴儿可以参考&lt;a href=&quot;https://bianchengnan.github.io/articles/debugging-dll-load-failure-caused-by-global-variable-initialize-dependency/&quot;&gt;《调试实战 | dll 加载失败之全局变量初始化篇》&lt;/a&gt; 和 &lt;a href=&quot;https://bianchengnan.github.io/articles/global-variable-initialization-order-investigation/&quot;&gt;《调试实战 | 全局变量初始化顺序探究》&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="全局变量" scheme="https://bianchengnan.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>2024 开工喽</title>
    <link href="https://bianchengnan.github.io//articles/2024-startup/"/>
    <id>https://bianchengnan.github.io//articles/2024-startup/</id>
    <published>2024-02-20T13:15:25.000Z</published>
    <updated>2025-12-23T13:51:13.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回首-2023"><a href="#回首-2023" class="headerlink" title="回首 2023"></a>回首 2023</h2><p>回顾整个 <code>2023</code> ，相比 <code>2022</code>  加班少了，工作没那么拼命了。</p><p>由于各种原因，年初立的 <code>flag</code> 好几个都没实现。</p><ul><li>公众号基本上处于鸽的状态</li><li>也没分享技术视频</li><li>语言倒是接触了一下 <code>rust</code>，但远没有达到能实战的地步</li><li>嘴没管住，腿倒是迈开了</li></ul><h2 id="展望-2024"><a href="#展望-2024" class="headerlink" title="展望 2024"></a>展望 2024</h2><p>我对 <code>2024</code> 这个数字感到非常亲切，<code>2024 = 1000 + 1024</code>，两个<strong>一千</strong></p><ul><li><p><strong>今年的首要任务依旧是锻炼身体</strong></p><p>本来计划 <code>2024</code> 年跑步作为日常锻炼的方式，结果 <code>2023</code> 年最后一次从公司跑回家后膝盖疼，<code>2024</code> 只能偶尔跑跑了</p></li></ul><ul><li><strong>继续遛狗</strong><br><code>2023</code> 花费了很大一部分时间在遛狗上，<code>2024</code> 继续努力。如果不是狗子的陪伴，估计我早抑郁了，感谢，感恩。</li></ul><ul><li><p><strong>坚持练习英语口语</strong></p><p>希望这次不要因为任何原因中断</p></li></ul><ul><li><p><strong>继续坚持分享技术文章</strong></p><p>遇到值得总结的问题，及时总结分享</p></li></ul><ul><li><p><strong>读一些非技术书籍</strong></p><p>之前看的书以技术书籍为主，<code>2024</code> 年争取多看些非技术的书籍</p></li></ul><ul><li><p><strong>做一些改变</strong></p><p>尽量熟悉 <code>AI</code> 相关的人和事</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回首-2023&quot;&gt;&lt;a href=&quot;#回首-2023&quot; class=&quot;headerlink&quot; title=&quot;回首 2023&quot;&gt;&lt;/a&gt;回首 2023&lt;/h2&gt;&lt;p&gt;回顾整个 &lt;code&gt;2023&lt;/code&gt; ，相比 &lt;code&gt;2022&lt;/code&gt;  加班少了
      
    
    </summary>
    
      <category term="年度总结" scheme="https://bianchengnan.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的递归栈查看（续）</title>
    <link href="https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack-continue/"/>
    <id>https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack-continue/</id>
    <published>2024-01-06T02:30:22.000Z</published>
    <updated>2025-12-23T13:51:14.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在上篇<a href="https://bianchengnan.github.io/articles/how-to-view-startup-function-from-a-deep-recursive-stack/">文章</a>中介绍了在 <code>windbg</code> 中如何查看非常深的调用栈 —— 使用 <code>kN</code> 命令指定栈帧数。<code>kN</code> 虽好，但最多只能查看 <code>0xffff</code> 个栈帧。如果栈帧数量比 <code>0xffff</code> 还多，该如何查看呢？本文将介绍几种查看方法。</p><a id="more"></a><p>在介绍查看方法前，需要对线程栈的特点有个基本的认识。</p><h2 id="线程栈的关键特性"><a href="#线程栈的关键特性" class="headerlink" title="线程栈的关键特性"></a>线程栈的关键特性</h2><ul><li><p>线程栈是从高向低扩展的，当向栈上 <code>push</code> 一个值的时候，栈底指针 <code>esp</code> 的值会减小。</p></li><li><p>函数返回地址会保存到栈上：</p><p>函数 <code>A</code> 调用函数 <code>B</code> 的时候，会把 <code>B</code> 需要的参数根据调用约定放到对应的位置，有可能是通过寄存器传递，也有可能通过栈传递。处理完参数后会执行 <code>call B</code>，而 <code>call</code> 指令可以简单理解为以下两个操作：</p><ol><li><strong>把返回地址（调用函数 B 的下一条指令地址）入栈</strong></li><li><strong>跳转到函数 <code>B</code> 继续执行</strong></li></ol><p>如果函数 <code>B</code> 会调用另外一个函数 <code>C</code>，那么会遵循相同的规律：会把返回地址（ <strong><code>call C</code> 后面的地址</strong>）入栈，然后跳转到 <code>C</code> 继续执行。当 <code>C</code> 执行结束的时候，<code>CPU</code> 会从栈上把保存的返回地址弹出到 <code>rip</code> 中，这样就可以继续从函数 <code>B</code> 中调用函数 <code>C</code> 的下一条指令继续执行了。</p></li></ul><p>根据以上几点可以得到一个非常重要的结论：如果 <code>A</code> 调用了 <code>B</code>，<code>B</code> 又调用了 <code>C</code>，<code>C</code> 又调用了 <code>D</code>。那么 <code>B</code> 返回到 <code>A</code> 的地址在线程栈的高处，<code>C</code> 返回到 <code>B</code> 的地址在线程栈的低处，<code>D</code> 返回到 <code>C</code> 的地址在线程栈的最低处。</p><p>有了以上的基本认识，就可以使用以下几种方法查看调用栈了。</p><h2 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h2><p><strong>方法1：</strong>使用 <code>.kframes</code> 设置默认显示的栈帧数量</p><p>​    增大默认显示数量，这样就可以一次性显示更多的调用栈</p><p><strong>方法2：</strong>使用 <code>dps</code>，自己识别调用栈</p><p>​    可以灵活高效的从指定的位置开始查找</p><p><strong>方法3：</strong>使用 <code>k</code> 命令的时候指定 <code>StackPtr</code></p><p>​    可以从指定位置开始显示调用栈，不必从头开始显示</p><p>为了方便验证每种方法的可行性，我写了一个非常简单的递归调用测试程序，为了让调用栈可以更深一些，我修改了工程设置中的<strong>堆栈保留大小</strong>为 <code>0x70800000</code>（大概 <code>1.75 GB</code> ）。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recursive</span><span class="params">(<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Recursive(--depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallRecursive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Recursive(<span class="number">0x7fffffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CallRecursive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试工程可以到<a href="https://github.com/bianchengnan/MyBlogStuff/tree/master/how-to-view-startup-function-from-a-deep-recursive-stack-continue" target="_blank" rel="noopener">这里</a>下载。</p><p>接下来依次介绍每种查看方法。</p><h2 id="方法1：使用-kframes-设置默认显示的栈帧数量"><a href="#方法1：使用-kframes-设置默认显示的栈帧数量" class="headerlink" title="方法1：使用 .kframes 设置默认显示的栈帧数量"></a>方法1：使用 <code>.kframes</code> 设置默认显示的栈帧数量</h2><p>在 <code>windbg</code> 的帮助文档中发现可以通过 <code>.kframes</code> 命令来设置 <code>k</code> 命令默认显示的栈帧数量。但是也不是可以显示无限多个栈帧。</p><p>那么通过 <code>.kframes</code> 可以设置的最大栈帧数是多少呢？通过几次尝试，我发现 <code>.kframes</code> 可以接受的最大值是 <code>32</code> 位的带符号整数的最大值，也就是 <code>0x7fffffff</code>（对应的十进制是 <code>2147483647</code>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/try-to-find-max-kframes-number.png" alt="try-to-find-max-kframes-number"></p><p> 但是，如果通过 <code>.kframes</code> 命令把栈帧数设置为 <code>0x7fffffff</code> 后，再执行 <code>k</code> 命令，发现 <code>windbg</code> 会直接提示内存分配失败。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-failed-after-kframes-set-to-0x7fffffff.png" alt="windbg-k-failed-after-kframes-set-to-0x7fffffff"></p><p>尝试把栈帧数设置为 <code>0x1000000</code>，再执行 <code>k</code> 命令，发现 <code>windbg</code> 的内存占用非常高，高峰期大概消耗了 <code>20GB</code> 的物理内存（下图中的 <code>Working Set</code> 列），经过将近两分钟的努力，最终还是以内存分配失败告终~</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-memory-usage-kframe-0x10000000.png" alt="windbg-memory-usage-kframe-0x10000000"></p><p>又试了几个更小的值，发现在我的机器上（<code>24GB</code> 物理内存）设置为 <code>0x1000000</code> 时可以输出结果，但是因为数据量太大了，等了半个多小时也没执行完~</p><p>虽然这次 <code>.kframes</code> 没能成功，但这绝对是一个非常值得了解的命令，可以处理绝大多数情况下的线程栈查看问题。</p><p><strong>优点：</strong> </p><ol><li>操作非常简单</li><li>可以处理绝大多数情况</li></ol><p><strong>缺点：</strong> </p><ol><li>会影响后续 <code>k</code> 命令默认显示效果（仅限当前调试会话，<code>windbg</code> 重启后会自动失效）</li><li>当调用栈过深的时候，<code>k</code> 命令可能会<strong>非常非常非常</strong>慢（对于示例程序，半个小时还没执行完）</li><li>内存占用可能会非常高（需要分配内存来显示对应的信息）</li><li>不能解决调用栈过深的问题（受到物理内存的限制）</li><li>很难找到一个合适的值（设置的太大，可能消耗过多的资源，运行慢；设置的太小，调用栈可能显示不全）</li></ol><h2 id="方法2：使用-dps，自己识别调用栈"><a href="#方法2：使用-dps，自己识别调用栈" class="headerlink" title="方法2：使用 dps，自己识别调用栈"></a>方法2：使用 <code>dps</code>，自己识别调用栈</h2><p>在 <code>windbg</code> 中可以通过 <code>dps</code> 以指针长度为单位打印出指定内存范围的值，同时会输出匹配的符号。</p><p><strong>操作步骤：</strong></p><ol><li>通过 <code>!teb</code> 指令找到栈顶（<code>StackBase</code>）的位置，然后减去一定的值（比如 <code>64kb</code>）得到一个较低的地址 <code>A</code>。</li><li>执行 <code>dps A StackBase</code>。如果输出结果中没有包含感兴趣的函数，可以减去一个更大的值，再次执行 <code>dps</code> 并查看输出结果，直到输出结果中包含感兴趣的函数为止。</li><li>根据 <code>dps</code> 的输出内容手动识别调用栈。</li></ol><p><strong>实战：</strong></p><p>通过 <code>!teb</code> 命令获取栈顶位置（<code>0000002a33800000</code>）然后减去 <code>64KB</code> （<code>0x10000</code>，也可以换成其它值，一般情况下 <code>64KB</code> 足够了）得到地址 <code>0000002a337f0000</code>，然后执行 <code>dps 0000002a337f0000 0000002a33800000</code>。或者可以直接直接输入 <code>dps 0000002a33800000-0x10000 0000002a33800000</code>。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-dps.png" alt="windbg-dps"></p><p>根据 <code>dps</code> 的结果可知，已经包含了关键的递归函数 —— <code>TestDeepRecursive!Recursive</code>，可以根据此次 <code>dps</code> 的输出结果手动识别调用栈。拉到输出结果的最下方，可以看到输出结果如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-dps-manual-reconstruct-callstack.png" alt="windbg-dps-manual-reconstruct-callstack"></p><p>从上图可以看到 <code>main</code> 函数，<code>CallRecursive</code> 函数，<code>Recursive</code> 函数。而且与 <code>vs</code> 中的调用栈完美匹配。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-callstack-in-vs.png" alt="view-callstack-in-vs"></p><blockquote><p><strong>说明：</strong> 输出结果中<strong>极有可能</strong>包含很多无关的信息（比如上图中的黄色高亮部分），需要仔细甄别。</p></blockquote><p><strong>优点：</strong> </p><ol><li>输出结果速度非常快</li><li>非常灵活，强大</li></ol><p><strong>缺点：</strong></p><ol><li>需要对线程栈有一定的认识</li><li>需要人肉识别调用栈，有一定难度</li><li>比较依赖调试符号，如果没有调试符号，只根据地址信息，很难找出关联关系</li><li>容易出错，因为栈上的内容比较杂，可能包含很多无关的信息</li></ol><h2 id="方法3：使用-k-命令的时候指定-StackPtr"><a href="#方法3：使用-k-命令的时候指定-StackPtr" class="headerlink" title="方法3：使用 k 命令的时候指定 StackPtr"></a>方法3：使用 <code>k</code> 命令的时候指定 <code>StackPtr</code></h2><p>前两种方法都有各自的优缺点，可以在前两种方法的基础上使用本方法——使用 <code>k</code> 命令的时候指定正确的 <code>StackPtr</code>，<code>windbg</code> 会自动帮我们识别调用栈。</p><p>使用本方法时需要传递一个<strong>正确</strong>的 <code>StackPtr</code>（调试 <code>x64</code> 程序时需要传递 <code>rsp</code>，调试 <code>x86</code> 程序时需要传递 <code>ebp</code>，也叫 <code>BasePtr</code> ），也可以同时指定要显示的栈帧数量。</p><p>关于 <code>k</code> 命令的帮助文档可以参考下图（截取自 <code>windbg</code> 帮助文档）：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-command-help.png" alt="windbg-k-command-help"></p><p>如果传递的 <code>StackPtr</code> 不对，那么输出结果很可能是错误的。比如，我使用一个错误的值执行 <code>k=0x0000002a337ff938</code> 输出结果如下：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/output-of-wrong-stackptr-k-command.png" alt="output-of-wrong-stackptr-k-command"></p><p>所以，传递一个正确的 <code>StackPtr</code> 是必须的。那么，该如何获取一个正确的 <code>StackPtr</code> 呢？有两个方法：</p><ol><li><p>执行 <code>k</code> 命令的时候，最左侧那一列就是 <code>rsp</code>（<code>x86</code> 程序对应着 <code>ebp</code>）。可以这样处理：先通过 <code>.kframes</code> 设置一个相对合理的值，然后执行 <code>k</code> 命令，等命令执行完，取最后一条输出结果的 <code>rsp</code> 的值，假设是 <code>00000029c3004040</code>，然后执行 <code>k=00000029c3004040 3</code>，就可以继续显示后续的三条调用栈了。重复此过程即可。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-start-at-specific-address.png" alt="windbg-k-start-at-specific-address"><br>实际使用的时候，可以尽量每次多显示一些栈帧，如果调用栈非常深，需要重复的次数会很多，但总比不能查看强！</p></li><li><p>在 <code>dps</code> 的输出结果中 <strong>“猜”</strong> 一个 <code>ebp</code> 或者 <code>rsp</code> 的值。说是猜，其实是有规律的。</p><p>2.1 对于 <code>x86</code> 的程序，<code>ebp</code> 保存了调用者的 <code>ebp</code>，<code>ebp+4</code> 的位置保存了返回地址。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-ebp-by-dps.png" alt="view-ebp-by-dps"></p><p>根据上图可以猜测，一个合法的 <code>ebp</code> 的值是 <code>0x009ef908</code>。</p><p>在 <code>windbg</code> 中输入 <code>k=0x09ef908 0x100</code>，可以得到下图完美的调用栈：<img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/k-0x009ef908-0x100.png" alt="k-0x009ef908-0x100"></p><p>2.2 对于 <code>x64</code> 的程序，<code>rsp-8</code> 的位置保存了返回地址。可以根据有意义的符号名称对应的最左侧地址值 <code>+8</code> 得到 <code>rsp</code> 的值。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-rsp-by-dps.png" alt="view-rsp-by-dps"></p><p>根据上图可知，一个合法的 <code>rsp</code> 的值是 <code>0x0000002a337ffbd0</code>。在 <code>windbg</code> 中输入 <code>k=0x0000002a337ffbd0 0x100</code>，可以得到下图完美的调用栈：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/k-0000002a337ffbd0-0x100.png" alt="k-0000002a337ffbd0-0x100"></p></li></ol><p><strong>优点：</strong></p><ol><li>输出效率高，只需要显示关心的栈帧即可</li><li>不用自己识别调用栈，可以像普通的 <code>k</code> 命令一样输出调用栈</li></ol><p><strong>缺点：</strong></p><ol><li>需要指定一个合法的 <code>StackPtr</code>，不能随便指定</li><li>需要非常了解  <code>x86/x64</code> 程序的调用栈，这样才能比较快速准确的找到合法的 <code>StackPtr</code></li></ol><p>所以，<code>dps</code> <code>+</code> <code>k=StackPtr [FrameCount]</code> 是最高效，最优雅的解决方案。</p><blockquote><p><strong>说明：</strong> 如果知道了一个合法的 <code>StackPtr</code>，也可以先通过 <code>r rsp = StackPtr</code> 修改 <code>rsp</code> 寄存器的值，然后再执行 <code>k</code> 命令显示调用栈。但是这个方法有一个<strong>特别不好</strong>的地方，<code>rsp</code> 会被修改，后续用到 <code>rsp</code> 寄存器的命令都会受影响。因此，不推荐使用。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用 <code>.kframes</code> 可以设置默认显示的栈帧数，可以突破默认最多显示 <code>0xffff</code> 个栈帧的限制，但是注意如果设置的值太大，会非常消耗内存</li><li><code>dps</code> 可以按指针打印一系列的值，并且会显示匹配的符号。务必记住此命令，非常有用</li><li>使用 <code>k</code> 命令时，可以指定 <code>StackPtr</code> 来从指定位置开始显示调用栈</li><li>对于 <code>x86</code> 的程序，<code>ebp</code> 保存了调用者的 <code>ebp</code>，<code>ebp+4</code> 的位置保存了返回地址。<strong>非常重要！！！</strong></li><li>对于 <code>x64</code> 的程序，<code>rsp-8</code> 的位置保存了返回地址。<strong>非常重要！！！</strong></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://devblogs.microsoft.com/oldnewthing/20130906-00/?p=3303" target="_blank" rel="noopener">https://devblogs.microsoft.com/oldnewthing/20130906-00/?p=3303</a></p><p><a href="https://blog.aaronballman.com/2011/07/reconstructing-a-corrupted-stack-crawl/" target="_blank" rel="noopener">https://blog.aaronballman.com/2011/07/reconstructing-a-corrupted-stack-crawl/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在上篇&lt;a href=&quot;https://bianchengnan.github.io/articles/how-to-view-startup-function-from-a-deep-recursive-stack/&quot;&gt;文章&lt;/a&gt;中介绍了在 &lt;code&gt;windbg&lt;/code&gt; 中如何查看非常深的调用栈 —— 使用 &lt;code&gt;kN&lt;/code&gt; 命令指定栈帧数。&lt;code&gt;kN&lt;/code&gt; 虽好，但最多只能查看 &lt;code&gt;0xffff&lt;/code&gt; 个栈帧。如果栈帧数量比 &lt;code&gt;0xffff&lt;/code&gt; 还多，该如何查看呢？本文将介绍几种查看方法。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="stack" scheme="https://bianchengnan.github.io/tags/stack/"/>
    
      <category term="递归" scheme="https://bianchengnan.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://bianchengnan.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
