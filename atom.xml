<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BianChengNan&#39;s Blog</title>
  
  <subtitle>Coding is hard, you can make it easy!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bianchengnan.github.io/"/>
  <updated>2025-12-13T05:48:33.731Z</updated>
  <id>https://bianchengnan.github.io/</id>
  
  <author>
    <name>BianChengNan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>置顶声明</title>
    <link href="https://bianchengnan.github.io//articles/top-most-announcement/"/>
    <id>https://bianchengnan.github.io//articles/top-most-announcement/</id>
    <published>2029-03-01T01:29:14.000Z</published>
    <updated>2025-12-13T05:48:33.731Z</updated>
    
    <content type="html"><![CDATA[<p>实在抱歉，因为图片使用的是 <code>http</code> 链接，在 <code>chrome</code> 或者 <code>edge</code> 浏览器中打开本博客的时候，看不到文章中的图片。</p><p>可以在 <code>chrome</code> 中通过 <code>chrome://flags</code> （在 <code>edge</code> 中通过 <code>edge://flags</code>）启用 <code>Insecure origins treated as secure</code>，</p><p>并且把图床地址 <a href="http://resources.bianchengnan.tech" target="_blank" rel="noopener">http://resources.bianchengnan.tech</a> 加入到信任列表的方式查看图片。（非常感谢群友 张帆 的提示）</p><p>整个操作如下图：</p><p><img src="http://resources.bianchengnan.tech/top-most-announcement/enable-show-image-in-chrome.png" alt="enable-show-image-in-chrome"></p><p>如果还不能查看相关图片，请联系我，或者到我的公众号里查看。</p><p>我的个人微信号是 <code>BianChengNan</code>，公众号是 <code>编程难</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实在抱歉，因为图片使用的是 &lt;code&gt;http&lt;/code&gt; 链接，在 &lt;code&gt;chrome&lt;/code&gt; 或者 &lt;code&gt;edge&lt;/code&gt; 浏览器中打开本博客的时候，看不到文章中的图片。&lt;/p&gt;
&lt;p&gt;可以在 &lt;code&gt;chrome&lt;/code&gt; 中通过 
      
    
    </summary>
    
      <category term="原" scheme="https://bianchengnan.github.io/categories/%E5%8E%9F/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>内存都去哪了？探究 VirtualAlloc 分配背后被“浪费”的 60KB</title>
    <link href="https://bianchengnan.github.io//articles/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/"/>
    <id>https://bianchengnan.github.io//articles/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/</id>
    <published>2025-12-06T13:43:53.000Z</published>
    <updated>2025-12-13T05:48:33.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录了一次因  <code>VirtualAlloc</code> 分配失败引发的 <code>OOM</code> 问题排查过程。通过编写测试程序模拟内存分配，发现 <code>32</code> 位进程在未开启 <code>Large Address Aware</code> 时，用户空间仅 <code>2GB</code> 可用，且 <code>VirtualAlloc</code> 实际分配粒度均为 <strong>64KB</strong>——若申请 <code>4KB</code>，剩余 <code>60KB</code> 将变为不可用空间，导致地址空间碎片化与大量浪费。借助 <code>VMMap</code> 碎片视图与 <code>Windbg</code> 分析，直观展示了分配粒度对内存布局的影响，并验证了按 <code>64KB</code> 对齐分配可避免该问题。</p><a id="more"></a><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>测试代码非常简单，我就直接贴到这里了，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nk = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usage: TestVirtualAlloc.exe N(kb). default 4kb"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    nk = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pAddr = VirtualAlloc(<span class="literal">nullptr</span>, nk * <span class="number">1024</span>, MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">        <span class="keyword">if</span> (pAddr == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"VirtualAlloc(%dkb) loop %6d failed. last error 0n%d\r\n"</span>, nk, idx++, GetLastError());</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"VirtualAlloc(%dkb) loop %6d succeed. address 0x%08x\r\n"</span>, nk, idx++, pAddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Free-空间出乎意料的大"><a href="#Free-空间出乎意料的大" class="headerlink" title="Free 空间出乎意料的大"></a>Free 空间出乎意料的大</h2><p>编译 <code>32</code> 位版本的程序，执行 <code>TestVirtualAlloc.exe 4</code>（每次分配 <code>4kb</code>），执行一段时间后，最终会失败，如下图：</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/virtual-alloc-failed.png" alt="virtual-alloc-failed"></p><p>这是预料内的现象，因为程序在不停的分配空间，<code>32</code> 位进程的虚拟地址空间仅有 <code>4GB</code>，在未开启 <code>Large Address Aware</code> 的情况下，用户程序可用的空间仅有 <code>2GB</code> 空间可用。</p><p>用 <code>windbg</code> 附加到该进程，执行 <code>!address -summary</code> 查看地址空间情况，发现 <code>Free</code> 占比有点太大了（<code>88.90%</code>），这不符合预期。程序在不停的分配空间，虽然没有 <code>commit</code>，但是已经 <code>reserve</code> 了，不应该有这么多 <code>Free</code> 空间才对。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/address-summary.png" alt="address-summary"></p><p><code>VMMap</code> 是查看虚拟内存空间的神器，可以非常详细的查看某个进程的内存空间布局。何不用 <code>VMMap</code> 查看一下？</p><h2 id="请出-VMMap"><a href="#请出-VMMap" class="headerlink" title="请出 VMMap"></a>请出 VMMap</h2><p>打开 <code>VMMap</code> 并选择 <code>TestVirtualAlloc.exe</code>，查看其虚拟内存空间。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/vmmap-view-memory.png" alt="vmmap-view-memory"></p><blockquote><p><strong>说明：</strong>切记勾选 <code>Options</code> 选项下的 <code>Show Free and Unsuable Regions</code></p></blockquote><p>当我看到 <code>60 K</code> 的 <code>Unusable</code> 跟在 <code>4 K</code> 的 <code>Private Data</code> 后时，沉睡的记忆终于被唤醒了，<code>VirtualAlloc</code> 的分配粒度是 <code>64kb</code> ！！！</p><p>在 <code>windbg</code> 中使用 <code>!address</code> 命令查看地址 <code>0x00490000</code> 和 <code>0x00491000</code> 的情况，如下图：</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/windbg-address-490000-491000.png" alt="windbg-address-490000-491000"></p><p>地址 <code>0x00491000</code> 所属的区域是 <code>MEM_FREE</code> 的。需要注意的是虽然从 <code>0x00491000</code> 开始的 <code>60kb</code> 是 <code>Free</code> 的，但是这块地址不能被分配使用了，这就是为什么 <code>VMMap</code> 中显示为 <code>Unusable</code> 的原因。</p><p>如果我分配的是 <code>64kb</code>，那么就不会有这么大的 <code>Free</code> 空间了。是不是呢？简单验证一下就知道了。</p><h2 id="继续验证"><a href="#继续验证" class="headerlink" title="继续验证"></a>继续验证</h2><p>执行 <code>TestVirtualAlloc.exe 64</code>（每次会分配 <code>64kb</code>），然后使用 <code>windbg</code> 观察内存空间的情况。</p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/address-summary-no-much-free-memory.png" alt="address-summary-no-much-free-memory"><p>可以发现 <code>MEM_FREE</code> 类型的内存空间很小了，基本上全是 <code>MEM_RESERVE</code> 类型的内存空间。使用 <code>VMMap</code> 查看的话，也差不多，这里就不截图了。感兴趣的小伙伴可以自己动手实验。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>折腾完，我突然意识到一个致命问题 —— 我的系统是 <code>64</code> 位的啊。<code>32</code> 位程序在 <code>64</code> 位操作系统下，用户态内存空间应该是 <code>4GB</code> 才对，这里为啥才 <code>2GB</code> 呢？想必聪明的你也一定知道其中的缘由了，想要使用 <code>4GB</code> 的内存空间，必须开启 <code>Large Address Aware</code> 才行。</p><p>经过确认，编译程序的时候，默认是没开启这个选项的。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/enable-large-address-aware.png" alt="enable-large-address-aware"></p><p>开启后，再次执行程序，可以发现可分配的内存地址是大于 <code>2gb</code> 的，接近 <code>4gb</code>。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/allocate-at-address-higher-than-2gb.png" alt="allocate-at-address-higher-than-2gb"></p><h2 id="Fragmentation-View"><a href="#Fragmentation-View" class="headerlink" title="Fragmentation View"></a>Fragmentation View</h2><p>其实，<code>VMMap</code> 还有一个非常强悍的功能，叫 <code>Fragmentation View</code>。此功能可以鸟瞰进程的整个内存空间，也可以放大到对应的区域查看，点击对应区域还可以查看具体的地址范围。从下图可以很明显的看到每次分配 <code>4kb</code> 的内存分布模式 —— <code>4kb</code> 的 <code>reserve</code> 空间（黄色方块）后跟着 <code>60kb</code> 的 <code>Unusable</code> 空间（灰色区域）。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/vmmap-fragment-view.png" alt="vmmap-fragment-view"></p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>我已经把对应的示例代码上传到了 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/TestVirtualAlloc" target="_blank" rel="noopener">github</a>，感兴趣的小伙伴可以自行实验。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>VMMap</code> 是查看虚拟内存空间的神兵利器</li><li><code>VirtualAlloc</code> 分配粒度是 <code>64kb</code>，如果分配的过小，会产生浪费，甚至是内存碎片</li><li>开启 <code>Large Address Aware</code> 后，<code>32</code> 位程序才能使用更大的内存空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录了一次因  &lt;code&gt;VirtualAlloc&lt;/code&gt; 分配失败引发的 &lt;code&gt;OOM&lt;/code&gt; 问题排查过程。通过编写测试程序模拟内存分配，发现 &lt;code&gt;32&lt;/code&gt; 位进程在未开启 &lt;code&gt;Large Address Aware&lt;/code&gt; 时，用户空间仅 &lt;code&gt;2GB&lt;/code&gt; 可用，且 &lt;code&gt;VirtualAlloc&lt;/code&gt; 实际分配粒度均为 &lt;strong&gt;64KB&lt;/strong&gt;——若申请 &lt;code&gt;4KB&lt;/code&gt;，剩余 &lt;code&gt;60KB&lt;/code&gt; 将变为不可用空间，导致地址空间碎片化与大量浪费。借助 &lt;code&gt;VMMap&lt;/code&gt; 碎片视图与 &lt;code&gt;Windbg&lt;/code&gt; 分析，直观展示了分配粒度对内存布局的影响，并验证了按 &lt;code&gt;64KB&lt;/code&gt; 对齐分配可避免该问题。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="vmmap" scheme="https://bianchengnan.github.io/tags/vmmap/"/>
    
  </entry>
  
  <entry>
    <title>排错实战 | 当编译器&quot;吃掉&quot;函数声明：一次由宏冲突引发的离奇编译错误</title>
    <link href="https://bianchengnan.github.io//articles/troubleshoot-another-compile-error/"/>
    <id>https://bianchengnan.github.io//articles/troubleshoot-another-compile-error/</id>
    <published>2025-12-06T13:43:53.000Z</published>
    <updated>2025-12-13T05:48:33.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在编译 <code>.NET Runtime</code> 源码研究 <code>GC</code> 机制时，我遇到了一个离奇的编译错误：函数 <code>__asan_handle_no_return</code> 的声明被编译器报错为”类函数宏的调用”。通过将源文件预处理输出到中间文件，我发现这个函数声明竟然变成了 <code>void ;</code>——它被”吃掉”了！追踪发现，在 <code>utils.h</code> 中定义了一个同名宏，当 <code>__SANITIZE_ADDRESS__</code> 宏未定义时，该宏被展开为空，导致函数声明被意外删除。这个案例再次证明：<strong>宏命名冲突是编译错误的常见陷阱</strong>，而<strong>预处理输出文件</strong>是诊断这类问题的利器。同时，<code>FileLocator</code> 这类文件搜索工具在源码分析中不可或缺。</p><a id="more"></a><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>从 <a href="https://github.com/dotnet/runtime" target="_blank" rel="noopener">https://github.com/dotnet/runtime</a> 下载源代码到本地，打开 <code>powershell</code> 执行 <code>.\build.cmd -vs coreclr.sln -a x64 -c Debug</code>，一切顺利的话会生成对应的 <code>sln</code> 文件。打开 <code>sln</code> 文件，重新生成解决方案，就遇到了下面的错误。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/compile-error.png" alt="compile-error"></p><p>从图中看，这就是一个很简单的函数声明啊，这还能出错？如果仔细看提示，<code>类函数宏的调用</code>。可以猜想这个错误跟宏有关系。难道又是一个宏冲突导致的问题？不管怎么样，还是老一套，把对应的源文件输出到中间文件，可以参考<a href="https://bianchengnan.github.io/articles/troubleshoot-vs-compile-error-C2589-illegal-token-on-right-side-of/">之前的文章</a>。</p><h2 id="初步调查"><a href="#初步调查" class="headerlink" title="初步调查"></a>初步调查</h2><p>错误工程是 <code>minipal_sanitizer_support</code>，出错的源文件是 <code>sansupport.c</code>。把 <code>sansupport.c</code> 经过预处理的文件输出到中间文件中，设置如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/preprocess-to-file-and-keep-comments.png" alt="preprocess-to-file-and-keep-comments"></p><p>设置好后，在 <code>sansupport.c</code> 上右键，编译，编译完成后，会生成一个名为 <code>sansupport.i</code> 的中间文件，打开此文件，并搜索 <code>__asan_handle_no_return</code>，仅发现了一条无关紧要的记录（在注释中出现），如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/search-keyword-and-find-one-useless.png" alt="search-keyword-and-find-one-useless"></p><p>呦吼，直接消失了？有点意思，搜索一下它上面的函数 <code>__asan_addr_is_in_fake_stack</code>。搜到了，而且有了意外收获 —— 目标函数变成了 <code>void ;</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/search-previous-function-and-find-target-function-missing.png" alt="search-previous-function-and-find-target-function-missing"></p><p>至此，已经可以基本确定是宏导致的了，在某处一定有一个与目标函数重名的宏，接下来该怎么办呢？还是搜。</p><h2 id="找出真凶"><a href="#找出真凶" class="headerlink" title="找出真凶"></a>找出真凶</h2><p>清楚 <code>FileLocator</code> 在下载的 <code>.net runtime</code> 源码目录下搜 <code>__asan_handle_no_return</code>，发现在 <code>utils.h</code> 中定义了这个宏。打开 <code>utils.h</code> 查看，果然发现 <code>146</code> 行的宏定义，如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/macro-defined-in-utils-h.png" alt="macro-defined-in-utils-h"></p><p>根据此处的逻辑可知，应该是 <code>126</code> 行的宏（<code>HAS_ADDRESS_SANITIZER</code>）没定义，导致了这个错误。而 <code>126</code> 行用到的宏又是由 <code>91~107</code> 行的宏定义决定的。如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/macro-HAS_ADDRESS_SANITIZER-definition.png" alt="macro-HAS_ADDRESS_SANITIZER-definition"></p><p>显然是没定义 <code>__SANITIZE_ADDRESS__</code> 宏导致的。知道原因了，简单粗暴的加上一句 <code>#define __SANITIZE_ADDRESS__</code>，再次编译，果然顺利通过了。</p><p>至于为什么编译失败，我就不关心了。因为我有更感兴趣的事情要处理 —— 查看 <code>gc</code> 相关的逻辑。本篇总结就水到这里啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>遇到奇怪的编译错误不要慌，秘密武器就是输出到中间文件，查看编译器眼中的文件到底长什么样</li><li>一定要有自己顺手的一套工具，搜索文件内容强烈推荐 <code>FileLocator</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在编译 &lt;code&gt;.NET Runtime&lt;/code&gt; 源码研究 &lt;code&gt;GC&lt;/code&gt; 机制时，我遇到了一个离奇的编译错误：函数 &lt;code&gt;__asan_handle_no_return&lt;/code&gt; 的声明被编译器报错为”类函数宏的调用”。通过将源文件预处理输出到中间文件，我发现这个函数声明竟然变成了 &lt;code&gt;void ;&lt;/code&gt;——它被”吃掉”了！追踪发现，在 &lt;code&gt;utils.h&lt;/code&gt; 中定义了一个同名宏，当 &lt;code&gt;__SANITIZE_ADDRESS__&lt;/code&gt; 宏未定义时，该宏被展开为空，导致函数声明被意外删除。这个案例再次证明：&lt;strong&gt;宏命名冲突是编译错误的常见陷阱&lt;/strong&gt;，而&lt;strong&gt;预处理输出文件&lt;/strong&gt;是诊断这类问题的利器。同时，&lt;code&gt;FileLocator&lt;/code&gt; 这类文件搜索工具在源码分析中不可或缺。&lt;/p&gt;
    
    </summary>
    
      <category term="排错" scheme="https://bianchengnan.github.io/categories/%E6%8E%92%E9%94%99/"/>
    
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="排错" scheme="https://bianchengnan.github.io/tags/%E6%8E%92%E9%94%99/"/>
    
      <category term="troubleshoot" scheme="https://bianchengnan.github.io/tags/troubleshoot/"/>
    
      <category term="编译" scheme="https://bianchengnan.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="宏" scheme="https://bianchengnan.github.io/tags/%E5%AE%8F/"/>
    
      <category term="compile" scheme="https://bianchengnan.github.io/tags/compile/"/>
    
  </entry>
  
  <entry>
    <title>深入.NET Runtime：一次 OOM 异常的分析与源码追踪之旅</title>
    <link href="https://bianchengnan.github.io//articles/analyze-oom-and-dive-into-dotnet-source/"/>
    <id>https://bianchengnan.github.io//articles/analyze-oom-and-dive-into-dotnet-source/</id>
    <published>2025-11-29T12:42:23.000Z</published>
    <updated>2025-12-13T05:48:33.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录了一次对 <code>.NET</code> 应用程序发生的“内存不足”（<code>OOM</code>）异常进行的深度源码级调查。问题始于一个看似矛盾的现象：诊断工具显示有足够大的空闲内存块（约 <code>50MB</code>），但垃圾回收（<code>GC</code>）过程却在尝试预留较小内存段（约 <code>16MB</code>）时失败。</p><p>为了探究根源，笔者<strong>逆向追踪了诊断工具（如SOS）输出的数据链路</strong>：从高层诊断命令（<code>AnalyzeOOMCommand</code>）入手，逐步深入<code>Microsoft.Diagnostics.Runtime (CLRMD)</code>库、托管辅助类、<code>Dac</code> 接口，最终直达 <code>.NET Runtime(CoreCLR)</code> 底层的 <code>GC</code> 相关 <code>Native</code> 代码（如 <code>ClrDataAccess</code>、<code>gc_heap</code>）。</p><p>虽然最终并没能定位问题的真实原因，但是理清了 <code>GC</code> 在 <code>virtual_alloc</code>过程中因<strong>内存限制检查、地址空间布局考量等因素</strong>导致预留失败的具体逻辑，并对 <code>.NET</code> 源码有了一定的认识，还是非常值得记录分享的。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前些日子，在 <code>.NET</code> 调试群里有位网友的 <code>.NET</code> 程序触发了 <code>OOM (Out Of Memory)</code> 异常，他在群里发了一些截图，询问大家是什么原因导致的。其中一张分析结果图如下：</p><p><img src="http://resources.bianchengnan.tech/analyze-oom-and-dive-into-dotnet-source/oom.png" alt="oom"></p><p>看着是 <code>gc</code> 过程中发生了内存不足的问题。大概率是要分配 <code>16MB</code> 左右的内存空间时失败了，但是另外一张截图显示，最大空闲块还有 <code>50MB</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/analyze-oom-and-dive-into-dotnet-source/address-summary.png" alt="address-summary"></p><p>由于没看过 <code>.net</code> 源码，只能根据自己的认知进行了回复，这种心里没底的感觉很不爽。正好最近想多研究下 <code>.net</code>，而且有源代码可查，为啥不看看呢？</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>可以通过 <code>git clone https://github.com/dotnet/runtime.git</code> 命令把 <code>.NET runtime</code> 源码克隆到本地。还可以下载对应的诊断工具源码，包括但不限于 <code>SOS</code>。可以通过 <code>git clone https://github.com/dotnet/diagnostics.git</code> 克隆到本地。</p><blockquote><p><strong>说明：</strong> 最开始的想法是编译一份进行调试，折腾了半天，还遇到一些编译错误，这里就不展开了，后面会有一篇文章单独总结。</p><p>下载的版本与我我本地的运行时版本（<code>8.0.7</code>）不匹配，切换到对应的版本（<code>git tag --list</code> 然后 <code>git checkout v8.0.7</code> ）。</p></blockquote><p>如何开始呢？截图中的关键信息描述就是入手点，当然从搜索入手了。</p><h2 id="追踪-OOM-来源"><a href="#追踪-OOM-来源" class="headerlink" title="追踪 OOM 来源"></a>追踪 OOM 来源</h2><p>打开文件内容搜索神器 <code>FileLocator</code>，搜索 <code>Failed to reserve memory</code>，在 <code>AnalyzeOOMCommand.cs</code> 中发现了匹配项。 </p><p><img src="http://resources.bianchengnan.tech/analyze-oom-and-dive-into-dotnet-source/search-keyword.png" alt="search-keyword"></p><p>关键类摘录如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnalyzeOOMCommand</span> : <span class="title">ClrRuntimeCommandBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">bool</span> foundOne = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (ClrOutOfMemoryInfo oom <span class="keyword">in</span> Runtime.Heap.SubHeaps.Select(h =&gt; h.OomInfo).Where(oom =&gt; oom != <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            foundOne = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(oom.Reason <span class="keyword">switch</span></span><br><span class="line">            &#123;</span><br><span class="line">                OutOfMemoryReason.Budget or OutOfMemoryReason.CantReserve =&gt; <span class="string">"OOM was due to an internal .Net error, likely a bug in the GC"</span>,</span><br><span class="line">                OutOfMemoryReason.CantCommit =&gt; <span class="string">"Didn't have enough memory to commit"</span>,</span><br><span class="line">                OutOfMemoryReason.LOH =&gt; <span class="string">"Didn't have enough memory to allocate an LOH segment"</span>,</span><br><span class="line">                OutOfMemoryReason.LowMem =&gt; <span class="string">"Low on memory during GC"</span>,</span><br><span class="line">                OutOfMemoryReason.UnproductiveFullGC =&gt; <span class="string">"Could not do a full GC"</span>,</span><br><span class="line">                _ =&gt; oom.Reason.ToString() <span class="comment">// shouldn't happen, we handle all cases above</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oom.GetMemoryFailure != GetMemoryFailureReason.None)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> message = oom.GetMemoryFailure <span class="keyword">switch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    GetMemoryFailureReason.ReserveSegment =&gt; <span class="string">"Failed to reserve memory"</span>,</span><br><span class="line">                    GetMemoryFailureReason.CommitSegmentBegin =&gt; <span class="string">"Didn't have enough memory to commit beginning of the segment"</span>,</span><br><span class="line">                    GetMemoryFailureReason.CommitEphemeralSegment =&gt; <span class="string">"Didn't have enough memory to commit the new ephemeral segment"</span>,</span><br><span class="line">                    GetMemoryFailureReason.GrowTable =&gt; <span class="string">"Didn't have enough memory to grow the internal GC data structures"</span>,</span><br><span class="line">                    GetMemoryFailureReason.CommitTable =&gt; <span class="string">"Didn't have enough memory to commit the internal GC data structures"</span>,</span><br><span class="line">                    _ =&gt; oom.GetMemoryFailure.ToString() <span class="comment">// shouldn't happen, we handle all cases above</span></span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(<span class="string">$"Details: <span class="subst">&#123;(oom.IsLargeObjectHeap ? <span class="string">"LOH"</span> : <span class="string">"SOH"</span>)&#125;</span> <span class="subst">&#123;message&#125;</span> <span class="subst">&#123;oom.Size:n0&#125;</span> bytes"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If it's a commit error (GetMemoryFailureReason.GrowTable can indicate a reserve</span></span><br><span class="line">                <span class="comment">// or a commit error since we make one VirtualAlloc call to reserve and commit),</span></span><br><span class="line">                <span class="comment">// we indicate the available commit space if we recorded it.</span></span><br><span class="line">                <span class="keyword">if</span> (oom.AvailablePageFileMB != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">$" - on GC entry available commit space was <span class="subst">&#123;oom.AvailablePageFileMB:n0&#125;</span> MB"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!foundOne)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"There was no managed OOM due to allocations on the GC heap"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看，与网友截图中的输出高度匹配，看样子是找对地方了。从代码逻辑可知，<code>AnalyzeOOMCommand</code> 命令会遍历堆，输出每个堆上的 <code>ClrOutOfMemoryInfo</code> 信息。关键代码如下：</p><p><code>foreach (ClrOutOfMemoryInfo oom in Runtime.Heap.SubHeaps.Select(h =&gt; h.OomInfo).Where(oom =&gt; oom != null))</code></p><p>至此可推断，发生 <code>OOM</code> 异常时，<code>runtime</code> 会把相关信息保存到堆上。<code>SOS</code> 等插件直接从对上取出对应信息，展示出来即可。看完这个类的实现，感觉我又行了，也能写一个类似的插件了，哈哈哈。不废话了，回到正题。单击 <code>h.OomInfo</code> 跳转到 <code>OomInfo</code> 的实现，可以发现其是类 <code>ClrSubHeap</code> 的一个属性字段。</p><blockquote><p><strong>说明：</strong><code>ClrSubHeap</code> 并没有实现在 <code>diagnostics</code> 工程中，而是实现在 <code>Microsoft.Diagnostics.Runtime</code> 中，可以通过 <code>git clone https://github.com/microsoft/clrmd.git</code> 下载。</p></blockquote><p>打开 <code>Microsoft.Diagnostics.Runtime.sln</code>，可以搜到 <code>OomInfo</code> 的实现，如下：</p><p><code>public ClrOutOfMemoryInfo? OomInfo =&gt; Heap.Helpers.GetOOMInfo(Address, out OomInfo oomInfo) ? new(oomInfo) : null;</code></p><p><code>OomInfo</code> 来自 <code>Heap.Helpers.GetOOMInfo()</code> 函数。而 <code>Heap</code> 是 <code>ClrSubHeap</code> 的一个字段，在 <code>ClrSubHeap</code> 构造的时候传进来。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClrSubHeap</span> : <span class="title">IClrSubHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrSubHeap</span>(<span class="params">ClrHeap clrHeap, <span class="keyword">in</span> SubHeapInfo subHeap</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Heap = clrHeap;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClrHeap Heap &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    IClrHeap IClrSubHeap.Heap =&gt; Heap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转到 <code>ClrHeap</code> 的实现看下 <code>Helpers</code> 的来源</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrHeap</span> : <span class="title">IClrHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrHeap</span>(<span class="params">ClrRuntime runtime, IMemoryReader memoryReader, IAbstractHeapProvider helpers, IAbstractTypeProvider typeHelpers, <span class="keyword">in</span> GCState gcInfo</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Runtime = runtime;</span><br><span class="line">        _memoryReader = memoryReader;</span><br><span class="line">        Helpers = helpers; <span class="comment">//&lt;----</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        SubHeaps = Helpers.EnumerateSubHeaps().Select(r =&gt; <span class="keyword">new</span> ClrSubHeap(<span class="keyword">this</span>, r)).ToImmutableArray();</span><br><span class="line">        Segments = SubHeaps.SelectMany(r =&gt; r.Segments).OrderBy(r =&gt; r.FirstObjectAddress).ToImmutableArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> IAbstractHeap Helpers &#123; <span class="keyword">get</span>; &#125; <span class="comment">//&lt;---</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClrRuntime Runtime &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 <code>Helpers</code> 是在 <code>ClrHeap</code> 构造的时候通过参数传进来的，而且 <code>SubHeaps</code> 也会在 <code>ClrHeap</code> 构造的时候被创建出来。</p><p>再看下 <code>ClrHeap</code> 是怎么被构造出来的。在 <code>ClrHeap</code> 的构造函数上方点击引用数量，跳转到对应的位置。可以发现其来自 <code>ClrRuntime</code> 的 <code>Heap</code> 属性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrRuntime</span> : <span class="title">IClrRuntime</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClrHeap Heap</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            ClrHeap? heap = _heap;</span><br><span class="line">            <span class="keyword">while</span> (heap <span class="keyword">is</span> <span class="literal">null</span>) <span class="comment">// Flush can cause a race.</span></span><br><span class="line">            &#123;</span><br><span class="line">                IAbstractHeap? heapHelpers = GetService&lt;IAbstractHeap&gt;(); <span class="comment">//&lt;---</span></span><br><span class="line">                IAbstractTypeHelpers? typeHelpers = GetService&lt;IAbstractTypeHelpers&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// These are defined as non-nullable but just in case, double check we have a non-null instance.</span></span><br><span class="line">                <span class="keyword">if</span> (heapHelpers <span class="keyword">is</span> <span class="literal">null</span> || typeHelpers <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException(<span class="string">"Unable to create a ClrHeap for this runtime."</span>);</span><br><span class="line"></span><br><span class="line">                heap = <span class="keyword">new</span>(<span class="keyword">this</span>, DataTarget.DataReader, heapHelpers, typeHelpers);</span><br><span class="line">                Interlocked.CompareExchange(<span class="keyword">ref</span> _heap, heap, <span class="literal">null</span>);</span><br><span class="line">                heap = _heap;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> heap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 <code>heapHelpers</code> 参数来自 <code>IAbstractHeap? heapHelpers = GetService&lt;IAbstractHeap&gt;();</code></p><p>跳转到 <code>GetService()</code> 的实现，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> T? GetService&lt;T&gt;() <span class="keyword">where</span> T: <span class="keyword">class</span> =&gt; (T?)_services.GetService(<span class="keyword">typeof</span>(T));</span><br></pre></td></tr></table></figure><p>可以发现，<code>GetService&lt;T&gt;()</code> 是通过 <code>_services.GetService(typeof(T))</code> 实现的，再看下 <code>_services</code> 的来源。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrRuntime</span> : <span class="title">IClrRuntime</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _services;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ClrHeap? _heap;</span><br><span class="line">    <span class="keyword">private</span> ImmutableArray&lt;ClrThread&gt; _threads;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> DomainAndModules? _domainAndModules;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAbstractRuntime? _runtime;</span><br><span class="line">    <span class="keyword">private</span> IAbstractComHelpers? _comHelpers;</span><br><span class="line">    <span class="keyword">private</span> IAbstractMethodLocator? _methodLocator;</span><br><span class="line">    <span class="keyword">private</span> IAbstractDacController? _controller;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrRuntime</span>(<span class="params">ClrInfo clrInfo, IServiceProvider services</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ClrInfo = clrInfo;</span><br><span class="line">        DataTarget = clrInfo.DataTarget;</span><br><span class="line">        _services = services; <span class="comment">//&lt;---</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 <code>_services</code> 是在 <code>ClrRuntime</code> 构造的时候传进来的。点击 <code>ClrRuntime</code> 的构造函数上方的引用计数，可以发现  <code>ClrRuntime</code>  在<code>ClrInfo</code> 的 <code>CreateRuntimeWorker()</code> 函数中被创建，<code>services</code> 参数来自 <code>ClrInfoProvider.GetDacServices()</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrInfo</span> : <span class="title">IClrInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ClrRuntime <span class="title">CreateRuntimeWorker</span>(<span class="params"><span class="keyword">string</span>? dacPath, <span class="keyword">bool</span> ignoreMismatch, <span class="keyword">bool</span> verifySignature</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        IServiceProvider services = ClrInfoProvider.GetDacServices(<span class="keyword">this</span>, dacPath, ignoreMismatch, verifySignature);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClrRuntime(<span class="keyword">this</span>, services);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下 <code>ClrInfoProvider</code> 的来源，发现其是 <code>ClrInfo</code> 的属性成员，在 <code>ClrInfo</code> 构造的时候被初始化。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrInfo</span> : <span class="title">IClrInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrInfo</span>(<span class="params">DataTarget dt, ModuleInfo module, Version clrVersion, IClrInfoProvider provider</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DataTarget = dt ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(dt));</span><br><span class="line">        ModuleInfo = module ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(module));</span><br><span class="line">        ClrInfoProvider = provider ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(provider)); <span class="comment">//&lt;---</span></span><br><span class="line">        Version = clrVersion ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(clrVersion));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The DataTarget containing this ClrInfo.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> DataTarget DataTarget &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The IClrInfoProvider which created this ClrInfo.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> IClrInfoProvider ClrInfoProvider &#123; <span class="keyword">get</span>; &#125; <span class="comment">//&lt;---</span></span><br><span class="line"></span><br><span class="line">    IDataTarget IClrInfo.DataTarget =&gt; DataTarget;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看 <code>ClrInfo</code> 是在哪里被创建的，点击 <code>ClrInfo</code> 的构造函数上方的引用计数，可以发现其来自 <code>DotNetClrInfoProvider</code> 的 <code>CreateClrInfo()</code> 函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DotNetClrInfoProvider</span> : <span class="title">IClrInfoProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClrInfo <span class="title">CreateClrInfo</span>(<span class="params">DataTarget dataTarget, ModuleInfo module, <span class="keyword">ulong</span> runtimeInfo, ClrFlavor flavor</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        ClrInfo result = <span class="keyword">new</span>(dataTarget, module, version, <span class="keyword">this</span>) <span class="comment">//&lt;---</span></span><br><span class="line">        &#123;</span><br><span class="line">            Flavor = flavor,</span><br><span class="line">            DebuggingLibraries = orderedDebugLibraries.ToImmutableArray(),</span><br><span class="line">            ContractDescriptorAddress = contractDescriptor,</span><br><span class="line">            IndexFileSize = indexFileSize,</span><br><span class="line">            IndexTimeStamp = indexTimeStamp,</span><br><span class="line">            BuildId = buildId,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知，<code>ClrInfo</code> 构造函数的最后一个参数是 <code>this</code>，所以 <code>ClrInfo</code> 中的 <code>ClrInfoProvider</code> 是 <code>DotNetClrInfoProvider</code> 类型的对象。再来查看一下 <code>DotNetClrInfoProvider::GetDacServices()</code> 函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IServiceProvider <span class="title">GetDacServices</span>(<span class="params">ClrInfo clrInfo, <span class="keyword">string</span>? providedPath, <span class="keyword">bool</span> ignoreMismatch, <span class="keyword">bool</span> verifySignature</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DacLibrary library = GetDacLibraryFromPath(clrInfo, providedPath, ignoreMismatch, verifySignature);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DacServiceProvider(clrInfo, library);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会返回 <code>DacServiceProvider</code> 类型的对象，所以 <code>ClrRuntime._services</code> 实际是 <code>DacServiceProvider</code> 类型的对象。<code>ClrRuntime</code> 的 <code>Heap</code> 属性中调用的 <code>IAbstractHeap? heapHelpers = GetService&lt;IAbstractHeap&gt;()</code> 就相当于调用的是 <code>DacServiceProvider.GetService(IAbstractHeap)</code>。</p><p>看看 <code>DacServiceProvider.GetService(Type)</code> 的实现，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DacServiceProvider</span> : <span class="title">IServiceProvider</span>, <span class="title">IDisposable</span>, <span class="title">IAbstractDacController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span>? GetService(Type serviceType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (serviceType == <span class="keyword">typeof</span>(IAbstractRuntime))</span><br><span class="line">            <span class="keyword">return</span> _runtime ??= <span class="keyword">new</span> DacRuntime(_clrInfo, _process, _sos, _sos13);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serviceType == <span class="keyword">typeof</span>(IAbstractHeap)) <span class="comment">//&lt;---</span></span><br><span class="line">        &#123;</span><br><span class="line">            IAbstractHeap? heap = _heapHelper;</span><br><span class="line">            <span class="keyword">if</span> (heap <span class="keyword">is</span> not <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> heap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_sos.GetGCHeapData(<span class="keyword">out</span> GCInfo data) &amp;&amp; _sos.GetCommonMethodTables(<span class="keyword">out</span> CommonMethodTables mts) &amp;&amp; mts.ObjectMethodTable != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> _heapHelper = <span class="keyword">new</span> DacHeap(_sos, _sos8, _sos12, _sos16, _dataReader, data, mts);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>ClrHeap</code> 中的 <code>Helpers</code> 成员的类型是 <code>DacHeap</code>，看看其 <code>GetOOMInfo()</code> 的实现。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DacHeap</span> : <span class="title">IAbstractHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">GetOOMInfo</span>(<span class="params"><span class="keyword">ulong</span> subHeapAddress, <span class="keyword">out</span> OomInfo oomInfo</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DacOOMData oomData;</span><br><span class="line">        <span class="keyword">if</span> (subHeapAddress != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_sos.GetOOMData(subHeapAddress, <span class="keyword">out</span> oomData) || oomData.Reason == OutOfMemoryReason.None &amp;&amp; oomData.GetMemoryFailure == GetMemoryFailureReason.None)</span><br><span class="line">            &#123;</span><br><span class="line">                oomInfo = <span class="keyword">default</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_sos.GetOOMData(<span class="keyword">out</span> oomData) || oomData.Reason == OutOfMemoryReason.None &amp;&amp; oomData.GetMemoryFailure == GetMemoryFailureReason.None)</span><br><span class="line">            &#123;</span><br><span class="line">                oomInfo = <span class="keyword">default</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oomInfo = <span class="keyword">new</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            AllocSize = oomData.AllocSize,</span><br><span class="line">            AvailablePageFileMB = oomData.AvailablePageFileMB,</span><br><span class="line">            GCIndex = oomData.GCIndex,</span><br><span class="line">            GetMemoryFailure = oomData.GetMemoryFailure,</span><br><span class="line">            IsLOH = oomData.IsLOH != <span class="number">0</span>,</span><br><span class="line">            Reason = oomData.Reason,</span><br><span class="line">            Size = oomData.Size,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了 <code>_sos.GetOOMData(out oomData)</code>。<code>_sos</code> 是 <code>DacHeap</code> 的成员变量，来自 <code>DacHeap</code> 构造函数的第一个参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DacHeap</span> : <span class="title">IAbstractHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac _sos; <span class="comment">//&lt;--</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac8? _sos8;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DacHeap</span>(<span class="params">SOSDac sos, SOSDac8? sos8, SosDac12? sos12, ISOSDac16? sos16, IMemoryReader reader, <span class="keyword">in</span> GCInfo gcInfo, <span class="keyword">in</span> CommonMethodTables commonMethodTables</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _sos = sos; <span class="comment">//&lt;--</span></span><br><span class="line">        _sos8 = sos8;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>DacHeap</code> 又是在 <code>DacServiceProvider.GetService(Type)</code> 中创建的，关键代码是</p><p><code>return _heapHelper = new DacHeap(_sos, _sos8, _sos12, _sos16, _dataReader, data, mts);</code></p><p>传递给 <code>DacHeap</code> 的第一个参数是 <code>DacServiceProvider</code> 的成员变量 <code>_sos</code>。该成员变量是在 <code>DacServiceProvider</code> 的构造函数中初始化的。构造函数如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DacServiceProvider</span> : <span class="title">IServiceProvider</span>, <span class="title">IDisposable</span>, <span class="title">IAbstractDacController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ClrInfo _clrInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IDataReader _dataReader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DacLibrary _dac;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ClrDataProcess _process;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac _sos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac6? _sos6;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DacServiceProvider</span>(<span class="params">ClrInfo clrInfo, DacLibrary library</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _clrInfo = clrInfo;</span><br><span class="line">        _dataReader = _clrInfo.DataTarget.DataReader;</span><br><span class="line"></span><br><span class="line">        _dac = library;</span><br><span class="line">        _process = library.CreateClrDataProcess();</span><br><span class="line">        _sos = _process.CreateSOSDacInterface() ?? <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">$"Could not create ISOSDacInterface."</span>); <span class="comment">//&lt;--</span></span><br><span class="line">        _sos6 = _process.CreateSOSDacInterface6();</span><br><span class="line"></span><br><span class="line">        library.DacDataTarget.SetMagicCallback(_process.Flush);</span><br><span class="line">        IsThreadSafe = _sos13 <span class="keyword">is</span> not <span class="literal">null</span> || RuntimeInformation.IsOSPlatform(OSPlatform.Windows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_sos</code> 是由 <code>_process.CreateSOSDacInterface()</code> 创建的，而 <code>_process</code> 的类型是 <code>ClrDataProcess</code>，看一下 <code>_process.CreateSOSDacInterface()</code> 的实现，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">ClrDataProcess</span> : <span class="title">CallableCOMWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Guid IID_IXCLRDataProcess = <span class="keyword">new</span>(<span class="string">"5c552ab6-fc09-4cb3-8e36-22fa03c798b7"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DacLibrary _library;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SOSDac? CreateSOSDacInterface()</span><br><span class="line">    &#123;</span><br><span class="line">        IntPtr result = QueryInterface(SOSDac.IID_ISOSDac);</span><br><span class="line">        <span class="keyword">if</span> (result == IntPtr.Zero)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SOSDac(_library, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvalidOperationException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数会返回 <code>SOSDac</code> 类型的对象，该类型构造函数的第二个参数是通过 <code>QueryInterface(SOSDac.IID_ISOSDac)</code> 得到的，<code>SOSDac.IID_ISOSDac</code> 的值是 <code>436f00f2-b42a-4b9f-870c-e73db66ae930</code>，是 <code>SOSDac</code> 类的静态变量，<code>SOSDac</code> 的定义如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">SOSDac</span> : <span class="title">CallableCOMWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Guid IID_ISOSDac = <span class="keyword">new</span>(<span class="string">"436f00f2-b42a-4b9f-870c-e73db66ae930"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DacLibrary _library;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt;? _regNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Dictionary&lt;<span class="keyword">ulong</span>, <span class="keyword">string</span>&gt;? _frameNames;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SOSDac</span>(<span class="params">DacLibrary? library, IntPtr ptr</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">library?.OwningLibrary, IID_ISOSDac, ptr</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _library = library ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(library));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">ref</span> <span class="keyword">readonly</span> ISOSDacVTable VTable =&gt; <span class="keyword">ref</span> Unsafe.AsRef&lt;ISOSDacVTable&gt;(_vtable);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SOSDac</span>(<span class="params">DacLibrary lib, CallableCOMWrapper toClone</span>) : <span class="title">base</span>(<span class="params">toClone</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _library = lib;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HResult <span class="title">GetOOMData</span>(<span class="params"><span class="keyword">out</span> DacOOMData oomData</span>)</span> =&gt; VTable.GetOOMStaticData(Self, <span class="keyword">out</span> oomData);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HResult <span class="title">GetOOMData</span>(<span class="params"><span class="keyword">ulong</span> address, <span class="keyword">out</span> DacOOMData oomData</span>)</span> =&gt; VTable.GetOOMData(Self, address, <span class="keyword">out</span> oomData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类什么有用的事情都没做，都是调用 <code>VTable</code> 中的实现，而且其基类是 <code>CallableCOMWrapper</code>，可以大胆猜测此类是一个 <code>COM</code> 调用类，真正的实现在 <code>native</code> 层。是不是呢？到 <code>native</code> 层搜搜就知道了。</p><h2 id="查看-clr-runtime-实现"><a href="#查看-clr-runtime-实现" class="headerlink" title="查看 clr runtime 实现"></a>查看 clr runtime 实现</h2><p>在  <code>native</code> 代码中搜索 <code>436f00f2-b42a-4b9f-870c-e73db66ae930</code>，可以在 <code>sospriv.h</code> 头文件中搜到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MIDL_INTERFACE(<span class="string">"436f00f2-b42a-4b9f-870c-e73db66ae930"</span>) <span class="comment">//&lt;---</span></span><br><span class="line">ISOSDacInterface : <span class="keyword">public</span> IUnknown</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">GetOOMData</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">        CLRDATA_ADDRESS oomAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct DacpOomData *data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">GetOOMStaticData</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">        struct DacpOomData *data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继续搜索 <code>ISOSDacInterface</code>，可以在 <code>daccess.cpp</code> 中找到使用的地方，对应的实现类是 <code>ClrDataAccess</code>。</p><blockquote><p><strong>说明：</strong> 对应的声明文件在 <code>D:\dotnet\runtime\src\coreclr\debug\daccess\dacimpl.h</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\debug\daccess\daccess.cpp</span></span><br><span class="line"></span><br><span class="line">STDMETHODIMP</span><br><span class="line">ClrDataAccess::QueryInterface(THIS_</span><br><span class="line">                              IN REFIID interfaceId,</span><br><span class="line">                              OUT PVOID* iface)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* ifaceRet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsEqualIID(interfaceId, IID_IUnknown) ||</span><br><span class="line">        IsEqualIID(interfaceId, __uuidof(IXCLRDataProcess)) ||</span><br><span class="line">        IsEqualIID(interfaceId, __uuidof(IXCLRDataProcess2)))</span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;IXCLRDataProcess2*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsEqualIID(interfaceId, __uuidof(ICLRDataEnumMemoryRegions)))</span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;ICLRDataEnumMemoryRegions*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsEqualIID(interfaceId, __uuidof(ISOSDacInterface))) <span class="comment">//&lt;---</span></span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;ISOSDacInterface*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsEqualIID(interfaceId, __uuidof(ISOSDacInterface2)))</span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;ISOSDacInterface2*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    AddRef();</span><br><span class="line">    *iface = ifaceRet;</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以查看 <code>ClrDataAccess::GetOOMData()</code> 的具体实现，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\debug\daccess\request.cpp</span></span><br><span class="line"></span><br><span class="line">HRESULT</span><br><span class="line">ClrDataAccess::GetOOMData(CLRDATA_ADDRESS oomAddr, struct DacpOomData *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (oomAddr == <span class="number">0</span> || data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> E_INVALIDARG;</span><br><span class="line"></span><br><span class="line">    SOSDacEnter();</span><br><span class="line">    *data = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!GCHeapUtilities::IsServerHeap())</span><br><span class="line">        hr = E_FAIL; <span class="comment">// doesn't make sense to call this on WKS mode</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FEATURE_SVR_GC</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hr = ServerOomData(oomAddr, data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _ASSERTE_MSG(<span class="literal">false</span>, <span class="string">"IsServerHeap returned true but FEATURE_SVR_GC not defined"</span>);</span><br><span class="line">    hr = E_NOTIMPL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//FEATURE_SVR_GC</span></span></span><br><span class="line"></span><br><span class="line">    SOSDacLeave();</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClrDataAccess::ServerOomData()</code> 的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\debug\daccess\request_svr.cpp</span></span><br><span class="line">    </span><br><span class="line">HRESULT</span><br><span class="line">ClrDataAccess::ServerOomData(CLRDATA_ADDRESS addr, DacpOomData *oomData)</span><br><span class="line">&#123;</span><br><span class="line">    TADDR heapAddress = TO_TADDR(addr);</span><br><span class="line">    dac_gc_heap heap = LoadGcHeapData(heapAddress);</span><br><span class="line">    dac_gc_heap* pHeap = &amp;heap;</span><br><span class="line"></span><br><span class="line">    oom_history pOOMInfo = pHeap-&gt;oom_info;</span><br><span class="line">    oomData-&gt;reason = pOOMInfo.reason;</span><br><span class="line">    oomData-&gt;alloc_size = pOOMInfo.alloc_size;</span><br><span class="line">    oomData-&gt;available_pagefile_mb = pOOMInfo.available_pagefile_mb;</span><br><span class="line">    oomData-&gt;gc_index = pOOMInfo.gc_index;</span><br><span class="line">    oomData-&gt;fgm = pOOMInfo.fgm;</span><br><span class="line">    oomData-&gt;size = pOOMInfo.size;</span><br><span class="line">    oomData-&gt;loh_p = pOOMInfo.loh_p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知，<code>oomData</code> 来自 <code>pHeap-&gt;oom_info</code>，看下 <code>oom_info</code> 的定义，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\gc\gcpriv.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gc_heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    PER_HEAP_FIELD_DIAG_ONLY oom_history oom_info;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其类型是 <code>oom_history</code>，查看定义，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\gc\gcinterface.dac.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reasons why an OOM might occur, recorded in the oom_history</span></span><br><span class="line"><span class="comment">// struct below.</span></span><br><span class="line"><span class="keyword">enum</span> oom_reason</span><br><span class="line">&#123;</span><br><span class="line">    oom_no_failure = <span class="number">0</span>,</span><br><span class="line">    oom_budget = <span class="number">1</span>,</span><br><span class="line">    oom_cant_commit = <span class="number">2</span>,</span><br><span class="line">    oom_cant_reserve = <span class="number">3</span>,</span><br><span class="line">    oom_loh = <span class="number">4</span>,</span><br><span class="line">    oom_low_mem = <span class="number">5</span>,</span><br><span class="line">    oom_unproductive_full_gc = <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/</span></span><br><span class="line"><span class="comment">/* If you modify failure_get_memory and         */</span></span><br><span class="line"><span class="comment">/* oom_reason be sure to make the corresponding */</span></span><br><span class="line"><span class="comment">/* changes in ClrMD.                            */</span></span><br><span class="line"><span class="comment">/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/</span></span><br><span class="line"><span class="keyword">enum</span> failure_get_memory</span><br><span class="line">&#123;</span><br><span class="line">    fgm_no_failure = <span class="number">0</span>,</span><br><span class="line">    fgm_reserve_segment = <span class="number">1</span>,</span><br><span class="line">    fgm_commit_segment_beg = <span class="number">2</span>,</span><br><span class="line">    fgm_commit_eph_segment = <span class="number">3</span>,</span><br><span class="line">    fgm_grow_table = <span class="number">4</span>,</span><br><span class="line">    fgm_commit_table = <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A record of the last OOM that occurred in the GC, with some</span></span><br><span class="line"><span class="comment">// additional information as to what triggered the OOM.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oom_history</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    oom_reason reason;</span><br><span class="line">    <span class="keyword">size_t</span> alloc_size;</span><br><span class="line">    <span class="keyword">uint8_t</span>* reserved;</span><br><span class="line">    <span class="keyword">uint8_t</span>* allocated;</span><br><span class="line">    <span class="keyword">size_t</span> gc_index;</span><br><span class="line">    failure_get_memory fgm;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">size_t</span> available_pagefile_mb;</span><br><span class="line">    BOOL loh_p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到以上定义就太亲切了。根据目前了解到的信息，这个结构体应该是当发生 <code>OOM</code> 时，<code>runtime</code> 设置的结构体。可以在代码中搜索使用 <code>fgm_reserve_segment</code> 的地方，一共就搜到两处，一处是其定义的地方，一处是使用的地方，使用的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">heap_segment*</span><br><span class="line">gc_heap::get_segment (<span class="keyword">size_t</span> size, gc_oh_num oh)</span><br><span class="line">&#123;</span><br><span class="line">    assert(oh != gc_oh_num::unknown);</span><br><span class="line">    BOOL uoh_p = (oh == gc_oh_num::loh) || (oh == gc_oh_num::poh);</span><br><span class="line">    <span class="keyword">if</span> (heap_hard_limit)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    heap_segment* result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (segment_standby_list != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = segment_standby_list;</span><br><span class="line">        heap_segment* last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (result)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> hs = (<span class="keyword">size_t</span>)(heap_segment_reserved (result) - (<span class="keyword">uint8_t</span>*)result);</span><br><span class="line">            <span class="keyword">if</span> ((hs &gt;= size) &amp;&amp; ((hs / <span class="number">2</span>) &lt; size))</span><br><span class="line">            &#123;</span><br><span class="line">                dprintf (<span class="number">2</span>, (<span class="string">"Hoarded segment %zx found"</span>, (<span class="keyword">size_t</span>) result));</span><br><span class="line">                <span class="keyword">if</span> (last)</span><br><span class="line">                &#123;</span><br><span class="line">                    heap_segment_next (last) = heap_segment_next (result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    segment_standby_list = heap_segment_next (result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last = result;</span><br><span class="line">                result = heap_segment_next (result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span>* mem = virtual_alloc (size);</span><br><span class="line">        <span class="keyword">if</span> (!mem)</span><br><span class="line">        &#123;</span><br><span class="line">            fgm_result.set_fgm (fgm_reserve_segment, size, uoh_p); <span class="comment">//&lt;---</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，当 <code>virtual_alloc (size)</code> 的返回值是空时，会设置 <code>fgm_reserve_segment</code>。再看看 <code>virtual_alloc</code> 的实现，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">virtual_alloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> virtual_alloc(size, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">virtual_alloc</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">bool</span> use_large_pages_p, <span class="keyword">uint16_t</span> numa_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> requested_size = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">    &#123;</span><br><span class="line">        gc_heap::reserved_memory_limit =</span><br><span class="line">            GCScan::AskForMoreReservedMemory (gc_heap::reserved_memory_limit, requested_size);</span><br><span class="line">        <span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//&lt;---</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = VirtualReserveFlags::None;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP</span></span><br><span class="line">    <span class="keyword">if</span> (virtual_alloc_hardware_write_watch)</span><br><span class="line">    &#123;</span><br><span class="line">        flags = VirtualReserveFlags::WriteWatch;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;--- use_large_pages_p 是 false，会调用 GCToOSInterface::VirtualReserve</span></span><br><span class="line">    <span class="keyword">void</span>* prgmem = use_large_pages_p ?</span><br><span class="line">        GCToOSInterface::VirtualReserveAndCommitLargePages(requested_size, numa_node) :</span><br><span class="line">        GCToOSInterface::VirtualReserve(requested_size, card_size * card_word_width, flags, numa_node);</span><br><span class="line">    <span class="keyword">void</span> *aligned_mem = prgmem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want (prgmem + size) to be right at the end of the address space</span></span><br><span class="line">    <span class="comment">// because we'd have to worry about that everytime we do (address + size).</span></span><br><span class="line">    <span class="comment">// We also want to make sure that we leave loh_size_threshold at the end</span></span><br><span class="line">    <span class="comment">// so we allocate a small object we don't need to worry about overflow there</span></span><br><span class="line">    <span class="comment">// when we do alloc_ptr+size.</span></span><br><span class="line">    <span class="keyword">if</span> (prgmem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span>* end_mem = (<span class="keyword">uint8_t</span>*)prgmem + requested_size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((end_mem == <span class="number">0</span>) || ((<span class="keyword">size_t</span>)(MAX_PTR - end_mem) &lt;= END_SPACE_AFTER_GC))</span><br><span class="line">        &#123;</span><br><span class="line">            GCToOSInterface::VirtualRelease (prgmem, requested_size);</span><br><span class="line">            dprintf (<span class="number">2</span>, (<span class="string">"Virtual Alloc size %zd returned memory right against 4GB [%zx, %zx[ - discarding"</span>,</span><br><span class="line">                        requested_size, (<span class="keyword">size_t</span>)prgmem, (<span class="keyword">size_t</span>)((<span class="keyword">uint8_t</span>*)prgmem+requested_size)));</span><br><span class="line">            prgmem = <span class="number">0</span>;</span><br><span class="line">            aligned_mem = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prgmem)</span><br><span class="line">    &#123;</span><br><span class="line">        gc_heap::reserved_memory += requested_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dprintf (<span class="number">2</span>, (<span class="string">"Virtual Alloc size %zd: [%zx, %zx["</span>,</span><br><span class="line">                 requested_size, (<span class="keyword">size_t</span>)prgmem, (<span class="keyword">size_t</span>)((<span class="keyword">uint8_t</span>*)prgmem+requested_size)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aligned_mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，一共有三个地方会导致返回空，第一处代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">&#123;</span><br><span class="line">    gc_heap::reserved_memory_limit =</span><br><span class="line">        GCScan::AskForMoreReservedMemory (gc_heap::reserved_memory_limit, requested_size);</span><br><span class="line">    <span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//&lt;---</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概逻辑是，如果<strong>保留内存限值</strong>（<code>gc_heap::reserved_memory_limit</code>）- <strong>已保留的内存</strong>（<code>gc_heap::reserved_memory</code>）小于 <strong>请求字节数</strong>（<code>requested_size</code>），就调用 <code>GCScan::AskForMoreReservedMemory()</code> 请求保留更多内存，该函数会返回新的限值。如果 <strong>新限值</strong> - <strong>已保留的内存</strong> 还是小于 <strong>请求字节数</strong> 就返回空。</p><p>第二处代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* prgmem = use_large_pages_p ?</span><br><span class="line">        GCToOSInterface::VirtualReserveAndCommitLargePages(requested_size, numa_node) :</span><br><span class="line">        GCToOSInterface::VirtualReserve(requested_size, card_size * card_word_width, flags, numa_node);</span><br><span class="line">    <span class="keyword">void</span> *aligned_mem = prgmem;</span><br></pre></td></tr></table></figure><p>由于，<code>use_large_pages_p</code> 是 <code>false</code>，会调用 <code>GCToOSInterface::VirtualReserve()</code>，该函数底层又会直接调用 <code>VirtualAlloc()</code>。</p><p>第三处代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prgmem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span>* end_mem = (<span class="keyword">uint8_t</span>*)prgmem + requested_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((end_mem == <span class="number">0</span>) || ((<span class="keyword">size_t</span>)(MAX_PTR - end_mem) &lt;= END_SPACE_AFTER_GC))</span><br><span class="line">    &#123;</span><br><span class="line">        GCToOSInterface::VirtualRelease (prgmem, requested_size);</span><br><span class="line">        dprintf (<span class="number">2</span>, (<span class="string">"Virtual Alloc size %zd returned memory right against 4GB [%zx, %zx[ - discarding"</span>,</span><br><span class="line">                     requested_size, (<span class="keyword">size_t</span>)prgmem, (<span class="keyword">size_t</span>)((<span class="keyword">uint8_t</span>*)prgmem+requested_size)));</span><br><span class="line">        prgmem = <span class="number">0</span>;</span><br><span class="line">        aligned_mem = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MAX_PTR</code> 为最大的无符号整数，<code>end_mem</code> 是此次分配的内存段的结束位置，如果结束位置后面的空间不能容纳大对象堆，也返回空。</p><p>至此，本次折腾就告一段路了，第一张图片中的报错信息，基本上是 <code>virtual_alloc</code> 失败导致的问题。为什么 <code>virtual_alloc</code> 会失败，我到现在也没想明白。因为只尝试保留内存空间，并没有进行提交，按理说在有足够大的空闲内存空间时，不应该失败才对。什么情况下 <code>VirtualAlloc()</code> 会失败，还望各位大牛不吝赐教！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>再次强烈推荐一下 <code>FileLocator</code> 文件内容搜索神器，你值得拥有</li><li></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><code>.net</code> 源码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录了一次对 &lt;code&gt;.NET&lt;/code&gt; 应用程序发生的“内存不足”（&lt;code&gt;OOM&lt;/code&gt;）异常进行的深度源码级调查。问题始于一个看似矛盾的现象：诊断工具显示有足够大的空闲内存块（约 &lt;code&gt;50MB&lt;/code&gt;），但垃圾回收（&lt;code&gt;GC&lt;/code&gt;）过程却在尝试预留较小内存段（约 &lt;code&gt;16MB&lt;/code&gt;）时失败。&lt;/p&gt;
&lt;p&gt;为了探究根源，笔者&lt;strong&gt;逆向追踪了诊断工具（如SOS）输出的数据链路&lt;/strong&gt;：从高层诊断命令（&lt;code&gt;AnalyzeOOMCommand&lt;/code&gt;）入手，逐步深入&lt;code&gt;Microsoft.Diagnostics.Runtime (CLRMD)&lt;/code&gt;库、托管辅助类、&lt;code&gt;Dac&lt;/code&gt; 接口，最终直达 &lt;code&gt;.NET Runtime(CoreCLR)&lt;/code&gt; 底层的 &lt;code&gt;GC&lt;/code&gt; 相关 &lt;code&gt;Native&lt;/code&gt; 代码（如 &lt;code&gt;ClrDataAccess&lt;/code&gt;、&lt;code&gt;gc_heap&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;虽然最终并没能定位问题的真实原因，但是理清了 &lt;code&gt;GC&lt;/code&gt; 在 &lt;code&gt;virtual_alloc&lt;/code&gt;过程中因&lt;strong&gt;内存限制检查、地址空间布局考量等因素&lt;/strong&gt;导致预留失败的具体逻辑，并对 &lt;code&gt;.NET&lt;/code&gt; 源码有了一定的认识，还是非常值得记录分享的。&lt;/p&gt;
    
    </summary>
    
      <category term="NET" scheme="https://bianchengnan.github.io/categories/NET/"/>
    
    
      <category term="源码" scheme="https://bianchengnan.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term=".net" scheme="https://bianchengnan.github.io/tags/net/"/>
    
      <category term="OOM" scheme="https://bianchengnan.github.io/tags/OOM/"/>
    
      <category term="clr" scheme="https://bianchengnan.github.io/tags/clr/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 使用 GFlags 与 WinDbg 定位 VS2022 “重复释放” 引发的崩溃</title>
    <link href="https://bianchengnan.github.io//articles/debug-vs2022-double-free-crash-with-gflags-windbg/"/>
    <id>https://bianchengnan.github.io//articles/debug-vs2022-double-free-crash-with-gflags-windbg/</id>
    <published>2025-11-29T02:21:23.000Z</published>
    <updated>2025-12-13T05:48:33.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录了一次独特的调试经历：作为开发利器的 <code>Visual Studio 2022</code>，其在切换调用栈时频繁崩溃。面对这一问题，利用 <code>procdump</code> 自动捕获崩溃转储文件，并通过 <code>WinDbg</code> 初步排查将问题指向堆内存的异常操作，可能是堆损坏或重复释放。为了精准定位，我启用 <code>gflags</code> 工具开启页堆检测，最终成功捕获到首次释放操作的完整调用栈，明确问题根源在于<code>VSDebug!treegrid::CTreeGridItemContainerGenerator::Refresh</code>过程中的<strong>内存重复释放</strong>。虽然因缺少源码无法直接修复，但通过环境隔离（关闭特定程序）避免了问题复现。此次实战再次证明了 <code>procdump</code>、<code>gflags</code> 等工具在诊断复杂内存问题中的巨大价值，也提醒我们即使面对没有源码的“黑盒”组件，系统化的调试方法依然能指引我们找到问题的本质。</p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近，用 <code>vs2022</code> 在调试的时候，切换调用栈，会有很大概率崩溃。一次两次就忍了，不停的崩溃就有点说不过去了。 话不多说，先放张动图看看 <code>vs2022</code> 是怎么崩溃的。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/vs2022%E5%B4%A9%E6%BA%83.gif" alt="vs2022崩溃"></p><a id="more"></a><p>好在我已经设置了 <code>procdump</code> 为事后调试器，每当有进程崩溃的时候，都会在 <code>d:\dumps\</code> 目录下保存一份转储文件。下图是最近保存的一些转储文件（已经清理过几次了）。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/recent-dump-files.png" alt="recent-dump-files"></p><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>老规矩，使用 <code>windbg</code> 打开对应的转储文件，先无脑 <code>!analyze -v</code> 一波，没看到有用的信息。执行 <code>k</code> 命令查看调用栈，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/delete-exception.png" alt="delete-exception"></p><p>看到熟悉的 <code>delete</code> 基本就猜到是堆出问题了，或者是堆破坏或者是重复释放。如果能找到 <code>delete</code> 的地址，然后使用地址相关命令（比如， <code>!address</code> 或者 <code>!heap -x addr</code> 命令）应该是可以看到一些信息的。那么该如何找到这个地址呢？</p><h2 id="查找关键地址"><a href="#查找关键地址" class="headerlink" title="查找关键地址"></a>查找关键地址</h2><p><code>64</code> 位程序一般是 <code>__stdcall</code>，一般第一个参数是通过 <code>rcx</code> 传递的，但是寄存器的值随着调用其它函数是会改变的，除非保存到栈上过。为了查看传递给 <code>delete</code> 的参数，找到调用它的栈帧。找到栈帧 <code>10</code> （<code>VSDebug!operator delete+0x9</code>）对应的返回地址(<code>00007fff98f13082</code>)，使用 <code>ub</code> 查看对应的反汇编。查看是否有保存 <code>rcx</code> 的操作，没有的话，继续向调用方向找（当然也可以向被调用方向查找是否有保存 <code>rcx</code> 的操作）。直到找到栈帧 <code>12</code> 的返回值地址，</p><p><code>12 0000002899dad690 00007fff99103111     VSDebug!CClassFactory&lt;CRefCount&gt;::Release+0x27</code></p><p>使用 <code>ub 00007fff99103111 L28</code>（为什么 <code>L28</code>，因为好截图）</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/find-the-addres-being-deleted.png" alt="find-the-addres-being-deleted"></p><p>从图中可知，<code>rcx</code> 来自 <code>rbx</code>，而 <code>rbx</code> 的值被保存到当前栈帧（栈帧 <code>13</code>） <code>rsp+0x40</code> 的位置上过。</p><p>执行 <code>dq 0000002899dad6c0 + 0x40 L2</code> 然后执行 <code>!address 0000014185ce4360</code>，然后执行 <code>!heap -x 0x14185ce4360</code>，可以发现这个地址确实是 <code>free</code> 的。如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/verify-the-adress-has-been-deleted.png" alt="verify-the-adress-has-been-deleted"></p><p>虽然这里的值不是 <code>100%</code> 靠谱，但是也能在一定程度上证实我们的猜测。其实，解决堆相关问题，可以使用神器 <code>gflags</code>，可以在尽可能早的时候把问题暴露出来。</p><h2 id="设置-gflags"><a href="#设置-gflags" class="headerlink" title="设置 gflags"></a>设置 gflags</h2><p>打开 <code>gflags.exe</code>，切换到 <code>Image File</code> 页，在 <code>Image:(TAB to refresh)</code> 后面的编辑框内输入 <code>vs</code> 的进程名 <code>devenv.exe</code>，然后按 <code>TAB</code> 键。可以无脑勾选跟堆相关的所有选项。每一项的具体意义可以询问 AI，给出的解释比较靠谱。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/set-gflags-for-devenv.png" alt="set-gflags-for-devenv"></p><p>当然，也可以通过命令行执行，最终都是操作注册表（下表摘自<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/gflags-details" target="_blank" rel="noopener">微软官方文档</a>）：</p><table><thead><tr><th align="left">设置类型</th><th align="left">注册表位置</th></tr></thead><tbody><tr><td align="left">系统级设置（注册表）</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\GlobalFlag</td></tr><tr><td align="left">特定程序的设置（“映像文件”）适用于计算机的所有用户。</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\GlobalFlag</td></tr><tr><td align="left">特定程序的无提示退出设置（“无提示进程退出”）适用于计算机的所有用户。</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\ImageFileName</td></tr><tr><td align="left">计算机的所有用户的图像文件的页堆选项</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\PageHeapFlags</td></tr><tr><td align="left">用户模式堆栈跟踪数据库大小 （<strong>tracedb</strong>）</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\StackTraceDatabaseSizeInMb</td></tr><tr><td align="left">为图像文件创建用户模式堆栈跟踪数据库（ust、0x1000）</td><td align="left">Windows 将映像文件名添加到 USTEnabled 注册表项的值（HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\USTEnabled）。</td></tr><tr><td align="left">在可能的情况下大型页加载映像</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\UseLargePages。</td></tr><tr><td align="left">特殊池（内核特殊池标记）</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PoolTag</td></tr><tr><td align="left">验证开始/验证结束</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PoolTagOverruns。 “ <strong>验证开始</strong> ”选项将值设置为 0。 “ <strong>验证结束</strong> ”选项将值设置为 1。</td></tr><tr><td align="left">映像文件的调试器</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\调试器</td></tr><tr><td align="left">对象引用跟踪</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Kernel\ObTraceProcessName  ObTracePermanent 和 ObTracePoolTags</td></tr></tbody></table><p>配置好后，再次重现问题，打开转储文件，再次进行分析。</p><h2 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h2><p>执行 <code>k</code> 命令，可以发现在 <code>GetParent</code> 函数内部触发了异常。如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/callstack-after-turn-on-gflags.png" alt="callstack-after-turn-on-gflags"></p><p>执行 <code>.ecxr</code> 查看异常发生时的上下文，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/ecxr-after-turn-on-gflags.png" alt="ecxr-after-turn-on-gflags"></p><p>第一眼就感觉 <code>rax</code> 的值好特殊啊。看看它的来源，很幸运，在崩溃代码附近（<code>00007fff984e309a</code>）执行 <code>ub</code> 和 <code>u</code> 操作可以找到完整信息，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/virtual-function-call-when-crash.png" alt="virtual-function-call-when-crash"></p><p>红色高亮部分是非常典型的虚函数调用代码。<code>rax</code> 指向虚表，<code>rbx</code> 是对象地址。非常幸运的是在红框上方，把 <code>rbx</code> 保存到了栈 <code>rsp+40h</code> 的地方。其实，没必要，因为当前上下文是异常发生时的上下文（执行了 <code>.ecxr</code> 命令），直接可以获取 <code>rbx</code> 的值。通过查看栈上的值，也佐证了这个观点。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/verify-rbx-by-rsp.png" alt="verify-rbx-by-rsp"></p><p>拿到对象地址后，执行 <code>!address 000001a053fd31f0</code> 和 <code>!heap -x 000001a053fd31f0</code></p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/view-heap-address-info.png" alt="view-heap-address-info"></p><p>从图中没看出特别明显的错误（尤其注意 <code>Flags</code> 的值）。我们已经使用 <code>gflags</code> 开启页堆，并且开启了 <code>ust</code>，可以通过 <code>!heap -p -a 0x1a053fd31f0</code> 命令查看此地址相关的调用栈，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/heap-p-a-address.png" alt="heap-p-a-address"></p><p>从上图可知，在 <code>VSDebug!treegrid::CTreeGridItemContainerGenerator::Refresh</code> 的时候已经触发了 <code>delete</code> 操作，至此，已经可以确认这是个重复释放的问题了，而且第一次释放时的调用栈也很清楚。</p><p>虽然问题已经很明确了，但是我堆 <code>f0f0f0f0f0f0f0f0</code> 这个填充模式充满了好奇。</p><h2 id="填充模式"><a href="#填充模式" class="headerlink" title="填充模式"></a>填充模式</h2><p>我在查看 <code>windbg</code> 帮助文档关于 <code>!heap</code> 部分时，意外发现了它的意义。原来是开启轻型页堆时，内存被释放后，会用此模式填充。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/fill-pattern-explanation-from-windbg-help-document.png" alt="fill-pattern-explanation-from-windbg-help-document"></p><p>而且，我还发现了其它几个有意思的填充值，赶紧实战验证下，通过上面的 <code>!heap -x 000001a053fd31f0</code> 命令已经得到了对应的 <code>Heap Entry</code> 的地址是 <code>000001a053fd31a0</code>。使用 <code>dd 000001a053fd31a0 L80</code> 命令看一下这段内存数据的值。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/view-memory-patttern.png" alt="view-memory-patttern"></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>虽然查到问题了，但是没有代码，也没法解决。但是在整个折腾的过程中发现只有开着某个特定程序的时候，<code>vs</code> 才会崩溃，关闭这个特定程序后 <code>vs</code> 就不再崩溃了。应该是那个程序使用了 <code>UIA</code> 相关接口，做了一些事情，导致 <code>vs</code>  崩溃。</p><p>就不再继续折腾了，有时候不是所有问题都要有一个明确的答案，这也算是解决问题的一种方式吧。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>我已经把对应的转储文件上传到百度云盘了，感兴趣的小伙伴可以下载，亲自实战一番。</p><p>链接: <a href="https://pan.baidu.com/s/15Xa-pCeezeHNwNVwJfGzxA" target="_blank" rel="noopener">https://pan.baidu.com/s/15Xa-pCeezeHNwNVwJfGzxA</a> 提取码: puv8</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/gflags-details" target="_blank" rel="noopener">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/gflags-details</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>procdump</code> 是收集转储文件的神兵利器，一定要放到自己的武器库里</li><li><code>gflags</code> 是解决内存破坏问题的神器，一定要放到自己的武器库里</li><li><code>gflags</code> 最终结果是设置注册表，必要时可以手动设置</li><li><code>x64</code> 位程序默认调用约定是 <code>__stdcall</code>，第一个参数一般会通过 <code>rcx</code> 传递</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录了一次独特的调试经历：作为开发利器的 &lt;code&gt;Visual Studio 2022&lt;/code&gt;，其在切换调用栈时频繁崩溃。面对这一问题，利用 &lt;code&gt;procdump&lt;/code&gt; 自动捕获崩溃转储文件，并通过 &lt;code&gt;WinDbg&lt;/code&gt; 初步排查将问题指向堆内存的异常操作，可能是堆损坏或重复释放。为了精准定位，我启用 &lt;code&gt;gflags&lt;/code&gt; 工具开启页堆检测，最终成功捕获到首次释放操作的完整调用栈，明确问题根源在于&lt;code&gt;VSDebug!treegrid::CTreeGridItemContainerGenerator::Refresh&lt;/code&gt;过程中的&lt;strong&gt;内存重复释放&lt;/strong&gt;。虽然因缺少源码无法直接修复，但通过环境隔离（关闭特定程序）避免了问题复现。此次实战再次证明了 &lt;code&gt;procdump&lt;/code&gt;、&lt;code&gt;gflags&lt;/code&gt; 等工具在诊断复杂内存问题中的巨大价值，也提醒我们即使面对没有源码的“黑盒”组件，系统化的调试方法依然能指引我们找到问题的本质。&lt;/p&gt;
&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近，用 &lt;code&gt;vs2022&lt;/code&gt; 在调试的时候，切换调用栈，会有很大概率崩溃。一次两次就忍了，不停的崩溃就有点说不过去了。 话不多说，先放张动图看看 &lt;code&gt;vs2022&lt;/code&gt; 是怎么崩溃的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/vs2022%E5%B4%A9%E6%BA%83.gif&quot; alt=&quot;vs2022崩溃&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="gflags" scheme="https://bianchengnan.github.io/tags/gflags/"/>
    
      <category term="vs222" scheme="https://bianchengnan.github.io/tags/vs222/"/>
    
      <category term="debugger" scheme="https://bianchengnan.github.io/tags/debugger/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 一个隐蔽的崩溃：当 this 指针在构造函数中“杀死”自己</title>
    <link href="https://bianchengnan.github.io//articles/debug-unexpected-crash-due-to-misuse-of-refcountedptr/"/>
    <id>https://bianchengnan.github.io//articles/debug-unexpected-crash-due-to-misuse-of-refcountedptr/</id>
    <published>2025-11-22T11:21:23.000Z</published>
    <updated>2025-12-13T05:48:33.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在最近的项目开发中，我遇到了一个由智能指针误用导致的程序崩溃问题。问题的根源在于 <code>SheetDataHandler</code> 类的构造函数中，将 <code>this</code> 指针传递给了一个接收 <code>SheetDataHandlerPtr</code>（智能指针类型）参数的静态函数 <code>HandleMissingColumn</code>。这个看似简单的操作，却导致了对象在构造函数执行期间被意外释放，最终引发空指针访问异常。</p><p>通过深入调试和反汇编分析，我发现当 <code>this</code> 指针被隐式转换为智能指针时，引用计数会从 <code>0</code> 增加到 <code>1</code>，而在函数调用结束后，智能指针对象析构时引用计数又减回 <code>0</code>，从而触发了对象的 <code>delete</code> 操作。这导致构造函数尚未执行完毕，对象就已经被销毁，后续对成员变量的访问变成了访问已释放内存的非法操作。</p><a id="more"></a><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>以下是我精简整理后的模拟代码，大家可以先锻炼一下眼力，看看是否可以一眼看出问题所在。关于 <code>RefCountedPtr</code> 的代码就不列出来了，可以参考<a href="https://bianchengnan.github.io/articles/mixed-use-of-different-shared-ptr/">之前的文章</a>。</p><blockquote><p><strong>提示</strong>：问题出在 <code>SheetDataHandler.cpp</code> 中。</p></blockquote><ul><li>表格数据处理类头文件 <code>SheetDataHandler.h</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SheetDataHandler.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RefCountedPtr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::wstring&gt; headers;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt;&gt; datasVec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataHandler</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> RefCountedPtr&lt;SheetDataHandler&gt; SheetDataHandlerPtr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataHandler</span> :</span> <span class="keyword">public</span> RefCounted&lt;IRefCounted&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SheetDataHandler(<span class="keyword">const</span> SheetData&amp; sheetData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleMissingColumn</span><span class="params">(SheetDataHandlerPtr helper, <span class="keyword">const</span> SheetData&amp; sheetData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetRowDataPtr&gt; rowDatas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::wstring&gt; headers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>表格数据处理类实现文件 <code>SheetDataHandler.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SheetDataHandler.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"></span><br><span class="line">SheetDataHandler::SheetDataHandler(<span class="keyword">const</span> SheetData&amp; sheetData)</span><br><span class="line">&#123;</span><br><span class="line">    HandleMissingColumn(<span class="keyword">this</span>, sheetData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SheetDataHandler::HandleMissingColumn(SheetDataHandlerPtr helper, <span class="keyword">const</span> SheetData&amp; sheetData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> headers = sheetData.headers;</span><br><span class="line">    <span class="keyword">auto</span> datasVec = sheetData.datasVec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle logic</span></span><br><span class="line"></span><br><span class="line">    helper-&gt;headers = headers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; rowData : datasVec)</span><br><span class="line">    &#123;</span><br><span class="line">        helper-&gt;rowDatas.push_back(<span class="built_in">std</span>::make_shared&lt;SheetRowData&gt;(helper, rowData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>表格数据类头文件 <code>SheetRowData.h</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SheetRowData.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RefCountedPtr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetCellData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SheetCellData() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    SheetCellData(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; data_) : data(data_), type(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::wstring data;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataHandler</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> RefCountedPtr&lt;SheetDataHandler&gt; SheetDataHandlerPtr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetRowData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SheetRowData() = <span class="keyword">default</span>;</span><br><span class="line">    SheetRowData(SheetDataHandlerPtr sdhPtr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt; cells);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt; cells;</span><br><span class="line">    SheetDataHandlerPtr sdhPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SheetRowData&gt; SheetRowDataPtr;</span><br></pre></td></tr></table></figure><ul><li>表格数据类实现文件 <code>SheetRowData.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SheetRowData.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"></span><br><span class="line">SheetRowData::SheetRowData(SheetDataHandlerPtr sdhPtr_, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt; cells_) : sdhPtr(sdhPtr_), cells(cells_)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>表格数据处理流程管理类头文件 <code>SheetDataProcessManager.h</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SheetDataProcessManager.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataProcessManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SheetDataProcessManager&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetData&gt; ReadSheetDatas(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetDataHandlerPtr&gt; sdhMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>表格数据处理流程管理类实现文件 <code>SheetDataProcessManager.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SheetDataProcessManager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataProcessManager.h"</span></span></span><br><span class="line"></span><br><span class="line">SheetDataProcessManager&amp; SheetDataProcessManager::Instance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> SheetDataProcessManager s_instance;</span><br><span class="line">    <span class="keyword">return</span> s_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetData&gt; SheetDataProcessManager::ReadSheetDatas(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetData&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read from excel</span></span><br><span class="line"></span><br><span class="line">    SheetData sheet1;</span><br><span class="line">    sheet1.headers = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::wstring&gt;&#123; <span class="string">L"ID"</span>, <span class="string">L"Name"</span>, <span class="string">L"Age"</span> &#125;;</span><br><span class="line">    sheet1.datasVec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt;&gt;&#123; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt;&#123; SheetCellData(<span class="string">L"001"</span>), SheetCellData(<span class="string">L"test"</span>), SheetCellData(<span class="string">L"18"</span>) &#125;&#125;;</span><br><span class="line">    result[<span class="string">L"Sheet1"</span>] = sheet1;</span><br><span class="line"></span><br><span class="line">    result[<span class="string">L"Sheet2"</span>] = SheetData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SheetDataProcessManager::Init(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> sheetDatas = ReadSheetDatas(path);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : sheetDatas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> handler = <span class="keyword">new</span> SheetDataHandler(it.second);</span><br><span class="line">        sdhMap[it.first] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SheetDataProcessManager::Handle()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主文件 <code>TestRefCountedPtrCrash.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TestRefCountedPtrCrash.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataProcessManager.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SheetDataProcessManager::Instance().Init(<span class="string">L"test.xlsx"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>优化完代码，执行测试时，遇到了一个崩溃问题，从错误提示看是读取非法地址（<code>0xFFFFFFFFFFFFFFF7</code>）导致的异常。从调用栈看是在执行 <code>RefCountedPtr</code> 的构造函数时发生的异常，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/refcountedptr-assignment-error.png" alt="refcountedptr-assignment-error"></p><p>好奇怪，其基类成员 <code>m_refCount</code> 的值是 <code>-572662307</code>，一个负数，按理说不应该是负数才对。<code>this-&gt;p_</code> 的值是 <code>0x000002519d2d2960</code>，并不是 <code>0xFFFFFFFFFFFFFFF7</code>，为什么会提示 <code>this-&gt;_p-&gt;</code> 是 <code>0xFFFFFFFFFFFFFFF7</code> 呢？先不管了，翻看一下上下文相关代码，没看到明显错误，应该是执行以下代码导致的异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdhMap[it.first] = handler;</span><br></pre></td></tr></table></figure><p>可是这行代码简单到不能再简单了——把对象保存到 <code>map</code> 中，这能出什么问题？既然代码看不出什么问题，那就还是回到发生异常的代码处看看吧。</p><h2 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h2><p>查看最顶层栈帧对应的代码，根据经验，最可能发生异常的是这句话 <code>p_-&gt;AddRef()</code>。具体查看一下发生异常时的汇编指令，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/call-virtual-function-AddRef.png" alt="call-virtual-function-AddRef"></p><p>红色高亮部分是明显的虚函数调用汇编代码、<code>rcx</code> 指向 <code>p_</code>，<code>rax</code> 指向虚表。<code>rax+8</code> 指向虚表第一个函数。等等，<code>rax</code> 的值怎么这么大？而且好像是十进制的，这时候我才发现我没开启十六进制显示。那赶紧看看对应的十六进制是什么？如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/view-values-in-hex.png" alt="view-values-in-hex"></p><p>真是不看不知道，一看吓一跳啊！！！ <code>rax</code> 的值是 <code>0xdddddddddddddddd</code>。而且注意看，<code>m_refCount</code> 的值也是 <code>0xdddddddd</code>。这个值可太熟悉了，当一个对象被删除时，<code>debug</code> 模式下会用 <code>0xdddddddd</code> 填充。难道这个指针被删除后，还在继续使用？查看一下这个指针的来源。查看代码可知，指针来源于 <code>auto handler = new SheetDataHandler(it.second);</code>。难道 <code>new</code> 返回的指针被释放了？代码如此简单，难道是构造函数内部出问题了？赶紧查看构造函数的实现。</p><h2 id="构造函数惹的祸"><a href="#构造函数惹的祸" class="headerlink" title="构造函数惹的祸"></a>构造函数惹的祸</h2><p>构造函数内部只调用了静态函数 <code>HandleMissingColumn(this, sheetData);</code>，并且把当前对象地址当作第一个参数传过去了。再看下这个静态函数的声明，<code>void SheetDataHandler::HandleMissingColumn(SheetDataHandlerPtr helper, const SheetData&amp; sheetData)</code>。第一个参数是一个基于引用计数的智能指针对象。至此，思索片刻，我明白了问题所在，正是这个函数的第一个参数导致了问题。执行构造函数时，引用计数是 <code>0</code>，通过 this 指针构造一个 <code>RefCountedPtr</code>，引用计数 <code>+1</code>，当这个 <code>RefCountedPtr</code> 对象声明周期结束时，引用计数 <code>-1</code> ，引用计数会变成 <code>0</code>，当引用计数变成 <code>0</code> 的时候，会触发执行 <code>delete</code>。怎么证明呢？直接在 <code>RefCounted::Release()</code> 函数加断点，再次运行程序，果然命中，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/delete-self-in-constructor.png" alt="delete-self-in-constructor"></p><p>找到问题根源，解决起来就简单了，只需要修改 <code>void SheetDataHandler::HandleMissingColumn(SheetDataHandlerPtr helper, const SheetData&amp; sheetData)</code> 的第一个参数为原生指针即可。或者在构造函数外部调用此函数也可以解决问题。</p><p>但是，这段代码之前运行一直没问题，为什么最近才暴雷呢？</p><h2 id="消除疑问"><a href="#消除疑问" class="headerlink" title="消除疑问"></a>消除疑问</h2><p>仔细想了一下，之前一直没问题，是因为一直能读取到数据。当有数据时，<code>HandleMissingColumn()</code> 函数内部会调用下面这行代码 <code>helper-&gt;rowDatas.push_back(std::make_shared&lt;SheetRowData&gt;(helper, rowData));</code> ，此行代码会构造一个 <code>SheetRowData</code> 对象，该对象内部有一个成员变量 <code>SheetDataHandlerPtr sdhHelper</code>，会增加引用计数。所以一直没发现这个问题。这下终于把所有疑问都搞清楚了，但是正是因为这番刨根问题，让我又意识到了这段代码中存在的另外一个问题——潜在的内存泄漏。</p><h2 id="潜在的内存泄漏"><a href="#潜在的内存泄漏" class="headerlink" title="潜在的内存泄漏"></a>潜在的内存泄漏</h2><p>为什么会导致内存泄漏呢？如果外部只是把 <code>sdhMap</code> 直接清空，当有数据时，<code>SheetDataHandler</code> 的析构函数是不会被调用的，因为 <code>SheetRowData</code> 中还持有着 <code>SheetDataHandlerPtr</code>。要想释放掉内存，就要在清空 <code>sdhMap</code> 前，先清空 <code>SheetDataHandler</code> 对象中的 <code>rowDatas</code>。这样就不会泄漏了。其实，更优雅的做法是使用标准库提供的 <code>std::weak_ptr</code>，让 <code>SheetRowData</code> 中持有 <code>std::weak_ptr&lt;SheetDataHandler&gt;</code>，使用的时候提升成 <code>std::shared_ptr</code>，如果提升成功，可以正常使用，如果失败，说明已经被删除，不能继续使用。</p><h2 id="无解的-vs-异常提示"><a href="#无解的-vs-异常提示" class="headerlink" title="无解的 vs 异常提示"></a>无解的 vs 异常提示</h2><p>当异常发生时，<code>vs</code> 中报的错误是 <code>引发了异常：读取访问权限冲突。this-&gt;p_ -&gt; 是 0xFFFFFFFFFFFFFFF7</code>。分析完整个异常，也没找到这个 <code>0xFFFFFFFFFFFFFFF7</code> 来自哪里，按理说应该访问 <code>0xdddddddddddddddd + 8</code> 这个地址触发的异常才对。于是保存了一个 <code>dump</code>，在 <code>windbg</code> 中打开，输入 <code>.ecxr</code> 指令查看异常发生时的指令及寄存器信息，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/check-exception-in-windbg.png" alt="check-exception-in-windbg"></p><p> 确实是无法访问 <code>0xdddddddddddddddd + 8</code> 地址对应的内存。不知道 <code>vs</code> 为什么会给出这么一个提示，希望有知道的朋友不吝赐教！</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>相关工程代码已经上传到 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/debug-unexpected-crash-due-to-misuse-of-refcountedptr\TestRefCountedPtrCrash" target="_blank" rel="noopener">github</a> 了，感兴趣的小伙伴儿可以下载验证。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/crtsetdbgflag?view=msvc-170" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/crtsetdbgflag?view=msvc-170</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在构造函数中一定不能把 <code>this</code> 指针当作 <code>RefCountedPtr</code> 使用</li><li><code>0xdddddddd</code> 是常用的删除后的填充数据，需要提高敏感度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在最近的项目开发中，我遇到了一个由智能指针误用导致的程序崩溃问题。问题的根源在于 &lt;code&gt;SheetDataHandler&lt;/code&gt; 类的构造函数中，将 &lt;code&gt;this&lt;/code&gt; 指针传递给了一个接收 &lt;code&gt;SheetDataHandlerPtr&lt;/code&gt;（智能指针类型）参数的静态函数 &lt;code&gt;HandleMissingColumn&lt;/code&gt;。这个看似简单的操作，却导致了对象在构造函数执行期间被意外释放，最终引发空指针访问异常。&lt;/p&gt;
&lt;p&gt;通过深入调试和反汇编分析，我发现当 &lt;code&gt;this&lt;/code&gt; 指针被隐式转换为智能指针时，引用计数会从 &lt;code&gt;0&lt;/code&gt; 增加到 &lt;code&gt;1&lt;/code&gt;，而在函数调用结束后，智能指针对象析构时引用计数又减回 &lt;code&gt;0&lt;/code&gt;，从而触发了对象的 &lt;code&gt;delete&lt;/code&gt; 操作。这导致构造函数尚未执行完毕，对象就已经被销毁，后续对成员变量的访问变成了访问已释放内存的非法操作。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="warning" scheme="https://bianchengnan.github.io/tags/warning/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 永远不要忽略编译警告：记一次由重复switch语句导致的诡异崩溃</title>
    <link href="https://bianchengnan.github.io//articles/debug-unexpected-crash-and-never-ignore-compiling-warnings/"/>
    <id>https://bianchengnan.github.io//articles/debug-unexpected-crash-and-never-ignore-compiling-warnings/</id>
    <published>2025-11-22T02:21:23.000Z</published>
    <updated>2025-12-13T05:48:33.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录并剖析了一次由看似低级的代码错误引发的、令人意想不到的程序崩溃。问题的根源在于 <code>GetErrorStr</code> 函数中一个容易被忽略的重复 <code>switch</code>语句。这个错误导致函数返回的 <code>std::wstring</code> 对象未被正确初始化，最终在构造 <code>CResult</code> 对象时引发了空指针访问异常 。</p><p>本文通过深入分析崩溃调用栈和反汇编代码，清晰地总结了从函数异常返回（未初始化字符串）到调用端使用无效数据（触发崩溃）的完整过程。希望这个案例能提醒各位，<strong>编译警告是发现潜在风险的第一道防线</strong>，而<strong>基础的汇编知识则是深入调试的利器</strong>。文末有可复现问题的代码，欢迎动手实践。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>好久没写文章了，一个是懒，一个是没有好的素材。最近在研发过程中遇到了几个崩溃问题，挺有意思的，值得总结。今天要总结的问题比较低级，而且编译的时候会报警告，但还是挺有教育意义的。一起看看吧。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>以下是我精简整理后的模拟代码，大家可以先锻炼一下眼力，看看是否可以一眼看出问题所在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CResult</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CResult(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; data_) </span><br><span class="line">        : data(data_)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::wstring data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DoModify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// a lot logic code, return error code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">wstring <span class="title">GetErrorStr</span><span class="params">(<span class="keyword">int</span> error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (error)</span><br><span class="line">    <span class="keyword">switch</span> (error)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"Ok"</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"Invalid Param"</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"Operation Failed"</span>;</span><br><span class="line">    <span class="comment">// a lot more other cases</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"N/A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> modifyResult = DoModify();</span><br><span class="line">    <span class="function">CResult <span class="title">result</span><span class="params">(GetErrorStr(modifyResult))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>优化完代码后，运行突然崩溃了，简单查看后，是非常典型的空指针异常。</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/nullptr-exception-callstacks.png" alt="nullptr-exception-callstacks"></p><p>心想这不是小菜一碟吗？空指针异常？老朋友了！但是简单翻看调用栈，好像不是普通的空指针异常，在构造字符串对象的时候抛出了异常（上图红色高亮部分调用栈）。难道字符串出问题了？当时脑子里就一句话：字符串能出什么问题？？？</p><p>但是通过调试查看，好像还真是字符串出问题了，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/string-error.png" alt="string-error"></p><p>既然是字符串出问题了，那就看下字符串的来源，来自函数 <code>std::wstring GetErrorStr(int error)</code> 的返回值。查看这个函数的实现。真是不看不知道，一看吓一跳！怎么有两行一样的 <code>switch(error)</code> ？这代码肯定是不对的，删掉一行，再次运行，果然没问题了。</p><p>为什么有重复的 <code>swtich</code> 就会崩溃呢？源码猜不出来，那就看看反汇编代码吧。</p><h2 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h2><p>反汇编代码如下，红色高亮部分是第一个 <code>switch</code> 对应的代码，什么有意义的事情都没做，直接跳转到函数结尾<code>00007FF7800F3A34</code> 了。</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/disassembly-code-of-geterrorstr.png" alt="disassembly-code-of-geterrorstr"></p><p>从图中反汇编代码可知，<code>GetErrorStr()</code> 没对字符串对象做任何初始化操作。那么调用端呢？是否初始化了字符串对象呢？我们接着看一下调用端的反汇编代码，从下图中可知，调用函数也没有初始化字符串对象。</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/disassembly-code-of-main.png" alt="disassembly-code-of-geterrorstr"></p><p>综上，该字符串对象没有被初始化，其内容完全是随机的。</p><p>至此，此次崩溃问题已经很清楚了。但是，这种低级错误，按理说应该有警告才对啊？！</p><h2 id="编译警告"><a href="#编译警告" class="headerlink" title="编译警告"></a>编译警告</h2><p>再次编译，果然有警告，当时我应该忽略了，看来一定要注意编译警告！</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/compile-warning.png" alt="compile-warning"></p><h2 id="汇编小知识"><a href="#汇编小知识" class="headerlink" title="汇编小知识"></a>汇编小知识</h2><p>简单解释以上汇编代码，对于刚接触汇编的小伙伴会有帮助。先了解一些基本知识：</p><ol><li><code>x64</code> 下的默认调用约定是 <code>stdcall</code>，前四个参数（非浮点型）通过 <code>rcx rdx r8 r9</code> 传递</li><li>对于 <code>std::wstring GetErrorStr(int error)</code> 这种返回复杂类型（非 <code>POD</code> 类型）的函数，生成的汇编代码相当于 <code>std::wstring* GetErrorStr(std::wstring*, int error)</code> 。<strong>第一个参数</strong> 指向了返回值的地址</li><li>调用结束后，返回值会保存在 <code>rax</code> 中</li></ol><p>所以，上图中第二句汇编代码 <code>00007FF7800F3924  mov qword ptr [rsp+8],rcx</code> 把字符串对象地址保存到了 <code>rsp+0x8</code> 的位置。接下来的几句汇编指令把 <code>rsp</code> 向下移动了 <code>0x8 + 0x8 + 0x108 = 0x118</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00007FF7800F3924  mov         qword ptr [rsp+8],rcx  </span><br><span class="line">00007FF7800F3929  push        rbp  </span><br><span class="line">00007FF7800F392A  push        rdi  </span><br><span class="line">00007FF7800F392B  sub         rsp,108h</span><br></pre></td></tr></table></figure><p>接下来的一条汇编指令 <code>00007FF7800F3932  lea rbp,[rsp+20h]</code> 使 <code>rbp</code> 指向了 <code>rsp+0x20</code> 的位置，那么 <code>rbp+0x100</code> 就指向了 第一个参数的地址。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>相关工程代码已经上传到 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/debug-unexpected-crash-and-never-ignore-compiling-warnings\TestSwitchCaseCrash" target="_blank" rel="noopener">github</a> 了，感兴趣的小伙伴儿可以下载验证。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>务必要关注编译器的警告</li><li>掌握汇编知识非常重要，尤其对调试更是如此</li><li><code>64</code> 位程序默认的调用约定是 <code>stdcall</code>，前四个参数（非浮点型）通过 <code>rcx rdx r8 r9</code> 传递</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录并剖析了一次由看似低级的代码错误引发的、令人意想不到的程序崩溃。问题的根源在于 &lt;code&gt;GetErrorStr&lt;/code&gt; 函数中一个容易被忽略的重复 &lt;code&gt;switch&lt;/code&gt;语句。这个错误导致函数返回的 &lt;code&gt;std::wstring&lt;/code&gt; 对象未被正确初始化，最终在构造 &lt;code&gt;CResult&lt;/code&gt; 对象时引发了空指针访问异常 。&lt;/p&gt;
&lt;p&gt;本文通过深入分析崩溃调用栈和反汇编代码，清晰地总结了从函数异常返回（未初始化字符串）到调用端使用无效数据（触发崩溃）的完整过程。希望这个案例能提醒各位，&lt;strong&gt;编译警告是发现潜在风险的第一道防线&lt;/strong&gt;，而&lt;strong&gt;基础的汇编知识则是深入调试的利器&lt;/strong&gt;。文末有可复现问题的代码，欢迎动手实践。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="warning" scheme="https://bianchengnan.github.io/tags/warning/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 5 —— 实战修复虚函数导致的编译错误</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/</id>
    <published>2024-12-01T06:37:07.000Z</published>
    <updated>2025-12-13T05:48:33.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，同事遇到了一个奇怪的编译问题，大概情况如下：</p><p><code>classA</code> 是模块 <code>A</code> 中的一个类， <code>classA</code> 没有定义构造函数，其它函数都是导出的。<code>B</code> 模块依赖了 <code>A</code> 模块，并且会调用 <code>classA</code> 的接口。当在 <code>B</code> 模块中添加了实例化 <code>classA</code> 对象的代码的时候，报链接错误，提示找不到 <code>classA</code> 类的某个虚函数。</p><p>我帮忙看过之后发现又是虚函数相关的编译问题（正好最近在总结虚函数相关的问题），这是送上门的素材啊！</p><a id="more"></a><blockquote><p><strong>说明：</strong> 项目代码不方便对外发布，本文所有的代码是我基于实际项目模拟的</p></blockquote><h2 id="示例程序简介"><a href="#示例程序简介" class="headerlink" title="示例程序简介"></a>示例程序简介</h2><p>示例程序由两个工程组成：<strong>主模块</strong>和<strong>接口模块</strong>。</p><ul><li><p>接口模块</p><p>接口模块只提供了头文件 <code>interface.h</code> 和对应的 <code>interface.lib</code> 文件及接口实现文件 <code>interface.dll</code>。头文件内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_INTERFACE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_INTERFACE InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>主模块</p><p>主模块会隐式依赖 <code>interface.lib</code>，并通过 <code>GetInterface()</code> 接口获取 <code>Interface1</code> 指针，然后调用其接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> if2 = Interface1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当在 <code>main()</code> 函数中通过 <code>auto if2 = Interface1();</code> 创建 <code>Interface1</code> 类型的对象时，编译器会报链接错误，提示无法解析的外部符号，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/LNK2001.png" alt="LNK2001"></p><h2 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h2><p>通过之前总结的几篇文章</p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/">《基础知识 | 有趣的动态转换》</a></p><p><a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a></p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/">《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/">《基础知识 | 函数基础 4 —— 又崩溃了，原来是虚函数声明顺序不一致捣的鬼 》</a></p><p>我对虚函数编译相关的问题有了比较全面的认识。</p><p>头文件中没声明 <code>Interface1</code> 的构造函数，并且 <code>Interface1</code> 包含虚函数，那么编译器会自动生成构造函数代码，与我们手动在头文件中<strong>定义</strong>一个空造函数是一样的。</p><p>在这种情况下，如果想在外部模块实例化 <code>Interface1</code> 的对象，那么 <code>Interface1</code> 所有的虚函数都需要是导出的或者需要在头文件中定义。</p><p>快速扫了一遍头文件，所有虚函数确实都是导出的。这就奇怪了，难道 <code>interface.lib</code> 文件又出问题了？</p><h2 id="查看-lib-文件"><a href="#查看-lib-文件" class="headerlink" title="查看 lib 文件"></a>查看 lib 文件</h2><p>使用 <code>vs</code> 自带的 <code>dumpbin</code> 查看 <code>interface.lib</code> 的导出符号，在命令行中分别输入以下两行命令，即可把 <code>Interface.lib</code> 中的导出符号信息导出到 <code>interface.txt</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> PATH=%PATH%;<span class="string">"C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\amd64\"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dumpbin /EXPORTS Interface.lib &gt; interface.txt</span></span><br></pre></td></tr></table></figure><p>在 <code>interface.txt</code> 中搜索 <code>Test4</code>，结果什么也没所搜到，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/cannot-search-Test4-from-interface-lib.png" alt="cannot-search-Test4-from-interface-lib"></p><p>原来又是头文件与 <code>lib</code> 文件不匹配导致的问题，头文件中包含 <code>Test4</code>，但是对应的 <code>lib</code> 文件中却没有。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>示例工程已经上传到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part5-real-sovle-a-real-virtual-function-compile-error" target="_blank" rel="noopener">这里</a>，感兴趣的小伙伴儿可以自行下载验证。</p><blockquote><p><strong>说明：</strong> 我已经上传了对应的 <code>Interface.lib</code> 及 <code>Interface.dll</code>，如果想重新编译 <code>Interface.vcxproj</code>，需要先注释掉 <code>Interface.h</code> 中包含 <code>Test4</code> 的那一行。编译成功后，如果想像我一样重现链接错误，那么需要在 <code>Interface.h</code> 中把删掉的 <code>Test4</code> 哪一行添加回来并且<strong>只重新编译</strong> <code>InterfaceExe.vcxproj</code>。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果类构造函数不是导出的，如果想在外部模块实例化类对象，那么类中所有虚函数都需要是导出的</li><li><code>dumpbin</code> 是查看 <code>.lib</code> 或 <code>.dll</code> 文件中导出符号的神兵利器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一阵子，同事遇到了一个奇怪的编译问题，大概情况如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;classA&lt;/code&gt; 是模块 &lt;code&gt;A&lt;/code&gt; 中的一个类， &lt;code&gt;classA&lt;/code&gt; 没有定义构造函数，其它函数都是导出的。&lt;code&gt;B&lt;/code&gt; 模块依赖了 &lt;code&gt;A&lt;/code&gt; 模块，并且会调用 &lt;code&gt;classA&lt;/code&gt; 的接口。当在 &lt;code&gt;B&lt;/code&gt; 模块中添加了实例化 &lt;code&gt;classA&lt;/code&gt; 对象的代码的时候，报链接错误，提示找不到 &lt;code&gt;classA&lt;/code&gt; 类的某个虚函数。&lt;/p&gt;
&lt;p&gt;我帮忙看过之后发现又是虚函数相关的编译问题（正好最近在总结虚函数相关的问题），这是送上门的素材啊！&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="part5" scheme="https://bianchengnan.github.io/tags/part5/"/>
    
      <category term="编译错误" scheme="https://bianchengnan.github.io/tags/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 4 —— 又崩溃了，原来是虚函数声明顺序不一致捣的鬼</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/</id>
    <published>2024-11-09T06:37:07.000Z</published>
    <updated>2025-12-13T05:48:33.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，同事遇到了一个崩溃问题，解决后发现这个崩溃是由于在公共类中加了一个虚函数接口，但是并没有编译相关模块导致的。这种崩溃问题是老朋友了。在此之前，我已经写了几篇关于虚函数的总结，感兴趣的小伙伴儿可以查看这几篇文章：</p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/">《基础知识 | 有趣的动态转换》</a></p><p><a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a></p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/">《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》</a></p><p>本文主要关注以下两个问题，如果你已经有了很明确的答案，可以跳过本文：</p><ul><li>如果在编译 <code>A</code> 模块的时候，<code>Test</code> 类的虚函数声明的顺序是 <code>Test1, Test2, Test3</code>，但是在 <code>B</code> 模块编译的时候，<code>Test</code> 类头文件中虚函数顺序变成了 <code>Test2, Test1, Test3</code>。在 <code>B</code> 模块中调用 <code>test-&gt;Test1()</code>，调用的是哪个函数呢？</li></ul><ul><li>假设 <code>A</code> 模块代码不变，但是在编译 <code>B</code> 模块的时候，<code>Test</code> 类的头文件中又多了一个虚函数 <code>Test4()</code>，在 <code>B</code> 模块中调用 <code>test-&gt;Test4()</code>，代码可以正常编译吗？会有链接问题吗？如果可以正常编译链接，运行的时候会有问题吗？</li></ul><a id="more"></a><p>在开始验证前先回顾一下之前的结论</p><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><ul><li><p><strong>虚表及虚表中的函数地址会与构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中</p></li><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>调用虚函数的时候会先获取虚表指针，然后根据虚函数的索引从虚表中得到最终的函数地址进行调用</p></li></ul><p>更多结论请参考 <a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">上一篇文章</a>。</p><p>回顾完结论后，让我们用测试程序探寻以上两个问题的答案，先来看看示例程序的代码</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序由两个工程组成：<strong>主模块</strong>和<strong>接口模块</strong>。</p><ul><li><p>接口模块</p><p>对应的工程是 <code>Interface.vcxproj</code>。代码很简单，实现了接口，并暴露了一个导出接口供主模块使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_INTERFACE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_INTERFACE InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT__INTERFACE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Interface1::Test1(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test2(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test3(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>主模块</p><p>对应的工程是 <code>InterfaceExe.vcxproj</code>。主模块通过<strong>导出接口</strong>和<strong>直接实例化</strong>的方式获取 <code>Interface1</code> 的对象指针，然后调用 <code>Test2()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    Interface1* if2 = <span class="keyword">new</span> Interface1();</span><br><span class="line">    if1-&gt;Test2(<span class="number">0</span>);</span><br><span class="line">    if2-&gt;Test2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以上示例程序编译运行一切正常。接下来<strong>保持接口模块不变</strong>，修改代码后<strong>只重新编译主模块</strong>。</p><h2 id="验证1"><a href="#验证1" class="headerlink" title="验证1"></a>验证1</h2><p>交换 <code>Interface.h</code> 中的 <code>Test2()</code> 和 <code>Test3()</code> 的顺序，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>只重新编译主模块</strong>，查看运行结果。结果如下：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/swap-test2-test3.png" alt="swap-test2-test3"></p><p>虽然代码里调用的都是 <code>Test2()</code>，但是从输出结果可知：<code>if1</code> 调用的是 <code>Test3()</code>，<code>if2</code> 调用的是 <code>Test2()</code>。</p><p>在 <code>windbg</code> 中分别查看这两个调用对应的反汇编，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-disassembly-of-virtual-function-call.png" alt="view-disassembly-of-virtual-function-call"></p><p>可以发现，调用的都是虚表中索引为 <code>3</code> （<code>0x18 / 0x8 = 3</code>）的函数。分别查看一下虚表</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-vtable-in-windbg.png" alt="view-vtable-in-windbg"></p><p>可以发现，</p><p><code>if1</code> 对应的虚表存储在 <code>Interface</code> 模块，第 <code>3</code> 项是 <code>Interface!Interface1::Test3</code>；</p><p><code>if2</code> 对应的虚表存储在 <code>InterfaceExe</code> 模块，第 <code>3</code> 项是 <code>InterfaceExe!Interface1::Test2</code>。</p><p>在编译 <code>Interface</code> 模块时，由于 <code>GetInterface()</code> 内部会调用 <code>new Interface1</code>，因此会在 <code>Interface</code> 模块中生成虚表，此时 <code>Test3()</code> 是最后一项。</p><p>在编译 <code>InterfaceExe</code> 模块时，由于会直接调用 <code>new Interface1()</code>，因此会在 <code>InterfaceExe</code> 模块中生成虚表，此时 <code>Test2()</code> 是最后一项。</p><p>在 <code>windbg</code> 中查看  <code>InterfaceExe!Interface1::Test2</code> 对应的反汇编，可以发现其最终会调用 <code>Interface!Interface1::Test2()</code>。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-disassembly-of-interfaceexe-interface1-test2.png" alt="view-disassembly-of-interfaceexe-interface1-test2"></p><blockquote><p><strong>思考：</strong> 如果 <code>Test2</code> 和 <code>Test3</code> 的参数个数或者参数类型不一致，是不是会有更严重的问题？</p><p>根据上面的分析可知，从 <code>if1</code> 调用的话会有问题，从 <code>if2</code> 调用的话没问题。</p></blockquote><h2 id="验证-2"><a href="#验证-2" class="headerlink" title="验证 2"></a>验证 2</h2><p>在  <code>Interface.h</code>  中增加一个名为 <code>Test4</code> 的接口，并在 <code>main()</code> 函数中调用之。修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，<strong>只重新编译主模块</strong>。可以<strong>正常编译链接</strong>，但是执行的时候遇到了一个异常。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-4th-function-in-vtable.png" alt="view-4th-function-in-vtable"></p><p>从上图可知，在 <code>main()</code> 函数调用 <code>Test4()</code> 时，<code>rip</code> 指向了地址 <code>00000003 19930522</code>。因为在重新编译主模块时，<code>Test4()</code> 是虚表中的第 <code>4</code> 项（从 <code>0</code> 开始），而虚表中第 <code>4</code> 项的值是 <code>00000003 19930522</code>。</p><p>因为在编译 <code>Interface.dll</code> 的时候，一共只有 <code>4</code> 项，最大索引是 <code>3</code>。而主模块中的调用代码却尝试访问虚表中的第 <code>4</code> 项，而第 4 项的内容是随机的，所以在执行的时候发生了异常。</p><p>根据以上验证结果可知，<strong>编译器会根据头文件中的顺序生成虚函数调用代码</strong>，如果与虚函数所属模块生成时的顺序不一致，很可能调用的是不同的函数，行为是未定义的。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>示例工程已经上传到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part4-what-will-happen-if-virtual-function-reordered" target="_blank" rel="noopener">这里</a>了，感兴趣的小伙伴儿可以自行下载，根据 <code>验证 1</code> 和 <code>验证 2</code> 中的修改方式手动修改代码，进行验证。</p><blockquote><p><strong>务必注意：</strong> 修改完代码后不要重新编译 <code>Interface</code> 工程，只重新编译 <code>InterfaceExe</code> 工程！</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>编译器会根据头文件中的顺序生成虚函数调用代码</strong>，如果与虚函数所属模块生成时的顺序不一致，很可能调用的是不同的函数，行为是未定义的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一阵子，同事遇到了一个崩溃问题，解决后发现这个崩溃是由于在公共类中加了一个虚函数接口，但是并没有编译相关模块导致的。这种崩溃问题是老朋友了。在此之前，我已经写了几篇关于虚函数的总结，感兴趣的小伙伴儿可以查看这几篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/&quot;&gt;《基础知识 | 有趣的动态转换》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/&quot;&gt;《基础知识 | C++ 虚函数简介》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/&quot;&gt;《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/&quot;&gt;《基础知识 | 函数基础 1 —— 基本概念 &amp;amp; 如何调用外部模块的函数》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/&quot;&gt;《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/&quot;&gt;《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要关注以下两个问题，如果你已经有了很明确的答案，可以跳过本文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在编译 &lt;code&gt;A&lt;/code&gt; 模块的时候，&lt;code&gt;Test&lt;/code&gt; 类的虚函数声明的顺序是 &lt;code&gt;Test1, Test2, Test3&lt;/code&gt;，但是在 &lt;code&gt;B&lt;/code&gt; 模块编译的时候，&lt;code&gt;Test&lt;/code&gt; 类头文件中虚函数顺序变成了 &lt;code&gt;Test2, Test1, Test3&lt;/code&gt;。在 &lt;code&gt;B&lt;/code&gt; 模块中调用 &lt;code&gt;test-&amp;gt;Test1()&lt;/code&gt;，调用的是哪个函数呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;假设 &lt;code&gt;A&lt;/code&gt; 模块代码不变，但是在编译 &lt;code&gt;B&lt;/code&gt; 模块的时候，&lt;code&gt;Test&lt;/code&gt; 类的头文件中又多了一个虚函数 &lt;code&gt;Test4()&lt;/code&gt;，在 &lt;code&gt;B&lt;/code&gt; 模块中调用 &lt;code&gt;test-&amp;gt;Test4()&lt;/code&gt;，代码可以正常编译吗？会有链接问题吗？如果可以正常编译链接，运行的时候会有问题吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="part4" scheme="https://bianchengnan.github.io/tags/part4/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part3-call-unexported-virtual-function-of-another-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part3-call-unexported-virtual-function-of-another-module/</id>
    <published>2024-09-14T06:37:07.000Z</published>
    <updated>2025-12-13T05:48:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在上篇文章 <a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a>中，我们明白了一个事实 —— 可以在不依赖外部模块的情况下通过类对象指针调用其<strong>虚函数</strong>。</p><p>但是遗留了几个问题，如下：</p><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li></ul><ul><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p></li><li><p>问题 4：如果在 <code>Interface1</code>  中声明了未导出的构造函数，上述代码能编译通过吗？</p></li><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p></li><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p></li></ul><p>本文力求把这几个问题弄清楚。如果您对以上问题已经有了答案，可以跳过本文。</p><a id="more"></a><p>我们先简单回顾一下<a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">上篇文章</a>中的代码（可以到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module" target="_blank" rel="noopener">这里</a>下载或查看）：</p><ul><li><p><code>Interface</code> 模块定义了 <code>Interface1</code> 类，并且其接口函数都是导出的。</p></li><li><p><code>GetInterface</code> 模块导出了一个接口，该接口内部会 <code>new Interface1()</code> 并返回。</p></li><li><p><code>InterfaceExe</code> 模块通过 <code>GetInterface</code> 模块的导出接口获得 <code>Interface1</code> 的指针，然后调用其虚函数。</p></li></ul><p>在解答以上几个问题前，我们先查看以下几种情况编译器生成的汇编代码。</p><blockquote><p><strong>说明：</strong> </p><ol><li>本文查看的是 <code>release</code> 版本关闭优化后的汇编代码，比 <code>debug</code> 版本更简洁明了</li><li>下文中提到的 <strong>定义</strong> 指的是函数的声明和实现在一起</li></ol></blockquote><h2 id="情况-1"><a href="#情况-1" class="headerlink" title="情况 1"></a>情况 1</h2><p>注释掉上篇文章代码中对 <code>if1-&gt;Test4(0);</code> 的调用。编译并查看反汇编代码，重点关注构造函数及虚表的存储位置。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case1-getinterface-constructor-vftable.png" alt="case1-getinterface-constructor-vftable"></p><p>可以发现 <code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中。虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><h2 id="情况-2"><a href="#情况-2" class="headerlink" title="情况 2"></a>情况 2</h2><p>在 <code>情况 1</code> 代码的基础上进行如下修改：</p><ul><li><p>在头文件<strong>定义</strong>构造函数（注意：头文件中既包含声明又包含实现）</p></li><li><p>在头文件<strong>定义</strong>一个名为 <code>Test5()</code> 的虚函数</p></li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Interface1() &#123;&#125;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="查看构造函数及虚表"><a href="#查看构造函数及虚表" class="headerlink" title="查看构造函数及虚表"></a>查看构造函数及虚表</h3><p>编译运行，跟踪反汇编代码。可以发现，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中。虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-getinterface-constructor-vftable.png" alt="case2-getinterface-constructor-vftable"></p><h3 id="查看虚函数汇编代码"><a href="#查看虚函数汇编代码" class="headerlink" title="查看虚函数汇编代码"></a>查看虚函数汇编代码</h3><p>挑几个典型的虚函数，查看其反汇编代码。</p><ul><li>先来看看 <code>InterfaceBase::scalar deleting destructor</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interfacebase-destructor.png" alt="case2-interfacebase-destructor"></li></ul><ul><li>再来看看 <code>Interface1::scalar deleting destructor</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-destructor.png" alt="case2-interface1-destructor"></li></ul><ul><li><p>再来看看 <code>Interface1::Test1()</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-test1.png" alt="case2-interface1-test1"></p><p>可以发现，<code>GetInterface</code> 模块中的 <code>Interface1::Test1()</code> 会调用 <code>Interface</code> 模块导出的  <code>Interface1::Test1()</code>。</p></li></ul><ul><li>再来看看 <code>Interface1::Test5()</code>的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-test5.png" alt="case2-interface1-test5"></li></ul><p>以上几个函数有一个共同特点：所有函数的实现代码都在 <code>GetInterface</code> 模块中。我是怎么知道的？根据输出结果判断的，输出结果中，<code>!</code> 前面的部分是模块名。比如，<code>GetInterface!Interface1::Test5</code>，对应的模块是 <code>GetInterface</code>。</p><blockquote><p><strong>小贴士：</strong> 还可以根据 <code>lma address</code> 来查找某个地址所属的模块</p></blockquote><h3 id="两种编译报错的情况"><a href="#两种编译报错的情况" class="headerlink" title="两种编译报错的情况"></a>两种编译报错的情况</h3><ul><li>去掉 <code>Test2()</code> 的导出标识，再编译，会报链接错误，如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-test2-not-export-link-error.png" alt="case2-test2-not-export-link-error"></li></ul><ul><li>如果把 <code>Interface1</code> 的构造函数的定义移动到 <code>Interface.cpp</code> 中，头文件中只保留声明，也会报链接错误，如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-constructor-implement-in-cpp-link-error.png" alt="case2-constructor-implement-in-cpp-link-error"></li></ul><p>  其实，这两个错误有共性：</p><ol><li><p>都没有导出标识</p></li><li><p>实现和声明分离</p><p>实现在 <code>Interface.cpp</code> 中，最终会编译到 <code>Interface</code> 模块，而不是 <code>GetInterface</code> 模块</p></li><li><p>都会被 <code>GetInterface</code> 模块用到</p><ul><li>在 <code>new Interface()</code> 时会调用构造函数</li><li>在构造函数调用时会初始化虚表指针，指向虚表。虚表需要记录 <code>Test2()</code> 的地址，而 <code>Test2()</code> 在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址</li></ul></li></ol><blockquote><p><strong>说明：</strong> <code>情况 1</code> 的构造函数的代码是编译器自动生成的，与 <code>情况 2</code> 的构造函数代码是一样的。</p></blockquote><h2 id="情况-3"><a href="#情况-3" class="headerlink" title="情况 3"></a>情况 3</h2><p>在 <code>情况 2</code> 代码的基础上进行如下修改：</p><ul><li>为构造函数增加导出标识，并且把实现移动到 <code>Interface.cpp</code> 中</li><li>去掉其它函数的导出标识。只保留 <code>Test3()</code> 的导出标识</li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="title">Interface1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line">Interface1::Interface1()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看构造函数及虚表-1"><a href="#查看构造函数及虚表-1" class="headerlink" title="查看构造函数及虚表"></a>查看构造函数及虚表</h3><p>编译运行，跟踪反汇编代码。可以发现，<code>GetInterface!GetInterface()</code> 调用的构造函数是从 <code>Interface</code> 模块导入的。</p><p><code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case3-getinterface-constructor-vftable.png" alt="case3-getinterface-constructor-vftable"></p><blockquote><p><strong>注意：</strong> </p><ul><li><p>虚表中的所有函数的地址都属于 <code>Interface</code> 模块，与 <code>情况 2</code> 不一样。</p></li><li><p>虽然 <code>Test3()</code> 是导出的，但是虚表中保存的 <code>Test3</code> 的地址是 <code>Interface</code> 模块的。</p></li><li><p>注意 <code>Test5()</code>。在 <code>情况 2</code> 中，虚表中保存的 <code>Test5()</code> 的地址是在 <code>GetInterface</code> 模块中的，而且不会像其它函数一样调用 <code>Interface</code> 模块中的函数。在  <code>情况 3</code> 中，虚表中保存的 <code>Test5()</code> 的地址在 <code>Interface</code> 模块中。</p></li></ul><p>可以猜测，因为构造函数被导出了，没有必要在外部模块创建虚表了。</p></blockquote><h2 id="情况-4"><a href="#情况-4" class="headerlink" title="情况 4"></a>情况 4</h2><p>在 <code>情况 3</code> 代码的基础上进行如下修改：</p><ul><li>去掉所有函数的导出标识</li><li>增加一个名为 <code>ExportInterface</code> 的导出接口，返回 <code>Interface1</code> 对象指针</li><li>修改 <code>GetInterface.cpp</code> 中的 <code>GetInterface</code> 接口，直接调用 <code>ExportInterface()</code></li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.h </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Interface1();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExportInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，跟踪反汇编代码。可以发现，与 <code>情况 3</code> 基本一致。<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case4-getinterface-constructor-vftable.png" alt="case4-getinterface-constructor-vftable"></p><h2 id="情况-5"><a href="#情况-5" class="headerlink" title="情况 5"></a>情况 5</h2><p>在 <code>情况 2</code> 代码的基础上进行如下修改：</p><ul><li>在 <code>Interface1.h</code> 中声明导出接口 <code>ExportInterface</code></li><li>在 <code>Interface1.cpp</code> 中实现 <code>ExportInterface</code></li><li>在 <code>GetInterface.h</code> 中增加导出接口 <code>GetInterface1</code></li><li>在 <code>GetInterface.cpp</code> 中实现 <code>GetInterface1</code></li><li>在 <code>InterfaceExe.cpp</code> 调用这两个接口得到接口指针</li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.h </span></span><br><span class="line"><span class="function">DLL_EXPORT InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.h </span></span><br><span class="line"><span class="function">DLL_EXPORT_GET InterfaceBase* <span class="title">GetInterface1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExportInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterfaceBase* base = GetInterface();</span><br><span class="line">    InterfaceBase* base1 = GetInterface1();</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(base);</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if1-&gt;Test4(0);</span></span><br><span class="line"></span><br><span class="line">    FreeInterface(if1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看，<code>GetInterface()</code> 相关的反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case5-getinterface-constructor-vftable.png" alt="case5-getinterface-constructor-vftable"></p><p>从上图可以发现，与 <code>情况 2</code> 是一样，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中，虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><p>再来看看 <code>GetInterface1()</code> 相关的反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case5-getinterface1-constructor-vftable.png" alt="case5-getinterface1-constructor-vftable"></p><p>从上图可以发现，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p>简单整理如下：</p><ul><li><p><code>GetInterface!GetInterface()</code> 内部会调用 <code>new Interface1</code>，进而导致 <code>Interface1</code> 的构造函数在 <code>GetInterface</code> 模块中被调用。对应的虚表及虚表中的函数地址都存储在 <code>GetInterface</code> 模块中。</p></li><li><p><code>GetInterface!GetInterface1()</code> 内部会调用 <code>Interface!ExportInterface()</code>，而 <code>Interface!ExportInterface()</code> 内部会调用 <code>new Interface1</code>， 最终 <code>Interface1</code> 的构造函数在 <code>Interface</code> 模块中被调用。对应的虚表及虚表中的函数地址都存储在 <code>Interface</code> 模块中。</p></li></ul><p>因此，可以得到这样的结论： <strong>虚表及虚表中的函数地址会跟构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中。</p><p>有了以上基础，就可以很顺利的回答之前的问题了，我们依次来看看每个问题。</p><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p><p><strong>答：</strong> 参考 <code>情况 1</code>，<code>Interface1</code> 与 <code>InterfaceBase</code> 的构造函数、虚表以及虚表中的函数都保存在  <code>GetInterface</code> 模块中。</p><blockquote><p><strong>小贴士：</strong> 可以推测，如果有另外一个类似 <code>GetInterface</code> 的模块，相应的内容在那个模块中也会生成一份。</p></blockquote></li></ul><ul><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p><p><strong>答：</strong> 参考 <code>情况 1</code>，虚表与构造函数一样保存在 <code>GetInterface</code> 模块中。</p></li></ul><ul><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p><p><strong>答：</strong> 不能。参考 <code>情况 2</code> 中提到的两种编译报错的情况。</p><p>在没有声明构造函数的情况下，编译器生成的构造函数代码和虚表都会保存在 <code>GetInterface</code> 模块中。</p><p>在构造函数调用时会初始化虚表指针，指向虚表。虚表需要记录每个虚函数的地址，而这些虚函数在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址，故报链接错误。</p></li></ul><ul><li><p>问题 4：如果在 <code>Interface1</code>  中声明了<strong>未导出</strong>的构造函数，上述代码能编译通过吗？</p><p><strong>答：</strong> 需要根据构造函数定义的位置判断</p><ul><li><p>如果构造函数的定义也在头文件中，则可以正常编译。</p><p>因为编译后构造函数的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果构造函数的定义在源文件中而且没导出，会报链接错误。</p><p>因为在 <code>GetInterface</code> 模块中调用 <code>new Interface</code> 的时候，会调用 <code>Interface</code> 的构造函数，但是在 <code>GetInterface</code> 模块中找不到其实现代码。</p></li></ul></li></ul><ul><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p><p><strong>答：</strong> 与 <code>问题 4</code> 一样，需要根据 <code>InterfaceBase::Test1()</code> 定义的位置判断</p><ul><li><p>如果 <code>InterfaceBase::Test1()</code> 的定义也在头文件中，则可以正常编译。</p><p>因为编译后 <code>InterfaceBase::Test1()</code> 的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果 <code>InterfaceBase::Test1()</code> 的定义在源文件中而且没导出，会报链接错误。</p><p><code>InterfaceBase::Test1()</code> 的实现代码保存在 <code>Interface</code> 模块中。<code>InterfaceBase</code> 的虚表需要记录 <code>InterfaceBase::Test1()</code> 的地址，而 <code>InterfaceBase::Test1()</code> 在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址，会报链接错误。</p></li></ul></li></ul><ul><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p><p>答： 与 <code>问题 4</code>、<code>问题 5</code> 一样，需要根据析构函数定义的位置判断</p><ul><li><p>如果析构函数的定义也在头文件中，则可以正常编译。</p><p>因为编译后析构函数的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果析构函数的定义在源文件中而且没导出，会报链接错误。</p><p>析构函数最终会保存在 <code>Interface</code> 模块中。当调用 <code>GetInterface</code> 模块中的  <code>FreeInterface()</code> 时，该函数内部会调用 <code>delete</code>，而 <code>delete</code> 内部会调用析构函数，但是在 <code>GetInterface</code> 模块中没有实现，会报链接错误。</p></li></ul><blockquote><p><strong>友情提示：</strong> </p><ol><li>如果基类的析构函数是虚函数，子类的析构函数即使不加 <code>virtual</code> 关键字也是虚的！</li><li>如果一个类被设计为基类并且其析构函数是非虚的，这是一个 <code>bad design</code>， 《effective c++》条款 7 中讲过，感兴趣的朋友可以参考</li></ol></blockquote></li></ul><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>我已经将以上几种情况对应的工程源码上传到个人仓库中了，可以到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part3-call-unexported-virtual-function-of-another-module" target="_blank" rel="noopener">这里</a>下载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>虚表及虚表中的函数地址会与构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中</li></ol><ol start="2"><li>如果 <code>classA</code> 所有函数都定义在头文件中，那么 <code>B</code> 模块不需要依赖 <code>A</code> 模块，因为 <code>classA</code> 的所有实现代码都在 <code>B</code> 中了</li></ol><ol start="3"><li><p>在构造函数调用时会初始化虚表指针，指向虚表。必须能解析每个虚函数的地址，否则会报链接错误。</p><p>务必注意报错的时机 —— <strong>在编译构造函数的时候报错，而不是编译虚函数调用代码的时候报错！</strong></p></li></ol><ol start="4"><li><p>如果在 <code>B</code> 模块中已经拿到了 <code>A</code> 模块中 <code>classA</code> 的对象指针，可以在 <code>B</code> 模块调用其虚函数，不需要关心虚函数是否导出。</p><p>既然已经拿到了对象指针，说明构造函数已经成功执行了，虚表已经保存好了虚函数的地址。</p></li></ol><ol start="5"><li><p>如果想在 <code>B</code> 模块中获取 <code>A</code> 模块中 <code>classA</code> 的对象，有两种方法：</p><ol><li><p><code>A</code> 模块导出一个返回 <code>classA</code> 对象的指针的接口，<code>B</code> 模块通过 <code>A</code> 模块的导出接口获取</p></li><li><p>直接在 <code>B</code> 模块中实例化 <code>classA</code> 对象。通过 <code>auto pA = new classA();</code> 或者 <code>classA a;</code></p></li></ol></li></ol><ol start="6"><li><p>如果想在 <code>B</code> 模块中<strong>直接</strong>实例化 <code>A</code> 模块中 <code>classA</code> 的对象，需要能在 <code>B</code> 模块中访问 <code>classA</code> 的构造函数，有两种方法：</p><ol><li><p><code>classA</code> 的构造函数是导出的 <strong>并且</strong> <code>B</code> 模块依赖 <code>A</code> 模块</p></li><li><p><code>classA</code> 的构造函数定义在头文件中（或者不声明构造函数，编译器会自动生成一个）</p></li></ol></li></ol><ol start="7"><li><p>如果 <code>A</code> 模块中 <code>classA</code> 的构造函数是未导出的，并且 <code>classA</code> 中有虚函数，要想在 <code>B</code> 模块中直接实例化 <code>classA</code>，需要满足：</p><ol><li><p>构造函数定义在头文件中</p></li><li><p>虚函数或者<strong>是导出的</strong>或者<strong>定义在头文件中</strong></p></li></ol></li></ol><ol start="8"><li>如果想在 <code>B</code> 模块中调用 <code>A</code> 模块中 <code>classA</code> 的成员函数（例如， <code>delete pA</code> 会调用 <code>classA</code> 的析构函数），那么 <code>classA</code> 的成员函数<ul><li>或者是虚的</li><li>或者是导出的</li><li>或者定义在头文件中</li></ul></li></ol><ol start="9"><li>如果链接错误是由找不到析构函数导致的，删除导致析构函数调用的代码，就不会报错了</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《effective c++》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在上篇文章 &lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/&quot;&gt;《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》&lt;/a&gt;中，我们明白了一个事实 —— 可以在不依赖外部模块的情况下通过类对象指针调用其&lt;strong&gt;虚函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是遗留了几个问题，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题 1：&lt;code&gt;Interface1&lt;/code&gt; 类中没有声明构造函数，编译器生成的构造函数保存在哪里？&lt;code&gt;GetInterface&lt;/code&gt; 模块还是 &lt;code&gt;Interface&lt;/code&gt; 模块？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 2：&lt;code&gt;Interface1&lt;/code&gt; 的虚表保存在哪里？&lt;code&gt;GetInterface&lt;/code&gt; 模块还是 &lt;code&gt;Interface&lt;/code&gt; 模块？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题 3：如果去掉 &lt;code&gt;Interface1&lt;/code&gt; 中虚函数的导出符号，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 4：如果在 &lt;code&gt;Interface1&lt;/code&gt;  中声明了未导出的构造函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 5：如果 &lt;code&gt;InterfaceBase::Test1()&lt;/code&gt; 不是纯虚函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 6：如果 &lt;code&gt;InterfaceBase&lt;/code&gt; 的析构函数不是虚函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文力求把这几个问题弄清楚。如果您对以上问题已经有了答案，可以跳过本文。&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="part3" scheme="https://bianchengnan.github.io/tags/part3/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/</id>
    <published>2024-07-27T06:37:07.000Z</published>
    <updated>2025-12-13T05:48:33.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一段日子，同事遇到了一个奇怪的现象 —— <code>B</code> 模块调用了 <code>A</code> 模块某个类的成员函数，没有依赖 <code>A</code> 模块，编译时没有报错。而 <code>C</code> 模块也调用了 <code>A</code> 模块中同一个类的成员函数，没有依赖 <code>A</code> 模块，编译时却报了链接错误。</p><p>简单语音沟通后觉得不太可能。用了 <code>A</code> 模块的函数，却不依赖 <code>A</code> 模块，有点儿不讲道理！</p><p>因为当时我没在电脑前，跟同事简单沟通了几个可以设置库依赖的位置，结果都没有发现对应的依赖项。</p><p>心里越发觉得不可思议，难道 <code>B</code> 模块是通过其它方式依赖 <code>A</code> 模块的？正常情况下，如果 <code>B</code> 模块依赖 <code>A</code> 模块，一定可以在 <code>B</code> 模块的导入表中看到 <code>A</code> 模块相关的记录。于是建议同事查看 <code>B</code> 模块的导入表，但是同事不太熟悉。因为项目比较急，遂建议同事在 <code>C</code> 模块中添加对 <code>A</code> 模块的依赖，先解决项目问题，后面有机会再调查具体原因。</p><p>直到最近才有时间调查这个问题，结果发现这个问题非常有意思 —— <code>B</code> 模块确实没有依赖 <code>A</code> 模块（<code>B</code> 模块的导入表中确实没发现 <code>A</code> 模块的相关项），但是 <code>B</code> 模块确实调用了 <code>A</code> 模块中的函数，而且不是通过 <code>LoadLibrary() + GetProcAddress()</code> 的方式调用的。</p><p>本文主要关注以下问题，如果你已经有了答案，可以跳过本文。</p><ul><li><code>B</code> 模块在什么情况下可以调用 <code>A</code> 模块中的函数，但是却不依赖 <code>A</code> 模块？</li></ul><a id="more"></a><blockquote><p><strong>约定：</strong></p><ol><li><p>本文不考虑通过 <code>GetProcAddress()</code> 获取函数指针后再调用的情况</p></li><li><p>虚函数表在本文中简称<strong>虚表</strong>，指向虚表的指针简称<strong>虚表指针</strong></p></li></ol></blockquote><p>为了更好的研究这个问题，我特意写了示例程序</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序由三个工程组成：接口模块、获取接口模块和主模块。</p><ul><li><p>接口模块 </p><p>对应的工程是 <code>Interface.vcxproj</code>，代码很简单，声明并实现了一些接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DLL_INTERFACE_EXPORT</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_INTERFACE_EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Interface1::Test1(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test2(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test3(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test4(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>获取接口模块</p><p>对应的工程是 <code>GetInterface.vcxproj</code>，依赖<strong>接口模块</strong>。代码非常简单，只暴露了一个接口，用来获取接口对象指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DLL_GETINTERFACE_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_GET __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_GET __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_GET InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DLL_EXPORT_GET <span class="keyword">void</span> <span class="title">FreeInterface</span><span class="params">(InterfaceBase*)</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_GETINTERFACE_EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GetInterface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeInterface</span><span class="params">(InterfaceBase* if1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> if1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>主模块</p><p>对应的工程是 <code>InterfaceExe.vcxproj</code>，只依赖<strong>获取接口模块</strong>，不依赖<strong>接口模块</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../GetInterface/GetInterface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterfaceBase* base = GetInterface();</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(base);</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    FreeInterface(if1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>示例工程已经上传到本篇博客对应的资料仓库里，感兴趣的小伙伴儿可以自行到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module" target="_blank" rel="noopener">这里</a>下载验证。</p><p>在以上代码中：</p><ol><li><p><code>if1-&gt;Test4()</code> <strong>会</strong>导致链接错误</p><p>报错信息如下：</p><p><code>LNK2019 无法解析的外部符号 &quot;__declspec(dllimport) public: void __cdecl Interface1::Test4(int)&quot; (__imp_?Test4@Interface1@@QEAAXH@Z)，该符号在函数 main 中被引用</code></p></li></ol><ol start="2"><li><p><code>if1-&gt;Test1()</code> <strong>不会</strong>导致链接错误。惊不惊喜？意不意外？</p><p>注释掉 <code>if1-&gt; Test4();</code> 即可顺利编译，所以可以确定 <code>if1-&gt;Test1()</code> 不会导致链接错误</p></li></ol><p>在解释之前，先回顾一下基础。</p><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><p>我之前写过一篇关于函数基础知识的总结—— <a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p>与当前问题相关的内容整理如下：</p><ul><li><p><code>B</code> 模块要想调用 <code>A</code> 模块中的函数，最重要的原则是：<code>B</code> 模块要能找到 <code>A</code> 模块函数的地址，一般情况下需要做两件事：</p><p><strong>首先</strong>，<code>A</code> 模块中的函数需要声明为导出的。导出的函数会记录在 <code>A</code> 模块的<strong>导出表</strong>中</p><p><strong>其次</strong>，通过头文件 + 库文件，让 <code>B</code> 模块依赖 <code>A</code> 模块。编译器会在 <code>B</code> 模块的<strong>导入表</strong>中添加对应项</p></li></ul><ul><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>虚函数调用是通过<strong>虚表</strong>实现的。大体调用过程如下：</p><ul><li><p>通过类对象找到虚表指针，进而找到虚表</p></li><li><p>根据头文件中虚函数的顺序得到索引</p></li><li><p>根据索引从虚表中取出函数地址进行调用</p></li></ul></li></ul><h2 id="简单解释"><a href="#简单解释" class="headerlink" title="简单解释"></a>简单解释</h2><p>下面我们尝试从虚函数的调用机制来理解编译器的行为：</p><ol><li><code>if1-&gt;Test4()</code> <strong>会</strong>导致链接错误<br>因为 <code>Test4()</code> 是普通成员函数，调用的时候，需要找到其地址。接口模块虽然导出了 <code>Test4()</code>，但是主模块并没有依赖接口模块。所以报链接错误很正常！</li></ol><ol start="2"><li><p><code>if1-&gt;Test1()</code> <strong>不会</strong>导致链接错误</p><p>已经得到了对象指针（<code>if1</code>），说明对象已经被构造好了，虚表指针已经指向了正确的虚表。因为 <code>Test1()</code> 是虚函数，调用 <code>Test1()</code> 是通过虚表进行的，直接到虚表对应的位置获取函数地址即可。 所以不会产生链接错误。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>如果 <code>B</code> 模块已经拿到了 <code>A</code> 模块中的类对象指针，通过该指针调用的类成员函数，</p><ul><li><p>如果调用的成员函数是<strong>普通函数</strong>，则 <code>B</code> 模块<strong>需要</strong>依赖 <code>A</code> 模块</p></li><li><p>如果调用的成员函数是<strong>虚函数</strong>，则 <code>B</code> 模块<strong>不需要</strong>依赖 <code>A</code> 模块</p></li></ul></li></ul><p>实际项目中遇到的正是这种情况：<code>B</code> 模块调用的是 <code>A</code> 模块中的虚函数，所以不需要依赖 <code>A</code> 模块；而 <code>C</code> 模块调用的是 <code>A</code> 模块中的普通成员函数，需要依赖 <code>A</code> 模块。至此，项目中的疑问算是彻底解开了。</p><p>这就完了？ 还有很多问题需要继续深挖……</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p></li><li><p>问题 4：如果在 <code>Interface1</code>  中声明了未导出的构造函数，上述代码能编译通过吗？</p></li><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p></li><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p></li></ul><p>争取在下一篇文章中把上面的坑都填上，<code>stay tuned~</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一段日子，同事遇到了一个奇怪的现象 —— &lt;code&gt;B&lt;/code&gt; 模块调用了 &lt;code&gt;A&lt;/code&gt; 模块某个类的成员函数，没有依赖 &lt;code&gt;A&lt;/code&gt; 模块，编译时没有报错。而 &lt;code&gt;C&lt;/code&gt; 模块也调用了 &lt;code&gt;A&lt;/code&gt; 模块中同一个类的成员函数，没有依赖 &lt;code&gt;A&lt;/code&gt; 模块，编译时却报了链接错误。&lt;/p&gt;
&lt;p&gt;简单语音沟通后觉得不太可能。用了 &lt;code&gt;A&lt;/code&gt; 模块的函数，却不依赖 &lt;code&gt;A&lt;/code&gt; 模块，有点儿不讲道理！&lt;/p&gt;
&lt;p&gt;因为当时我没在电脑前，跟同事简单沟通了几个可以设置库依赖的位置，结果都没有发现对应的依赖项。&lt;/p&gt;
&lt;p&gt;心里越发觉得不可思议，难道 &lt;code&gt;B&lt;/code&gt; 模块是通过其它方式依赖 &lt;code&gt;A&lt;/code&gt; 模块的？正常情况下，如果 &lt;code&gt;B&lt;/code&gt; 模块依赖 &lt;code&gt;A&lt;/code&gt; 模块，一定可以在 &lt;code&gt;B&lt;/code&gt; 模块的导入表中看到 &lt;code&gt;A&lt;/code&gt; 模块相关的记录。于是建议同事查看 &lt;code&gt;B&lt;/code&gt; 模块的导入表，但是同事不太熟悉。因为项目比较急，遂建议同事在 &lt;code&gt;C&lt;/code&gt; 模块中添加对 &lt;code&gt;A&lt;/code&gt; 模块的依赖，先解决项目问题，后面有机会再调查具体原因。&lt;/p&gt;
&lt;p&gt;直到最近才有时间调查这个问题，结果发现这个问题非常有意思 —— &lt;code&gt;B&lt;/code&gt; 模块确实没有依赖 &lt;code&gt;A&lt;/code&gt; 模块（&lt;code&gt;B&lt;/code&gt; 模块的导入表中确实没发现 &lt;code&gt;A&lt;/code&gt; 模块的相关项），但是 &lt;code&gt;B&lt;/code&gt; 模块确实调用了 &lt;code&gt;A&lt;/code&gt; 模块中的函数，而且不是通过 &lt;code&gt;LoadLibrary() + GetProcAddress()&lt;/code&gt; 的方式调用的。&lt;/p&gt;
&lt;p&gt;本文主要关注以下问题，如果你已经有了答案，可以跳过本文。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 模块在什么情况下可以调用 &lt;code&gt;A&lt;/code&gt; 模块中的函数，但是却不依赖 &lt;code&gt;A&lt;/code&gt; 模块？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="part2" scheme="https://bianchengnan.github.io/tags/part2/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/</id>
    <published>2024-07-12T20:37:07.000Z</published>
    <updated>2025-12-13T05:48:33.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近遇到了几个跟虚函数有关的问题，既有编译链接问题，又有运行问题，归根到底是基本功不扎实导致的问题。本文将会简单梳理一下函数相关的基本知识：</p><ul><li>函数是什么？</li><li>函数调用约定有哪些？有什么作用？</li><li>普通函数、类静态函数、类成员函数的区别是什么？</li><li>什么时候会调用构造函数，什么时候会调用析构函数？</li><li>调用虚函数与调用其它函数的区别是什么？</li><li><code>B</code> 模块如何调用 <code>A</code> 模块的函数？</li></ul><p>本文适合初学者，如果您已经有一定的开发经验，可以跳过本文。</p><a id="more"></a><h2 id="函数是什么？"><a href="#函数是什么？" class="headerlink" title="函数是什么？"></a>函数是什么？</h2><p>函数其实就是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>。一般情况下，函数编译后的二进制代码会被存储在可执行文件（又叫 <code>Portable Executive</code>，简称  <code>PE</code> ）的代码段中，程序启动时会加载到内存中。</p><p>有几个关键点需要牢记于心：</p><ol><li>每个函数的二进制代码都会存储在对应的模块中，相对模块基址一定的偏移处</li><li>模块加载到内存后会占据一段内存空间，这段内存空间中包含当前模块的函数、全局变量等</li><li>函数的虚拟地址是由 <strong>模块基址+函数相对于模块基址的偏移</strong> 决定的</li><li><strong>模块中函数地址相对于模块基址的偏移不会改变</strong>，模块的基址发生变化后，函数地址也会跟着变</li></ol><p>下图是用 <code>IDA</code> 查看 <code>ntoskrnl.exe</code> 中的函数情况。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/functions-in-module.png" alt="functions-in-module"></p><p><code>ntoskrnl.exe</code> 的基址是 <code>0x00000001 40000000</code>，每个函数相对于模块有一定的偏移。比如，<code>NtSetEvent</code> 相对于模块基址的偏移是 <code>0x00000001 406B2B60 - 0x00000001 40000000 = 0x006B2B60</code>。</p><p>如果下次启动的时候，<code>ntoskrnl.exe</code> 基址变了，<code>NtSetEvent</code> 的地址也会跟着变，但是相对于模块基址的偏移不会变。</p><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>函数调用约定有哪些？有什么作用？</p><p>在 <code>c++</code> 中，常用的调用约定有  <code>__cdecl</code>，<code>__stdcall</code>， <code>__fastcall</code>， <code>__thiscall</code>。</p><p><code>__cdecl</code> 是 <code>vs</code> 工程属性中默认的调用约定（可以在 <code>vs</code> 工程属性中设置，如下图），<code>__thiscall</code> 是类成员函数默认的调用约定，<code>Windows API</code> 一般会显式使用 <code>__stdcall</code>。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/set-default-calling-convention.png" alt="set-default-calling-convention"></p><p>调用约定的主要作用：</p><ul><li>影响函数名称，每种调用约定生成的函数名称不一样</li><li>影响参数传递方式</li><li>影响谁来平衡调用栈（调用者还是被调用者）</li></ul><h3 id="x86-程序"><a href="#x86-程序" class="headerlink" title="x86 程序"></a>x86 程序</h3><p>在 <code>x86</code> 程序中有各种调用约定，我简单的整理成了表格，如下：</p><table><thead><tr><th>调用约定</th><th>参数传递方式</th><th>谁来平衡堆栈</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-160" target="_blank" rel="noopener">__cdecl</a></td><td>所有参数通过栈传递，从右向左依次入栈，<code>ebp + 8</code> 指向第一个参数</td><td>调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/stdcall?view=msvc-160" target="_blank" rel="noopener">__stdcall</a></td><td>与 <code>__cdecl</code> 调用约定一样</td><td>被调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-160" target="_blank" rel="noopener">__fastcall</a></td><td>前两个 <code>DWORD</code> 类型的参数通过 <code>ecx</code>, <code>edx</code> 传递，其余参数从右向左依次入栈</td><td>被调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/thiscall?view=msvc-160" target="_blank" rel="noopener">__thiscall</a></td><td>对象指针通过 <code>ecx</code> 传递，其余参数与 <code>__cdecl</code> 调用约定一样通过栈传递</td><td>被调用者</td></tr></tbody></table><blockquote><p><strong>说明：</strong> <a href="https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a> 提到了更多种调用约定，感兴趣的小伙伴儿可以自行查看</p></blockquote><p>​                                                                                                                                                                                                                                                                                                                                         关于名字修饰规则可以参考《软件调试》第 <code>1</code> 版 第 <code>25</code> 章，<code>740</code> 页。</p><blockquote><p><strong>小贴士：</strong> 可以使用 <code>vs</code> 自带的工具 <code>undname.exe</code> 查看修饰前的函数名</p></blockquote><h3 id="x64-程序"><a href="#x64-程序" class="headerlink" title="x64 程序"></a>x64 程序</h3><p>在 <code>x64</code> 程序中只有一种调用约定 —— <code>__fastcall</code>。即使显式指定了调用约定，最后也会按 <code>__fastcall</code> 生成代码。</p><p>参数传递方式如下表（摘录自<a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a>）：</p><table><thead><tr><th align="left">Parameter type</th><th align="left">fifth and higher</th><th align="left">fourth</th><th align="left">third</th><th align="left">second</th><th align="right">leftmost</th></tr></thead><tbody><tr><td align="left">floating-point</td><td align="left">stack</td><td align="left">XMM3</td><td align="left">XMM2</td><td align="left">XMM1</td><td align="right">XMM0</td></tr><tr><td align="left">integer</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left">Aggregates (8, 16, 32, or 64 bits) and <strong><code>__m64</code></strong></td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left">Other aggregates, as pointers</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left"><strong><code>__m128</code></strong>, as a pointer</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr></tbody></table><p>各种典型情况下参数传递方式列举如下（摘录自同一个 <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a>，注释按习惯调整到上方了）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a in RCX, b in RDX, c in R8, d in R9, f then e pushed on stack</span></span><br><span class="line">func1(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in XMM0, b in XMM1, c in XMM2, d in XMM3, f then e pushed on stack</span></span><br><span class="line">func2(<span class="keyword">float</span> a, <span class="keyword">double</span> b, <span class="keyword">float</span> c, <span class="keyword">double</span> d, <span class="keyword">float</span> e, <span class="keyword">float</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in RCX, b in XMM1, c in R8, d in XMM3, f then e pushed on stack</span></span><br><span class="line">func3(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> c, <span class="keyword">float</span> d, <span class="keyword">int</span> e, <span class="keyword">float</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3,</span></span><br><span class="line"><span class="comment">// ptr to f pushed on stack, then ptr to e pushed on stack</span></span><br><span class="line">func4(__m64 a, __m128 b, struct c, <span class="keyword">float</span> d, __m128 e, __m128 f);</span><br></pre></td></tr></table></figure><h2 id="各种类型的函数比较"><a href="#各种类型的函数比较" class="headerlink" title="各种类型的函数比较"></a>各种类型的函数比较</h2><p>普通函数、类静态函数、类成员函数的区别是什么？</p><p>平时开发过程中，经常遇到的函数有普通函数、类静态成员函数、类成员函数（构造函数、析构函数等）。</p><p>它们的共同特点是：它们都是函数，编译后都是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>，都会保存在某个模块中。</p><p>它们最主要的区别在调用的写法上：</p><ul><li><p>调用普通函数，直接通过函数名即可</p></li><li><p>构造函数、析构函数会被自动调用</p><blockquote><p><strong>说明：</strong> 虽然是自动调用，其实是编译器生成了调用代码，不用我们手动写而已</p></blockquote></li><li><p>调用类成员函数的时候，需要通过类对象或类对象指针进行调用</p></li><li><p>调用类静态成员函数的时候需要加上类名限定</p><blockquote><p><strong>说明：</strong> 也可以通过类对象或类对象指针进行调用，编译器会自动推断类型</p></blockquote></li></ul><p>以下示例代码展示了这三种函数的调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">T1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">(CDemo*, <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T1(<span class="number">0</span>);</span><br><span class="line">    CDemo::T1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CDemo demo;</span><br><span class="line">    demo.T2(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    T2(&amp;demo, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>x64</code> 程序中，<code>T1()</code> 与 <code>CDemo::T1()</code> ，<code>T2()</code> 与 <code>CDemo::T2()</code> 是等价的，会生成同样的汇编代码。如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/function-call-disassembly-x64.png" alt="function-call-disassembly-x64"></p><p>在 <code>x86</code> 程序中，由于调用约定不同，<code>T2()</code> 与 <code>CDemo::T2()</code> 的参数传递方式不同，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/function-call-disassembly-x86.png" alt="function-call-disassembly-x86"></p><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>什么时候会调用构造函数，什么时候会调用析构函数？</p><ul><li><p>当一个类对象被构造出来的时候，会调用构造函数</p><p>比如有一个名为 <code>CTest</code> 的类。下面两句代码都会导致类构造函数被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTest t1;</span><br><span class="line">  CTest* p = <span class="keyword">new</span> CTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个类对象的生命周期结束的时候，会调用析构函数</p><p>一个对象的生命周期什么时候结束呢？有两种情况：</p><ol><li>变量超出作用域</li><li>显式调用 <code>delete</code> </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTest t1;</span><br><span class="line">  CTest* p = <span class="keyword">new</span> CTest();</span><br><span class="line">  <span class="keyword">delete</span> p; <span class="comment">// delete 内部会调用析构函数</span></span><br><span class="line">&#125; <span class="comment">// t1 会在这里被析构</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>敲黑板：</strong> 如果不在 <code>B</code> 模块中实例化 <code>A</code> 模块中的类对象，那么对 <code>B</code> 模块而言 <code>A</code> 模块的构造函数不必是导出的。析构函数也是一样的道理。</p></blockquote><h2 id="虚函数-vs-其它函数"><a href="#虚函数-vs-其它函数" class="headerlink" title="虚函数 vs 其它函数"></a>虚函数 vs 其它函数</h2><p>调用虚函数与调用其它函数的区别是什么？</p><p>我之前写过一篇关于虚函数的总结 —— <a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a>（如果图挂了可以看<a href="https://zhuanlan.zhihu.com/p/240765167" target="_blank" rel="noopener">这里</a>）。</p><p>介绍了虚函数的相关内容：虚表都包含哪些内容、虚表指针的初始化时机、虚函数是如何支持多态的。这里再简单总结一下：</p><ul><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>虚函数调用是通过虚表实现的。大体调用过程如下：</p><ul><li>通过类对象找到虚表指针，进而找到虚表</li><li>根据头文件中虚函数的顺序得到索引</li><li>根据索引从虚表中取出函数地址进行调用</li></ul></li></ul><p>调用虚函数与调用其它函数最主要的区别是：</p><p>调用普通函数的时候，会直接跳转到函数首地址；调用虚函数的时候，会通过虚表跳转到函数首地址。</p><h2 id="跨模块调用"><a href="#跨模块调用" class="headerlink" title="跨模块调用"></a>跨模块调用</h2><p><code>B</code> 模块如何调用 <code>A</code> 模块中的函数？</p><p><code>B</code> 模块要想调用 <code>A</code> 模块中的函数，最重要的原则是：<code>B</code> 模块要能找到 <code>A</code> 模块中的函数地址，一般情况下需要做两件事：</p><p><strong>首先</strong>，<code>A</code> 模块中的函数需要声明为导出的。导出的函数会记录在 <code>A</code> 模块的<strong>导出表</strong>中</p><p><strong>其次</strong>，通过头文件 + 库文件，让 <code>B</code> 模块依赖 <code>A</code> 模块。编译器会在 <code>B</code> 模块的<strong>导入表</strong>中添加对应项</p><blockquote><p><strong>说明：</strong> 还可以通过 <code>GetAddressProc()</code> 找到函数地址进行调用</p></blockquote><p><code>B</code> 模块依赖 <code>A</code> 模块，在 <code>vs</code> 中有三种设置方法：</p><h2 id="解决库依赖的三种方法"><a href="#解决库依赖的三种方法" class="headerlink" title="解决库依赖的三种方法"></a>解决库依赖的三种方法</h2><ol><li><p>在代码中使用 <code>#pragma comment(lib, libA)</code> 进行依赖</p><p>可以不修改工程配置，直接在代码中设置依赖</p></li></ol><ol start="2"><li><p>在 <code>B</code> 模块对应项目的链接器设置中，添加对项目 <code>A</code> 的依赖</p><p>这是比较常规的做法，设置方法如下图：<img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/add-lib-in-project-link-option.png" alt="add-lib-in-project-link-option"></p></li></ol><ol start="3"><li><p>在 <code>B</code> 模块对应项目的引用配置中添加对项目 <code>A</code> 的引用</p><p>此方法最简单，最省心，甚至都不用考虑被依赖的库文件的生成路径！<img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/add-project-reference.png" alt="add-project-reference"></p></li></ol><blockquote><p><strong>注意：</strong> 前两种方法，可能需要在附加库目录中配置 <code>libA</code> 的路径，第三种方法不用。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>函数是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>，会被存储在模块中的某个位置，<strong>相对于模块基址的偏移不会改变</strong>，模块的基址发生变化后，函数地址也会跟着变</li><li>调用约定会影响编译后的函数名、参数传递方式、谁来平衡调用栈</li><li><code>x86</code> 程序有各种调用约定，<code>x64</code> 程序只有 <code>__fastcall</code> 一种调用约定</li><li>调用函数的两个关键点是：<ul><li>找到函数地址</li><li>明确参数传递方式（由调用约定决定）</li></ul></li><li>调用外部模块的函数，需要依赖对应的库。在 <code>vs</code> 中解决库依赖有三种方法：<ul><li>在代码中使用 <code>#pragma comment(lib, libA)</code> 进行依赖</li><li>在 <code>B</code> 模块对应项目的链接器设置中，添加对项目 <code>A</code> 的依赖</li><li>在 <code>B</code> 模块对应项目的引用配置中添加对项目 <code>A</code> 的引用</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>《软件调试》第一版 </p></li><li><p>调用约定相关参考链接</p><ul><li><a href="https://learn.microsoft.com/en-us/cpp/cpp/calling-conventions?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/cpp/calling-conventions?view=msvc-160</a></li><li><a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160</a></li><li><a href="https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近遇到了几个跟虚函数有关的问题，既有编译链接问题，又有运行问题，归根到底是基本功不扎实导致的问题。本文将会简单梳理一下函数相关的基本知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数是什么？&lt;/li&gt;
&lt;li&gt;函数调用约定有哪些？有什么作用？&lt;/li&gt;
&lt;li&gt;普通函数、类静态函数、类成员函数的区别是什么？&lt;/li&gt;
&lt;li&gt;什么时候会调用构造函数，什么时候会调用析构函数？&lt;/li&gt;
&lt;li&gt;调用虚函数与调用其它函数的区别是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 模块如何调用 &lt;code&gt;A&lt;/code&gt; 模块的函数？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文适合初学者，如果您已经有一定的开发经验，可以跳过本文。&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="part1" scheme="https://bianchengnan.github.io/tags/part1/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（下）</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/</id>
    <published>2024-06-08T09:39:23.000Z</published>
    <updated>2025-12-13T05:48:33.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在前面两篇文章中，应该算是彻底理清了项目中存在的两个问题。感兴趣的小伙伴儿可以参考<a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1">《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》</a>和 <a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2">《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）》</a>。</p><p>在上篇文章的末尾提到一种情况</p><blockquote><p>如果在 <code>LoadDlls.exe</code> 中也显式加载了 <code>dll3.dll</code>，还会不会崩溃呢？答案是<strong>可能崩溃，也可能不崩溃</strong>。</p><p>因为 <code>RegisterInitCallback()</code>内部更新数据时使用的是 <code>map.insert()</code>，这会导致一个问题 —— 如果 <code>map</code> 中已经存在相同的 <code>key</code>，那么 <code>insert()</code> 会失败，不会更新数据。</p><p>试想，如果显式加载 <code>dll3.dll</code> 成功，但是 <code>dll3.dll</code> 的基址变了。<code>map</code> 中保存的还是旧的无效地址，而不是新函数地址。</p><p>如果 <code>dll3.dll</code> 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常<strong>“幸运”</strong>的正常运行。 </p></blockquote><p>本文通过实战来验证上文中的结论，什么情况下会崩溃，什么情况下不崩溃。</p><a id="more"></a><h2 id="显式加载-dll3-dll"><a href="#显式加载-dll3-dll" class="headerlink" title="显式加载 dll3.dll"></a>显式加载 dll3.dll</h2><p>修改 <code>LoadDlls</code> 工程中的 <code>main()</code> 函数代码，使其加载 <code>dll1.dll</code>、<code>dll2.dll</code> 和 <code>dll3.dll</code>。修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="string">"dll3.dll"</span>, <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本以为这样修改后，应该偶尔会崩溃（因为默认开启了 <code>ASLR</code>，模块的加载基址应该会随机才对）。结果发现，每次运行都不崩溃，而且功能一切正常，着实有些出乎意料。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/function-normal.png" alt="function-normal"></p><p>看来 <code>dll3.dll</code> 每次都能加载到上一次被加载的基址。那怎么才能让 <code>dll3.dll</code> 加载到其它基址呢？</p><h2 id="改变加载基址"><a href="#改变加载基址" class="headerlink" title="改变加载基址"></a>改变加载基址</h2><p>最朴素的想法是，如果在显式加载 <code>dll3.dll</code> 之前，又加载了很多其它 <code>dll</code>，把原本 <code>dll3.dll</code> 加载的基址占用掉，那么再次加载 <code>dll3.dll</code> 的基址肯定会发生变化，大概率会崩溃。</p><p>按照这个思路，修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="string">"dll4.dll"</span>, <span class="string">"dll3.dll"</span>, <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完成后，把 <code>dll1.dll</code> 复制一份，修改名字为 <code>dll4.dll</code>，然后运行 <code>LoadDlls.exe</code>，果然崩溃了。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/app-crashed.png" alt="app-crashed"></p><blockquote><p><strong>小提示：</strong> 如果删除 <code>dll4.dll</code>，再次运行程序，又不崩溃了</p></blockquote><p>调查一下崩溃原因，看看是不是跟我们预期的一样。</p><h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><p>用 <code>windbg</code> 打开转储文件后，点击 <code>!analyze -v</code>，分析结果如下：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/windbg-analyze-v.png" alt="windbg-analyze-v"></p><p>可以发现在执行 <code>movsxd rax,dword ptr [rax+4]</code> 的时候崩溃了，而且这段反汇编代码属于 <code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush()</code>。在 <code>windbg</code> 中查看相关反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-disassembly-of-flush.png" alt="view-disassembly-of-flush"></p><p>从上图可知，<code>rax</code> 的值最开始来源于 <code>rsp+0x50</code>（<code>mov rax, qword ptr [rsp+50h]</code>），而 <code>rsp+0x50</code> 的值又来源于 <code>rcx</code>（<code>mov qword ptr [rsp+8], rcx</code>，<code>sub rsp, 48h</code>）。</p><p>在遍历调用 <code>s_init_callbacks</code> 保存的回调函数的时候并不会使用 <code>rcx</code>，因此 <code>rcx</code> 的值是是随机的，那么使用了 <code>rcx</code> 而崩溃是可以理解的。</p><p>还有一个小问题：为什么 <code>dll2!Init()</code> 会调用 <code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush()</code> 呢？</p><h2 id="进一步调查"><a href="#进一步调查" class="headerlink" title="进一步调查"></a>进一步调查</h2><p>使用命令 <code>dx dll2!s_init_callbacks</code> 查看  <code>dll2!s_init_callbacks</code> 的内容，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-s_init_callbacks.png" alt="view-s_init_callbacks"></p><p>可以发现 <code>dll2!s_init_callbacks</code> 中保存的函数地址是 <code>0x7ffd 929e12e4</code>，对应的函数是 <code>dll4!@ILT+735(?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ)</code>，该函数最终会调用<code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush</code>。</p><p>使用 <code>lmm dll*</code> 查看相关模块加载情况，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-modules.png" alt="view-modules"></p><p>从上图可知，<code>dll4.dll</code> 的基址与已经卸载的 <code>dll3.dll</code> 的基址是一样的，都是 <code>00007ffd 929d0000</code>，新加载的 <code>dll3.dll</code> 的基址已经变成了 <code>00007ffd 8c540000</code>。</p><p><code>s_init_callbacks</code> 中保存的函数地址相对于模块基址的偏移是 <code>0x7ffd 929e12e4 - 00007ffd 929d0000 = 0x112e4</code>，换算成在 <code>dll3.dll</code> 中的地址是 <code>0x00007ffd 8c540000 + 0x112e4 = 0x00007ffd 8c5512e4</code>。在 <code>windbg</code> 中使用 <code>ln 0x00007ffd8c5512e4</code> 查看于该地址对应的符号，输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; ln <span class="number">0x00007ffd8c5512e4</span></span><br><span class="line">Browse <span class="keyword">module</span></span><br><span class="line">Set bu breakpoint</span><br><span class="line"></span><br><span class="line">(<span class="number">00007f</span>fd`<span class="number">8</span>c5512e4)   dll3!ILT+<span class="number">735</span>(?Dll3InitCallbackYAXXZ)   |  (<span class="number">00007f</span>fd`<span class="number">8</span>c5512e9)   dll3!ILT+<span class="number">740</span>(?flush?$basic_ostreamDU?$char_traitsDstdstdQEAAAEAV12XZ)</span><br><span class="line">Exact matches:</span><br></pre></td></tr></table></figure><p>可以发现与 <code>dll3!ILT+735(?Dll3InitCallbackYAXXZ)</code> 完全匹配。</p><p>至此，所有疑问都已经解开了。<code>dll3.dll</code> 加载的时候会注册回调函数，由于异常 <code>dll3.dll</code> 会被自动卸载，但是注册回调函数并没有取消注册，<code>dll4.dll</code> 紧接着被加载到了 <code>dll3.dll</code> 旧基址，再次加载 <code>dll3.dll</code>，新的 <code>dll3.dll</code> 被加载到了其他位置。<code>dll3.dll</code> 最开始注册的回调函数变成了 <code>dll4.dll</code> 中的函数。</p><p>因为这是实际项目中遇到的问题，非常有代表性，而且崩溃的代码与业务代码毫不相干，很难查！</p><p>总结下来，主要有两大问题：</p><ol><li>在全局变量的构造函数中调用 <code>LoadLibrary()</code> 加载新的 <code>dll</code>，这是很危险的操作，应该尽量避免。</li><li>当使用 <code>insert()</code> 而不是 <code>operator[]</code> 向 <code>map</code> 中插入数据时，如果对应的 <code>key</code> 已经存在，不会更新数据。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>lm</code> 可以显示模块信息（包括已经卸载的模块信息），<code>lmm dll*</code> 可以显示以 <code>dll</code> 开头的模块</li><li><code>map.insert()</code> 在插入新数据时，如果发现对应的 <code>key</code> 已经存在，会直接返回 <code>false</code>，而不会更新数据。<code>operator []</code> 会强制更新数据</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在前面两篇文章中，应该算是彻底理清了项目中存在的两个问题。感兴趣的小伙伴儿可以参考&lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1&quot;&gt;《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》&lt;/a&gt;和 &lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2&quot;&gt;《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在上篇文章的末尾提到一种情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果在 &lt;code&gt;LoadDlls.exe&lt;/code&gt; 中也显式加载了 &lt;code&gt;dll3.dll&lt;/code&gt;，还会不会崩溃呢？答案是&lt;strong&gt;可能崩溃，也可能不崩溃&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;RegisterInitCallback()&lt;/code&gt;内部更新数据时使用的是 &lt;code&gt;map.insert()&lt;/code&gt;，这会导致一个问题 —— 如果 &lt;code&gt;map&lt;/code&gt; 中已经存在相同的 &lt;code&gt;key&lt;/code&gt;，那么 &lt;code&gt;insert()&lt;/code&gt; 会失败，不会更新数据。&lt;/p&gt;
&lt;p&gt;试想，如果显式加载 &lt;code&gt;dll3.dll&lt;/code&gt; 成功，但是 &lt;code&gt;dll3.dll&lt;/code&gt; 的基址变了。&lt;code&gt;map&lt;/code&gt; 中保存的还是旧的无效地址，而不是新函数地址。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;dll3.dll&lt;/code&gt; 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常&lt;strong&gt;“幸运”&lt;/strong&gt;的正常运行。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文通过实战来验证上文中的结论，什么情况下会崩溃，什么情况下不崩溃。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="全局变量" scheme="https://bianchengnan.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/</id>
    <published>2024-05-12T08:39:23.000Z</published>
    <updated>2025-12-13T05:48:33.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在<a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1">上篇文章《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》</a>中，解决了由于全局变量初始化顺序不对导致的崩溃问题。但是代码里还有一处非常隐蔽的 <code>bug</code>，今天继续介绍一下这个问题及对应的解决方法。</p><a id="more"></a><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>在上篇文章代码的基础上，修改 <code>LoadDlls</code> 工程中的 <code>main()</code> 函数代码，使其加载 <code>dll1.dll</code> 和 <code>dll2.dll</code>（上篇文章中只加载了 <code>dll1.dll</code>）。修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="comment">/*"dll3.dll",*/</span> <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="keyword">auto</span> loaded_module_map = LoadPlugins(plugins);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin done, press any key to init plugins."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">    InitPlugins(loaded_module_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直接运行崩溃了"><a href="#直接运行崩溃了" class="headerlink" title="直接运行崩溃了"></a>直接运行崩溃了</h2><p>运行完 <code>LoadPlugins()</code> 后，点击任意按键继续运行，会继续执行 <code>InitPlugins()</code>，程序会在此函数中崩溃。因为我设置 <code>procdump</code> 为 <code>JIT</code> 调试器（具体设置方法可以参考<a href="https://bianchengnan.github.io/articles/process-dump-tools-you-should-know/">这篇文章</a>），程序崩溃后会自动调用 <code>procdump</code> 保存崩溃转储文件。</p><p>用 <code>windbg</code> 打开转储文件，无脑点击 <code>!analyze -v</code>，让 <code>windbg</code> 帮我们自动分析，分析结果如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/exception-when-excute-from-unloaded-dll3.png" alt="exception-when-excute-from-unloaded-dll3"></p><p>从上图中的<strong>调用栈</strong>基本可以确定在执行 <code>dll3.dll</code> 中的代码时发生了异常。</p><p>而且这次的异常不是因为<strong>读/写</strong>非法地址导致的，而是执行到非法地址导致的（注意红色高亮部分的提示 <code>Attempt to execute non-executable address 00007ffbdd9812e4</code>）。</p><p>可以猜测 <code>00007ffbdd9812e4</code> 是属于 <code>dll3.dll</code> 的（可以通过 <code>!address 00007ffbdd9812e4</code> 验证），而且当执行到 <code>00007ffbdd9812e4</code> 的时候，<code>dll3.dll</code> 已经被卸载了（注意底部红色高亮部分的 <code>Unloaded</code> 关键字）。</p><p>使用 <code>!address 00007ffbdd9812e4</code> 查看该地址的信息，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/address-00007ffbdd9812e4.png" alt="address-00007ffbdd9812e4"></p><p>从上图可知，<code>00007ffbdd9812e4</code> 确实是属于 <code>dll3.dll</code> 的，但是 <code>dll3.dll</code> 已经被卸载了。<code>00007ffbdd9812e4</code> 所在的页面是 <code>MEM_FREE</code> 的，而且是 <code>PAGE_NOACCESS</code> 的。</p><p>但是，程序为什么会执行到一个已经被卸载的模块中的地址呢？</p><h2 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h2><p>从调用栈可以得知，<code>dll3.dll</code> 中的函数是由 <code>dll2!Init()</code> 调用的， 通过查看  <code>dll2!Init()</code> 源码，可以发现 <code>dll2!Init()</code> 函数中会遍历 <code>s_init_callbacks</code>。在 <code>windbg</code> 中输入<code>dx dll2!s_init_callbacks</code> 查看其内容，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/view-s_init_callbacks.png" alt="view-s_init_callbacks"></p><p>可以发现，<code>s_init_callbacks</code> 中只有一项，是 <code>dll3.dll</code> 中的函数。</p><p>根据源码可知，<code>dll3.dll</code> 在加载的时候会自动调用 <code>dll2!RegisterInitCallback()</code> 注册回调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterInitCallback(<span class="string">"dll3"</span>, Dll3InitCallback);</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure><p>可以推理，<code>s_init_callbacks</code> 中的函数是 <code>dll3!Dll3InitCallback</code>。</p><p>加载 <code>dll3.dll</code> 的调试符号后，查看调用栈，可以证实我们的猜想。如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/compare-callstacks-after-reload-dll3-symbol.png" alt="compare-callstacks-after-reload-dll3-symbol"></p><p>根据源码可知，<code>dll3.dll</code> 在加载的时候还会自动调用 <code>RegisterCallback()</code>，相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterCallback(<span class="string">"dll3"</span>, Dll3Callback);</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure><p>因为调用 <code>RegisterCallback()</code> 的时候发生了异常（在<a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1">上篇文章</a>中已经分析过了），导致 <code>dll3.dll</code> 加载失败，<code>dll3.dll</code> 会被自动<strong>卸载</strong> 。但是通过 <code>RegisterInitCallback()</code> 注册的回调函数已经保存在了 <code>dll2!s_init_callbacks</code> 中，没有被清除。</p><p>当后面调用 <code>dll2!Init()</code> 时，会调用 <code>dll3.dll</code> 注册到  <code>dll2!s_init_callbacks</code> 中的函数（<code>Dll3InitCallback</code>），因为 <code>dll3.dll</code> 已经被卸载了，对应的函数地址也无效了，也就会发生上文中的异常。</p><h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h2><p>如果在 <code>LoadDlls.exe</code> 中也显式加载了 <code>dll3.dll</code>，还会不会崩溃呢？答案是<strong>可能崩溃，也可能不崩溃</strong>。</p><p>因为 <code>RegisterInitCallback()</code>内部更新数据时使用的是 <code>map.insert()</code>，这会导致一个问题 —— 如果 <code>map</code> 中已经存在相同的 <code>key</code>，那么 <code>insert()</code> 会失败，不会更新数据。</p><p>试想，如果显式加载 <code>dll3.dll</code> 成功，但是 <code>dll3.dll</code> 的基址变了。<code>map</code> 中保存的还是旧的无效地址，而不是新函数地址。</p><p>如果 <code>dll3.dll</code> 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常<strong>“幸运”</strong>的正常运行。 </p><p>要想规避这种问题，可以换一种写法，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterInitCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//s_init_callbacks.insert(std::make_pair(key, callback));</span></span><br><span class="line">    s_init_callbacks[key] = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>调试由于模块被卸载导致的异常，其实很简单 —— 直接在 <code>windbg</code> 中使用 <code>!analyze -v</code> 基本上就可以定位到问题了</p></li><li><p>这次的崩溃，直接原因在于模块被意外的卸载了，归根结底还是代码不规范导致的</p></li><li><p>如果 <code>map</code> 中想保存最新数据，那么不要使用 <code>map.insert</code>，而要使用 <code>operater []</code></p></li><li><p><code>map.insert()</code> 在插入新数据时，如果发现对应的 <code>key</code> 已经存在，会直接返回 <code>false</code>，而不会更新数据。<code>operator []</code> 会强制更新数据</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1&quot;&gt;上篇文章《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》&lt;/a&gt;中，解决了由于全局变量初始化顺序不对导致的崩溃问题。但是代码里还有一处非常隐蔽的 &lt;code&gt;bug&lt;/code&gt;，今天继续介绍一下这个问题及对应的解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="全局变量" scheme="https://bianchengnan.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/</id>
    <published>2024-03-23T07:39:23.000Z</published>
    <updated>2025-12-13T05:48:33.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近又遇到了一个程序功能不正常的问题，深入调查后发现与全局变量初始化顺序有非常大的关系，只不过这次更加隐蔽。</p><p>之前总结了两篇与全局变量初始化顺序有关的文章，感兴趣的小伙伴儿可以参考<a href="https://bianchengnan.github.io/articles/debugging-dll-load-failure-caused-by-global-variable-initialize-dependency/">《调试实战 | dll 加载失败之全局变量初始化篇》</a> 和 <a href="https://bianchengnan.github.io/articles/global-variable-initialization-order-investigation/">《调试实战 | 全局变量初始化顺序探究》</a>。</p><a id="more"></a><p>在排查错误之前先简单介绍一下相关代码。</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序一共包含 <code>4</code> 个工程：<code>LoadDlls, dll1, dll2, dll3</code>。</p><ul><li><p>主程序 <code>LoadDlls.exe</code> 会加载 <code>dll1.dll</code></p></li><li><p><code>dll1.dll</code> 隐式依赖了 <code>dll2.dll</code>，所以 <code>dll1.dll</code> 加载的时候会自动加载 <code>dll2.dll</code></p></li><li><p><code>dll2.dll</code> 中的全局变量 <code>s_culprit</code> 的构造函数会加载 <code>dll3.dll</code></p></li><li><p><code>dll3.dll</code> 加载的时候会自动调用 <code>dll2.dll</code> 的导出函数 <code>RegisterInitCallback()</code> 和 <code>RegisterCallback()</code></p></li></ul><p>下面是每个工程的关键代码</p><ul><li><p><code>src/common/autorunner.h</code> </p><p>该文件是公共头文件，实现了自动注册逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// autorunner.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoRunner</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AutoRunner(<span class="keyword">void</span> (*func)())</span><br><span class="line">    &#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_CAT(s1, s2) s1 ## s2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_WITH_LINE(name, <span class="meta-keyword">line</span>) STR_CAT(name, <span class="meta-keyword">line</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGIN_AUTO_RUN static AutoRunner NAME_WITH_LINE(s_auto_runner_, __LINE__) ([]()&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END_AUTO_RUN  &#125;);</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>LoadDlls</code> </p><p>该工程只有一个源文件，用来模拟加载各种插件。对应的源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadDlls.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFN_Init)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, HMODULE&gt; LoadPlugins(<span class="keyword">const</span> <span class="keyword">char</span>* plugins[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, HMODULE&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; ; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* plugin = plugins[idx];</span><br><span class="line">        <span class="keyword">if</span> (plugin == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HMODULE <span class="keyword">module</span> = LoadLibraryA(plugin);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD lastError = GetLastError();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load ［"</span> &lt;&lt; plugin &lt;&lt; <span class="string">"] failed with error "</span> &lt;&lt; lastError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[plugin] = <span class="keyword">module</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitPlugins</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, HMODULE&gt;&amp; loaded_plugins)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : loaded_plugins)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> init_entry = (PFN_Init)GetProcAddress(it.second, <span class="string">"Init"</span>);</span><br><span class="line">        <span class="keyword">if</span> (init_entry != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            init_entry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="comment">/*"dll2.dll", "dll3.dll",*/</span> <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> loaded_module_map = LoadPlugins(plugins);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin done, press any key to init plugins."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">    InitPlugins(loaded_module_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>dll1</code> </p><p>该工程非常简单，什么有用的事情都没做，但是会依赖 <code>dll2</code>，加载 <code>dll1.dll</code> 的时候会自动加载 <code>dll2.dll</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain1.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/autorunner.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../dll2/exports.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMajorVersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Major Version of dll2.dll is "</span> &lt;&lt; MajorVersion() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_AUTO_RUN</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm running in dll1.dll, which implicitly depends on dll2.dll."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>dll2</code></p><p>该模块提供了注册回调函数的导出接口，并实现了回调逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exports.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_DLL2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT extern <span class="meta-string">"C"</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT extern <span class="meta-string">"C"</span> __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">int</span> <span class="title">MajorVersion</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">RegisterInitCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span>;</span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">RegisterCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_DLL2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"exports.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MajorVersion</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">void</span>(*)()&gt; s_init_callbacks;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterInitCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_init_callbacks.insert(<span class="built_in">std</span>::make_pair(key, callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGlobalVariable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyGlobalVariable() &#123; <span class="keyword">auto</span> <span class="keyword">module</span> = LoadLibrary(<span class="string">L"dll3.dll"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyGlobalVariable s_culprit;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">void</span>(*)()&gt; s_callbacks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_callbacks.insert(<span class="built_in">std</span>::make_pair(key, callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : s_init_callbacks)</span><br><span class="line">    &#123;</span><br><span class="line">        it.second();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>dll3</code></p><p>该模块会<strong>自动</strong>调用 <code>dll2.dll</code> 导出的接口进行注册</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain3.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/autorunner.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../dll2/exports.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dll3InitCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm callback from dll3.dll"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterInitCallback(<span class="string">"dll3"</span>, Dll3InitCallback);</span><br><span class="line">END_AUTO_RUN</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dll3Callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm callback from dll3.dll"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterCallback(<span class="string">"dll3"</span>, Dll3Callback);</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure></li></ul><p>直接运行程序，从表面上看一切正常，但是在调试器下运行程序的时候会遇到一个意想不到的异常。</p><h2 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h2><p>打开 <code>windbg</code>，选择需要执行的程序，确定后输入 <code>g</code> 命令，目标程序会发生异常，自动中断到 <code>windbg</code> 中。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/exception-break-to-windbg.png" alt="exception-break-to-windbg"></p><p>在 <code>windbg</code> 中输入 <code>kc</code> 查看调用栈，输出结果摘录如下（为了方便查看，输出结果有所调整，注意 <code>&lt;----</code> 的部分）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; kc</span><br><span class="line"> # Call Site</span><br><span class="line"><span class="number">00</span> dll2!<span class="built_in">std</span>::_Tree&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span>)&gt;::_Insert_nohint&lt;...&gt;()</span><br><span class="line"><span class="number">01</span> dll2!<span class="built_in">std</span>::_Tree&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span>)&gt;::emplace&lt;...&gt;()</span><br><span class="line"><span class="number">02</span> dll2!<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span>)&gt;::insert&lt;...&gt;()</span><br><span class="line"><span class="number">03</span> dll2!RegisterCallback  <span class="comment">//&lt;----</span></span><br><span class="line"><span class="number">04</span> dll3!&lt;lambda_7ce22ad9d321cf7c9be3c0faf7e37347&gt;::<span class="keyword">operator</span>()</span><br><span class="line"><span class="number">05</span> dll3!&lt;lambda_7ce22ad9d321cf7c9be3c0faf7e37347&gt;::&lt;lambda_invoker_cdecl&gt;</span><br><span class="line"><span class="number">06</span> dll3!AutoRunner::AutoRunner  <span class="comment">//&lt;----</span></span><br><span class="line">07 dll3!`dynamic initializer for 's_auto_runner_23''</span><br><span class="line"><span class="number">08</span> ucrtbased!_initterm</span><br><span class="line"><span class="number">09</span> dll3!dllmain_crt_process_attach</span><br><span class="line"><span class="number">0</span>a dll3!dllmain_crt_dispatch</span><br><span class="line"><span class="number">0b</span> dll3!dllmain_dispatch</span><br><span class="line"><span class="number">0</span>c dll3!_DllMainCRTStartup</span><br><span class="line"><span class="number">0</span>d ntdll!LdrpCallInitRoutine</span><br><span class="line"><span class="number">0</span>e ntdll!LdrpInitializeNode</span><br><span class="line"><span class="number">0f</span> ntdll!LdrpInitializeGraphRecurse</span><br><span class="line"><span class="number">10</span> ntdll!LdrpPrepareModuleForExecution</span><br><span class="line"><span class="number">11</span> ntdll!LdrpLoadDllInternal</span><br><span class="line"><span class="number">12</span> ntdll!LdrpLoadDll</span><br><span class="line"><span class="number">13</span> ntdll!LdrLoadDll</span><br><span class="line"><span class="number">14</span> KERNELBASE!LoadLibraryExW</span><br><span class="line"><span class="number">15</span> dll2!MyGlobalVariable::MyGlobalVariable   <span class="comment">//&lt;----</span></span><br><span class="line">16 dll2!`dynamic initializer for 's_culprit''</span><br><span class="line"><span class="number">17</span> ucrtbased!_initterm</span><br><span class="line"><span class="number">18</span> dll2!dllmain_crt_process_attach</span><br><span class="line"><span class="number">19</span> dll2!dllmain_crt_dispatch</span><br><span class="line"><span class="number">1</span>a dll2!dllmain_dispatch</span><br><span class="line"><span class="number">1b</span> dll2!_DllMainCRTStartup</span><br><span class="line"><span class="number">1</span>c ntdll!LdrpCallInitRoutine</span><br><span class="line"><span class="number">1</span>d ntdll!LdrpInitializeNode</span><br><span class="line"><span class="number">1</span>e ntdll!LdrpInitializeGraphRecurse</span><br><span class="line"><span class="number">1f</span> ntdll!LdrpInitializeGraphRecurse</span><br><span class="line"><span class="number">20</span> ntdll!LdrpPrepareModuleForExecution</span><br><span class="line"><span class="number">21</span> ntdll!LdrpLoadDllInternal</span><br><span class="line"><span class="number">22</span> ntdll!LdrpLoadDll</span><br><span class="line"><span class="number">23</span> ntdll!LdrLoadDll</span><br><span class="line"><span class="number">24</span> KERNELBASE!LoadLibraryExW</span><br><span class="line"><span class="number">25</span> KERNELBASE!LoadLibraryExA</span><br><span class="line"><span class="number">26</span> KERNELBASE!LoadLibraryA</span><br><span class="line"><span class="number">27</span> LoadDlls!LoadPlugins  <span class="comment">//&lt;----</span></span><br><span class="line"><span class="number">28</span> LoadDlls!main</span><br><span class="line"><span class="number">29</span> LoadDlls!invoke_main</span><br><span class="line"><span class="number">2</span>a LoadDlls!__scrt_common_main_seh</span><br><span class="line"><span class="number">2b</span> LoadDlls!__scrt_common_main</span><br><span class="line"><span class="number">2</span>c LoadDlls!mainCRTStartup</span><br><span class="line"><span class="number">2</span>d KERNEL32!BaseThreadInitThunk</span><br><span class="line"><span class="number">2</span>e ntdll!RtlUserThreadStart</span><br></pre></td></tr></table></figure><p>在 <code>windbg</code> 中输入 <code>.frame 0x27</code> 切换到 <code>0x27</code> 栈帧，然后输入 <code>dv</code> 查看局部变量，可以发现确实是在加载 <code>dll1.dll</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; .frame <span class="number">0x27</span></span><br><span class="line"><span class="number">27</span> <span class="number">000000</span>d5`<span class="number">3</span>a4ff610 <span class="number">00007f</span>f7`da7debb7     LoadDlls!LoadPlugins+<span class="number">0xb3</span> [D:\MyBlogStuff\LoadDlls\src\LoadDlls\LoadDlls.cpp @ <span class="number">19</span>] </span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dv</span><br><span class="line">         <span class="keyword">module</span> = <span class="number">0xcccccccc</span>`cccccccc</span><br><span class="line">         plugin = <span class="number">0x00007ff7</span>`da7ea740 <span class="string">"dll1.dll"</span></span><br><span class="line">            idx = <span class="number">0</span>n0</span><br><span class="line">        plugins = <span class="number">0x000000d5</span>`<span class="number">3</span>a4ff868</span><br><span class="line">         result = &#123; size=<span class="number">0x0</span> &#125;</span><br></pre></td></tr></table></figure><p>结合代码可以整理整个执行流程，大概是这样的：</p><ul><li><p>主程序 <code>LoadDlls.exe</code> 会通过 <code>LoadPlugins()</code> 调用 <code>LoadLibrary()</code> 来加载 <code>dll1.dll</code>，由于 <code>dll1.dll</code> 隐式依赖了 <code>dll2.dll</code>，所以 <code>dll1.dll</code> 加载的时候会自动加载 <code>dll2.dll</code>。</p></li><li><p><code>dll2.dll</code> 中的全局变量 <code>s_culprit</code> 的构造函数（栈帧 <code>0x15</code>）内部会调用 <code>LoadLibrary()</code> 加载 <code>dll3.dll</code>（栈帧 <code>0x14</code>）</p></li><li><p><code>dll3.dll</code> 中的全局变量 <code>s_auto_runner_23</code> 的构造函数（栈帧 <code>0x6</code>）内部会调用 <code>dll2.dll</code> 的导出函数 <code>RegisterCallback()</code>（栈帧 <code>0x3</code>）</p></li><li><p><code>RegisterCallback()</code> 内部会调用 <code>s_callbacks.insert()</code> 把注册的回调函数保存起来，但是在保存过程中遇到了异常，中断到了 <code>windbg</code> 中。</p></li></ul><h2 id="查看异常"><a href="#查看异常" class="headerlink" title="查看异常"></a>查看异常</h2><p>根据 <code>windbg</code> 给出的提示，可以发现是在读取地址 <code>0x00000008</code> 的时候发生了异常，此地址明显是不可访问的。</p><p><code>00007ffd 57684ff1 488b4008    mov rax,qword ptr [rax+8] ds:00000000 00000008=????????????????</code></p><p>看上去非常像是空指针异常。这段代码是在调用  <code>s_callbacks.insert()</code> 的时候执行的，大概率是 <code>s_callbacks</code> 出了问题，在 <code>windbg</code> 中使用 <code>dx s_callbacks -r4</code> 查看  <code>s_callbacks</code> 的值，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/view-s_callbacks.png" alt="view-s_callbacks"></p><p>可以发现，<code>s_callbacks</code> 中的值很奇怪，都是空值。看上去很像还没有初始化的样子。</p><p>结合上面整理的调用流程，可以发现是在调用 <code>dll2!s_culprit</code> 的构造函数时接触发了对 <code>dll2!RegisterCallback()</code> 的调用，这时 <code>dll2!s_callbacks</code> 这个全局变量还没有初始化。</p><p>因为初始化完 <code>dll2!s_culprit</code>，才会初始化 <code>dll2!s_callbacks</code>。</p><p>至此，可以破案了。只需要调整一下这两个全局变量的顺序，问题就解决了。修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyGlobalVariable s_culprit; // 移动到 s_callbacks 下面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">void</span>(*)()&gt; s_callbacks;</span><br><span class="line"></span><br><span class="line">MyGlobalVariable s_culprit;</span><br></pre></td></tr></table></figure><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>相关工程代码已经上传到 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/LoadDlls" target="_blank" rel="noopener">github</a> 了，感兴趣的小伙伴儿可以下载验证。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次故障是因为在 <code>dll2.dll</code> 的全局变量 <code>s_culprit</code> 的构造函数中使用 <code>LoadLibrary()</code> 加载了 <code>dll3.dll</code>，而 <code>dll3.dll</code> 中的全局变量构造函数会调用 <code>dll2!RegisterCallback()</code>，这个函数内部会使用未初始化的全局变量 <code>dll2!s_callbacks</code>。因为此时正在初始化 <code>dll2!s_culprit</code> 的过程中，<code>dll2!s_culprit</code> 初始化完成后才会初始化 <code>dll2!s_callbacks</code>。</p><p>相较于之前的案例，这次的案例更复杂，涉及到了多个模块。单看每个模块，问题都不大，但是放到一起就触发了这个异常。</p><p>所以，尽量不要在全局变量的构造函数中做复杂的工作，尤其要避免类似 <code>LoadLibrary</code> 的操作。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices</a></li></ul><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>其实，这个问题背后还有一个更隐蔽的 <code>bug</code>，不知道你是否看出来了呢？<code>stay tuned!</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近又遇到了一个程序功能不正常的问题，深入调查后发现与全局变量初始化顺序有非常大的关系，只不过这次更加隐蔽。&lt;/p&gt;
&lt;p&gt;之前总结了两篇与全局变量初始化顺序有关的文章，感兴趣的小伙伴儿可以参考&lt;a href=&quot;https://bianchengnan.github.io/articles/debugging-dll-load-failure-caused-by-global-variable-initialize-dependency/&quot;&gt;《调试实战 | dll 加载失败之全局变量初始化篇》&lt;/a&gt; 和 &lt;a href=&quot;https://bianchengnan.github.io/articles/global-variable-initialization-order-investigation/&quot;&gt;《调试实战 | 全局变量初始化顺序探究》&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="全局变量" scheme="https://bianchengnan.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>2024 开工喽</title>
    <link href="https://bianchengnan.github.io//articles/2024-startup/"/>
    <id>https://bianchengnan.github.io//articles/2024-startup/</id>
    <published>2024-02-20T13:15:25.000Z</published>
    <updated>2025-12-13T05:48:33.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回首-2023"><a href="#回首-2023" class="headerlink" title="回首 2023"></a>回首 2023</h2><p>回顾整个 <code>2023</code> ，相比 <code>2022</code>  加班少了，工作没那么拼命了。</p><p>由于各种原因，年初立的 <code>flag</code> 好几个都没实现。</p><ul><li>公众号基本上处于鸽的状态</li><li>也没分享技术视频</li><li>语言倒是接触了一下 <code>rust</code>，但远没有达到能实战的地步</li><li>嘴没管住，腿倒是迈开了</li></ul><h2 id="展望-2024"><a href="#展望-2024" class="headerlink" title="展望 2024"></a>展望 2024</h2><p>我对 <code>2024</code> 这个数字感到非常亲切，<code>2024 = 1000 + 1024</code>，两个<strong>一千</strong></p><ul><li><p><strong>今年的首要任务依旧是锻炼身体</strong></p><p>本来计划 <code>2024</code> 年跑步作为日常锻炼的方式，结果 <code>2023</code> 年最后一次从公司跑回家后膝盖疼，<code>2024</code> 只能偶尔跑跑了</p></li></ul><ul><li><strong>继续遛狗</strong><br><code>2023</code> 花费了很大一部分时间在遛狗上，<code>2024</code> 继续努力。如果不是狗子的陪伴，估计我早抑郁了，感谢，感恩。</li></ul><ul><li><p><strong>坚持练习英语口语</strong></p><p>希望这次不要因为任何原因中断</p></li></ul><ul><li><p><strong>继续坚持分享技术文章</strong></p><p>遇到值得总结的问题，及时总结分享</p></li></ul><ul><li><p><strong>读一些非技术书籍</strong></p><p>之前看的书以技术书籍为主，<code>2024</code> 年争取多看些非技术的书籍</p></li></ul><ul><li><p><strong>做一些改变</strong></p><p>尽量熟悉 <code>AI</code> 相关的人和事</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回首-2023&quot;&gt;&lt;a href=&quot;#回首-2023&quot; class=&quot;headerlink&quot; title=&quot;回首 2023&quot;&gt;&lt;/a&gt;回首 2023&lt;/h2&gt;&lt;p&gt;回顾整个 &lt;code&gt;2023&lt;/code&gt; ，相比 &lt;code&gt;2022&lt;/code&gt;  加班少了
      
    
    </summary>
    
      <category term="年度总结" scheme="https://bianchengnan.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的递归栈查看（续）</title>
    <link href="https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack-continue/"/>
    <id>https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack-continue/</id>
    <published>2024-01-06T02:30:22.000Z</published>
    <updated>2025-12-13T05:48:33.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在上篇<a href="https://bianchengnan.github.io/articles/how-to-view-startup-function-from-a-deep-recursive-stack/">文章</a>中介绍了在 <code>windbg</code> 中如何查看非常深的调用栈 —— 使用 <code>kN</code> 命令指定栈帧数。<code>kN</code> 虽好，但最多只能查看 <code>0xffff</code> 个栈帧。如果栈帧数量比 <code>0xffff</code> 还多，该如何查看呢？本文将介绍几种查看方法。</p><a id="more"></a><p>在介绍查看方法前，需要对线程栈的特点有个基本的认识。</p><h2 id="线程栈的关键特性"><a href="#线程栈的关键特性" class="headerlink" title="线程栈的关键特性"></a>线程栈的关键特性</h2><ul><li><p>线程栈是从高向低扩展的，当向栈上 <code>push</code> 一个值的时候，栈底指针 <code>esp</code> 的值会减小。</p></li><li><p>函数返回地址会保存到栈上：</p><p>函数 <code>A</code> 调用函数 <code>B</code> 的时候，会把 <code>B</code> 需要的参数根据调用约定放到对应的位置，有可能是通过寄存器传递，也有可能通过栈传递。处理完参数后会执行 <code>call B</code>，而 <code>call</code> 指令可以简单理解为以下两个操作：</p><ol><li><strong>把返回地址（调用函数 B 的下一条指令地址）入栈</strong></li><li><strong>跳转到函数 <code>B</code> 继续执行</strong></li></ol><p>如果函数 <code>B</code> 会调用另外一个函数 <code>C</code>，那么会遵循相同的规律：会把返回地址（ <strong><code>call C</code> 后面的地址</strong>）入栈，然后跳转到 <code>C</code> 继续执行。当 <code>C</code> 执行结束的时候，<code>CPU</code> 会从栈上把保存的返回地址弹出到 <code>rip</code> 中，这样就可以继续从函数 <code>B</code> 中调用函数 <code>C</code> 的下一条指令继续执行了。</p></li></ul><p>根据以上几点可以得到一个非常重要的结论：如果 <code>A</code> 调用了 <code>B</code>，<code>B</code> 又调用了 <code>C</code>，<code>C</code> 又调用了 <code>D</code>。那么 <code>B</code> 返回到 <code>A</code> 的地址在线程栈的高处，<code>C</code> 返回到 <code>B</code> 的地址在线程栈的低处，<code>D</code> 返回到 <code>C</code> 的地址在线程栈的最低处。</p><p>有了以上的基本认识，就可以使用以下几种方法查看调用栈了。</p><h2 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h2><p><strong>方法1：</strong>使用 <code>.kframes</code> 设置默认显示的栈帧数量</p><p>​    增大默认显示数量，这样就可以一次性显示更多的调用栈</p><p><strong>方法2：</strong>使用 <code>dps</code>，自己识别调用栈</p><p>​    可以灵活高效的从指定的位置开始查找</p><p><strong>方法3：</strong>使用 <code>k</code> 命令的时候指定 <code>StackPtr</code></p><p>​    可以从指定位置开始显示调用栈，不必从头开始显示</p><p>为了方便验证每种方法的可行性，我写了一个非常简单的递归调用测试程序，为了让调用栈可以更深一些，我修改了工程设置中的<strong>堆栈保留大小</strong>为 <code>0x70800000</code>（大概 <code>1.75 GB</code> ）。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recursive</span><span class="params">(<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Recursive(--depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallRecursive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Recursive(<span class="number">0x7fffffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CallRecursive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试工程可以到<a href="https://github.com/bianchengnan/MyBlogStuff/tree/master/how-to-view-startup-function-from-a-deep-recursive-stack-continue" target="_blank" rel="noopener">这里</a>下载。</p><p>接下来依次介绍每种查看方法。</p><h2 id="方法1：使用-kframes-设置默认显示的栈帧数量"><a href="#方法1：使用-kframes-设置默认显示的栈帧数量" class="headerlink" title="方法1：使用 .kframes 设置默认显示的栈帧数量"></a>方法1：使用 <code>.kframes</code> 设置默认显示的栈帧数量</h2><p>在 <code>windbg</code> 的帮助文档中发现可以通过 <code>.kframes</code> 命令来设置 <code>k</code> 命令默认显示的栈帧数量。但是也不是可以显示无限多个栈帧。</p><p>那么通过 <code>.kframes</code> 可以设置的最大栈帧数是多少呢？通过几次尝试，我发现 <code>.kframes</code> 可以接受的最大值是 <code>32</code> 位的带符号整数的最大值，也就是 <code>0x7fffffff</code>（对应的十进制是 <code>2147483647</code>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/try-to-find-max-kframes-number.png" alt="try-to-find-max-kframes-number"></p><p> 但是，如果通过 <code>.kframes</code> 命令把栈帧数设置为 <code>0x7fffffff</code> 后，再执行 <code>k</code> 命令，发现 <code>windbg</code> 会直接提示内存分配失败。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-failed-after-kframes-set-to-0x7fffffff.png" alt="windbg-k-failed-after-kframes-set-to-0x7fffffff"></p><p>尝试把栈帧数设置为 <code>0x1000000</code>，再执行 <code>k</code> 命令，发现 <code>windbg</code> 的内存占用非常高，高峰期大概消耗了 <code>20GB</code> 的物理内存（下图中的 <code>Working Set</code> 列），经过将近两分钟的努力，最终还是以内存分配失败告终~</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-memory-usage-kframe-0x10000000.png" alt="windbg-memory-usage-kframe-0x10000000"></p><p>又试了几个更小的值，发现在我的机器上（<code>24GB</code> 物理内存）设置为 <code>0x1000000</code> 时可以输出结果，但是因为数据量太大了，等了半个多小时也没执行完~</p><p>虽然这次 <code>.kframes</code> 没能成功，但这绝对是一个非常值得了解的命令，可以处理绝大多数情况下的线程栈查看问题。</p><p><strong>优点：</strong> </p><ol><li>操作非常简单</li><li>可以处理绝大多数情况</li></ol><p><strong>缺点：</strong> </p><ol><li>会影响后续 <code>k</code> 命令默认显示效果（仅限当前调试会话，<code>windbg</code> 重启后会自动失效）</li><li>当调用栈过深的时候，<code>k</code> 命令可能会<strong>非常非常非常</strong>慢（对于示例程序，半个小时还没执行完）</li><li>内存占用可能会非常高（需要分配内存来显示对应的信息）</li><li>不能解决调用栈过深的问题（受到物理内存的限制）</li><li>很难找到一个合适的值（设置的太大，可能消耗过多的资源，运行慢；设置的太小，调用栈可能显示不全）</li></ol><h2 id="方法2：使用-dps，自己识别调用栈"><a href="#方法2：使用-dps，自己识别调用栈" class="headerlink" title="方法2：使用 dps，自己识别调用栈"></a>方法2：使用 <code>dps</code>，自己识别调用栈</h2><p>在 <code>windbg</code> 中可以通过 <code>dps</code> 以指针长度为单位打印出指定内存范围的值，同时会输出匹配的符号。</p><p><strong>操作步骤：</strong></p><ol><li>通过 <code>!teb</code> 指令找到栈顶（<code>StackBase</code>）的位置，然后减去一定的值（比如 <code>64kb</code>）得到一个较低的地址 <code>A</code>。</li><li>执行 <code>dps A StackBase</code>。如果输出结果中没有包含感兴趣的函数，可以减去一个更大的值，再次执行 <code>dps</code> 并查看输出结果，直到输出结果中包含感兴趣的函数为止。</li><li>根据 <code>dps</code> 的输出内容手动识别调用栈。</li></ol><p><strong>实战：</strong></p><p>通过 <code>!teb</code> 命令获取栈顶位置（<code>0000002a33800000</code>）然后减去 <code>64KB</code> （<code>0x10000</code>，也可以换成其它值，一般情况下 <code>64KB</code> 足够了）得到地址 <code>0000002a337f0000</code>，然后执行 <code>dps 0000002a337f0000 0000002a33800000</code>。或者可以直接直接输入 <code>dps 0000002a33800000-0x10000 0000002a33800000</code>。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-dps.png" alt="windbg-dps"></p><p>根据 <code>dps</code> 的结果可知，已经包含了关键的递归函数 —— <code>TestDeepRecursive!Recursive</code>，可以根据此次 <code>dps</code> 的输出结果手动识别调用栈。拉到输出结果的最下方，可以看到输出结果如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-dps-manual-reconstruct-callstack.png" alt="windbg-dps-manual-reconstruct-callstack"></p><p>从上图可以看到 <code>main</code> 函数，<code>CallRecursive</code> 函数，<code>Recursive</code> 函数。而且与 <code>vs</code> 中的调用栈完美匹配。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-callstack-in-vs.png" alt="view-callstack-in-vs"></p><blockquote><p><strong>说明：</strong> 输出结果中<strong>极有可能</strong>包含很多无关的信息（比如上图中的黄色高亮部分），需要仔细甄别。</p></blockquote><p><strong>优点：</strong> </p><ol><li>输出结果速度非常快</li><li>非常灵活，强大</li></ol><p><strong>缺点：</strong></p><ol><li>需要对线程栈有一定的认识</li><li>需要人肉识别调用栈，有一定难度</li><li>比较依赖调试符号，如果没有调试符号，只根据地址信息，很难找出关联关系</li><li>容易出错，因为栈上的内容比较杂，可能包含很多无关的信息</li></ol><h2 id="方法3：使用-k-命令的时候指定-StackPtr"><a href="#方法3：使用-k-命令的时候指定-StackPtr" class="headerlink" title="方法3：使用 k 命令的时候指定 StackPtr"></a>方法3：使用 <code>k</code> 命令的时候指定 <code>StackPtr</code></h2><p>前两种方法都有各自的优缺点，可以在前两种方法的基础上使用本方法——使用 <code>k</code> 命令的时候指定正确的 <code>StackPtr</code>，<code>windbg</code> 会自动帮我们识别调用栈。</p><p>使用本方法时需要传递一个<strong>正确</strong>的 <code>StackPtr</code>（调试 <code>x64</code> 程序时需要传递 <code>rsp</code>，调试 <code>x86</code> 程序时需要传递 <code>ebp</code>，也叫 <code>BasePtr</code> ），也可以同时指定要显示的栈帧数量。</p><p>关于 <code>k</code> 命令的帮助文档可以参考下图（截取自 <code>windbg</code> 帮助文档）：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-command-help.png" alt="windbg-k-command-help"></p><p>如果传递的 <code>StackPtr</code> 不对，那么输出结果很可能是错误的。比如，我使用一个错误的值执行 <code>k=0x0000002a337ff938</code> 输出结果如下：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/output-of-wrong-stackptr-k-command.png" alt="output-of-wrong-stackptr-k-command"></p><p>所以，传递一个正确的 <code>StackPtr</code> 是必须的。那么，该如何获取一个正确的 <code>StackPtr</code> 呢？有两个方法：</p><ol><li><p>执行 <code>k</code> 命令的时候，最左侧那一列就是 <code>rsp</code>（<code>x86</code> 程序对应着 <code>ebp</code>）。可以这样处理：先通过 <code>.kframes</code> 设置一个相对合理的值，然后执行 <code>k</code> 命令，等命令执行完，取最后一条输出结果的 <code>rsp</code> 的值，假设是 <code>00000029c3004040</code>，然后执行 <code>k=00000029c3004040 3</code>，就可以继续显示后续的三条调用栈了。重复此过程即可。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-start-at-specific-address.png" alt="windbg-k-start-at-specific-address"><br>实际使用的时候，可以尽量每次多显示一些栈帧，如果调用栈非常深，需要重复的次数会很多，但总比不能查看强！</p></li><li><p>在 <code>dps</code> 的输出结果中 <strong>“猜”</strong> 一个 <code>ebp</code> 或者 <code>rsp</code> 的值。说是猜，其实是有规律的。</p><p>2.1 对于 <code>x86</code> 的程序，<code>ebp</code> 保存了调用者的 <code>ebp</code>，<code>ebp+4</code> 的位置保存了返回地址。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-ebp-by-dps.png" alt="view-ebp-by-dps"></p><p>根据上图可以猜测，一个合法的 <code>ebp</code> 的值是 <code>0x009ef908</code>。</p><p>在 <code>windbg</code> 中输入 <code>k=0x09ef908 0x100</code>，可以得到下图完美的调用栈：<img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/k-0x009ef908-0x100.png" alt="k-0x009ef908-0x100"></p><p>2.2 对于 <code>x64</code> 的程序，<code>rsp-8</code> 的位置保存了返回地址。可以根据有意义的符号名称对应的最左侧地址值 <code>+8</code> 得到 <code>rsp</code> 的值。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-rsp-by-dps.png" alt="view-rsp-by-dps"></p><p>根据上图可知，一个合法的 <code>rsp</code> 的值是 <code>0x0000002a337ffbd0</code>。在 <code>windbg</code> 中输入 <code>k=0x0000002a337ffbd0 0x100</code>，可以得到下图完美的调用栈：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/k-0000002a337ffbd0-0x100.png" alt="k-0000002a337ffbd0-0x100"></p></li></ol><p><strong>优点：</strong></p><ol><li>输出效率高，只需要显示关心的栈帧即可</li><li>不用自己识别调用栈，可以像普通的 <code>k</code> 命令一样输出调用栈</li></ol><p><strong>缺点：</strong></p><ol><li>需要指定一个合法的 <code>StackPtr</code>，不能随便指定</li><li>需要非常了解  <code>x86/x64</code> 程序的调用栈，这样才能比较快速准确的找到合法的 <code>StackPtr</code></li></ol><p>所以，<code>dps</code> <code>+</code> <code>k=StackPtr [FrameCount]</code> 是最高效，最优雅的解决方案。</p><blockquote><p><strong>说明：</strong> 如果知道了一个合法的 <code>StackPtr</code>，也可以先通过 <code>r rsp = StackPtr</code> 修改 <code>rsp</code> 寄存器的值，然后再执行 <code>k</code> 命令显示调用栈。但是这个方法有一个<strong>特别不好</strong>的地方，<code>rsp</code> 会被修改，后续用到 <code>rsp</code> 寄存器的命令都会受影响。因此，不推荐使用。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用 <code>.kframes</code> 可以设置默认显示的栈帧数，可以突破默认最多显示 <code>0xffff</code> 个栈帧的限制，但是注意如果设置的值太大，会非常消耗内存</li><li><code>dps</code> 可以按指针打印一系列的值，并且会显示匹配的符号。务必记住此命令，非常有用</li><li>使用 <code>k</code> 命令时，可以指定 <code>StackPtr</code> 来从指定位置开始显示调用栈</li><li>对于 <code>x86</code> 的程序，<code>ebp</code> 保存了调用者的 <code>ebp</code>，<code>ebp+4</code> 的位置保存了返回地址。<strong>非常重要！！！</strong></li><li>对于 <code>x64</code> 的程序，<code>rsp-8</code> 的位置保存了返回地址。<strong>非常重要！！！</strong></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://devblogs.microsoft.com/oldnewthing/20130906-00/?p=3303" target="_blank" rel="noopener">https://devblogs.microsoft.com/oldnewthing/20130906-00/?p=3303</a></p><p><a href="https://blog.aaronballman.com/2011/07/reconstructing-a-corrupted-stack-crawl/" target="_blank" rel="noopener">https://blog.aaronballman.com/2011/07/reconstructing-a-corrupted-stack-crawl/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在上篇&lt;a href=&quot;https://bianchengnan.github.io/articles/how-to-view-startup-function-from-a-deep-recursive-stack/&quot;&gt;文章&lt;/a&gt;中介绍了在 &lt;code&gt;windbg&lt;/code&gt; 中如何查看非常深的调用栈 —— 使用 &lt;code&gt;kN&lt;/code&gt; 命令指定栈帧数。&lt;code&gt;kN&lt;/code&gt; 虽好，但最多只能查看 &lt;code&gt;0xffff&lt;/code&gt; 个栈帧。如果栈帧数量比 &lt;code&gt;0xffff&lt;/code&gt; 还多，该如何查看呢？本文将介绍几种查看方法。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="stack" scheme="https://bianchengnan.github.io/tags/stack/"/>
    
      <category term="递归" scheme="https://bianchengnan.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://bianchengnan.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的递归栈查看</title>
    <link href="https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack/"/>
    <id>https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack/</id>
    <published>2024-01-06T02:00:22.000Z</published>
    <updated>2025-12-13T05:48:33.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近，遇到了一个由于递归导致的卡死问题。这个问题非常有意思，值得总结。</p><p>你知道什么情况下无限递归会卡死，而不崩溃吗？你知道递归层数过多时，如何找到导致递归调用的函数吗？你知道如何快速找到关键线程吗？你知道如何附加到一个正在被调试的进程吗？你知道如何在 <code>windbg</code> 中显示指定数量的栈帧吗？</p><p>带着这些疑问，一起来看看这个非常有意思的问题吧。</p><blockquote><p><strong>说明：</strong> 文章末尾有这些问题的答案，可以直接跳到末尾查看。</p></blockquote><a id="more"></a><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>程序在执行某个功能时，迟迟不能完成，通过任务管理器可以发现 <code>CPU</code> 使用率比较高（<code>12.47%</code>），大概耗尽了一个核心（机器是八核的，每个核心占 <code>12.5%</code>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/high-cpu.png" alt="high-cpu"></p><p>心中暗喜，大概率是遇到了死循环，应该很好解决。赶紧用 <code>vs</code> 附加上去看看。</p><h2 id="了解错误"><a href="#了解错误" class="headerlink" title="了解错误"></a>了解错误</h2><p>附加到被调试进程后，手动暂停，然后通过<strong>并行堆栈</strong>找到可疑线程。</p><blockquote><p><strong>温馨提示：</strong> 可以通过 <code>调试 -&gt; 窗口 -&gt; 并行堆栈</code> 打开<strong>并行堆栈</strong>视图，也可以使用快捷键 <code>Ctrl+Shift+D, S</code> 打开 。</p></blockquote><p>一般情况下调用栈最长的线程就是可疑线程。即使不是，也可以在<strong>并行堆栈</strong>视图中快速切换线程。相比于手动一个个切换线程，并行堆栈简直是太方便了！</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-thread-stack.png" alt="view-thread-stack"></p><p>通过并行堆栈视图，可以观察到当前线程的调用栈非常深，已经超出了 <code>vs</code> 所支持的最大栈帧数。仔细观察调用栈，可以发现 <code>00007ffc9dcb3cb5</code> 这个地址会<strong>重复</strong>出现，说明这很可能是一个递归问题。</p><p>然而，只知道这是一个递归问题还不够，我们需要找到引发递归调用的函数。如果能看到完整的调用栈，那么就可以找到罪魁祸首了。由于 <code>vs</code> 不能显示更多的调用栈帧，我们可以请老朋友 <code>windbg</code> 出马。</p><h2 id="请出-windbg"><a href="#请出-windbg" class="headerlink" title="请出 windbg"></a>请出 windbg</h2><p>启动 <code>windbg</code>，以 <code>Noninvasive</code> 模式附加到被调试进程（由于该进程正在被 <code>vs</code> 调试，如果不以 <code>Noninvasive</code> 模式附加，<code>windbg</code> 无法成功附加）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-noninvasive-attach.png" alt="windbg-noninvasive-attach"></p><p>附加成功后，通过 <code>~~[12544]s</code> 切换到目标线程，没想到报错了。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-switch-thread-error.png" alt="windbg-switch-thread-error"></p><p>没关系，直接切不过去，还有其它方法可以找到目标线程。可以简单粗暴的使用 <code>~* k</code> 命令显示所有线程的调用栈，然后根据调用栈判断哪个线程是目标线程，也可以通过 <code>!runaway</code> 查看所有线程的运行时间，根据运行时间长短快速找出目标线程。</p><h2 id="runaway"><a href="#runaway" class="headerlink" title="!runaway"></a>!runaway</h2><p>在 <code>windbg</code> 中输入 <code>!runaway</code> 可以查看所有线程的运行时间。一般，<code>CPU</code> 占用率越高的线程，运行时间也越长。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-runaway.png" alt="windbg-runaway"></p><p>可以发现 <code>0</code> 号线程运行时间最长，然后是 <code>32</code> 号线程。先切换到 <code>0</code> 号线程，执行 <code>k</code> 命令查看调用栈，发现是主线程（一般情况下 <code>0</code> 号线程都是主线程），不是我们关心的线程。再执行 <code>~32s</code> 切换到运行时间排名第二的线程，然后执行 <code>k</code> 命令查看调用栈，发现与在 <code>vs</code> 中看到的调用栈吻合，<code>32</code> 号线程是目标线程了。</p><blockquote><p>*<em>说明： *</em> 当时比较着急，忘了 <code>windbg</code> 中默认使用十六进制。如果执行 <code>~~[0n12544]s</code> 即可正常切换过去了。<code>0n</code> 表示使用十进制。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/switch-to-0n12544-successfully.png" alt="switch-to-0n12544-successfully"></p></blockquote><p>找到对应的线程后，接下来的任务是查看完整调用栈。</p><h2 id="查看完整调用栈"><a href="#查看完整调用栈" class="headerlink" title="查看完整调用栈"></a>查看完整调用栈</h2><p>默认情况下，<code>windbg</code> 的 <code>k</code> 命令最多只显示 <code>256</code> 个调用栈帧，最大的栈帧号是 <code>ff</code>，从 <code>0</code> 开始计数。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-k-output-default.png" alt="windbg-k-output-default"></p><p>我们可以在 <code>windbg</code> 中执行 <code>kN</code>来指定要显示的栈帧数，如果 <code>N</code> 足够大，那么应该可以显示出完整的调用栈。</p><p>先尝试输入 <code>k200</code>，发现看不到头，再试试 <code>k2000</code>，依然看不到头，<code>k5000</code> 依然看不到头（这调用栈不是一般的深啊~）。 直接输入 <code>k50000</code>，这次应该够了吧？没想到报错了。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-k50000-error.png" alt="windbg-k50000-error"></p><p>根据提示可知，可以输入的最大值是 <code>0xffff</code>。在 <code>windbg</code> 中输入 <code>k0xffff</code>，耐心等待一会儿就可以看到完整的调用栈了。如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-full-callstack-in-windbg.png" alt="view-full-callstack-in-windbg"></p><blockquote><p><strong>说明：</strong> 不要输入 <code>kffff</code>，因为会被解释为  <code>kf fff</code>，第一个 <code>f</code> 会被解释为选项，用来显示两个栈帧的间距。<img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-k-command-help.png" alt="windbg-k-command-help"></p></blockquote><h2 id="调用栈深的异常"><a href="#调用栈深的异常" class="headerlink" title="调用栈深的异常"></a>调用栈深的异常</h2><p>调用栈深的有点异常，总共有 <code>0x9032 + 1</code> 个栈帧（即 <code>36915</code> 个）。这样深的调用栈却未发生栈溢出，实属不可思议。要知道，线程栈预留空间默认只有 <code>1MB</code>。</p><p>在 <code>windbg</code> 中查看当前线程栈信息，重点查看线程栈总大小和当前已使用大小（具体查看方法可以参考<a href="https://bianchengnan.github.io/articles/how-to-check-thread-stack-base/">这篇文章</a>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-stack-total-size-and-current-used-size.png" alt="view-stack-total-size-and-current-used-size"></p><p>可以发现，线程栈预留空间大约是 <code>1.757 GB</code>，当前已使用大小大约是 <code>64.07 MB</code>。</p><p>说实话，我还是头一次遇到这么<strong>巨大</strong>的栈空间，难怪调用栈如此深却没有发生栈溢出。</p><p>但是等一下，线程栈怎么会这么大？默认不是只有 <code>1MB</code> 吗？是在创建线程的时候指定了<strong>线程栈预留空间</strong>大小？还是 <code>64</code> 位程序编译时使用的<strong>线程栈预留空间</strong>的默认值发生了变化，或者被手动修改了？又或者是有人调整了 <code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 值？</p><p>不论是修改编译参数，还是手动修改 <code>PE</code> 头，这些操作最终都会体现在 <code>PE</code> 文件上。先使用 <code>CFF Explorer</code> 查看 <code>PE</code> 文件头。</p><h2 id="查看-PE-头"><a href="#查看-PE-头" class="headerlink" title="查看 PE 头"></a>查看 PE 头</h2><p>果然，<code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 变成了 <code>0x0000000070800000</code> ，与上面在 <code>windbg</code> 中看到的线程栈总大小是一致的。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-pe-header.png" alt="view-pe-header"></p><p>为了验证是不是 <code>64</code> 位程序默认编译参数导致的，我特意建了一个简单的控制台程序，查看了工程设置参数，发现与 <code>32</code> 位程序一样，<strong>线程栈预留空间</strong>默认大小是 <code>1MB</code>。</p><p>一般不会有人修改生成的 <code>PE</code> 文件，回想到总是遇到栈溢出问题，猜测极有可能是某位同事修改了工程设置。不过栈空间修改的这么大，确实有待商榷。</p><p>至此，基本可以结案了。</p><h2 id="结案"><a href="#结案" class="headerlink" title="结案"></a>结案</h2><p>虽然递归了，调用栈很深，但是由于栈空间非常大，所以<strong>一时半会儿</strong>还不会导致栈溢出。最终看到的现象就是卡死、<code>CPU</code> 占用率高，而不是崩溃。当然，最终栈空间耗尽后，还是会触发栈溢出异常的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在 <code>windbg</code> 中可以通过 <code>kN</code> 查看指定数量的调用栈。只要 <code>N</code> 足够大，基本上可以看到完整的调用栈，但是默认情况下，<code>N</code> 不能超过 <code>0xffff</code>。</li><li>在 <code>vs</code> 中可以通过<strong>并行堆栈</strong>快速查看各个线程的调用栈，从而可以快速找到关键线程。强烈推荐！</li><li>在 <code>windbg</code> 中可以使用 <code>~* k</code> 快速查看所有线程的调用栈，与 <code>vs</code> 中的<strong>并行堆栈</strong>功能不相上下。</li><li>在 <code>windbg</code> 中可以通过 <code>!runaway</code> 查看运行时间最长的线程，从而可以快速找到关键线程。</li><li><code>windbg</code> 可以以 <code>Noninvasive</code> 的形式附加到一个正在被调试的进程。</li><li><code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 决定了线程栈预留空间的大小，可以手动修改此值来调整线程的默认栈预留空间大小。</li><li>在 <code>vs</code> 工程中可以通过修改<strong>堆栈保留大小</strong>选项（单位是字节）来控制 <code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 的值。</li></ul><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>如果调用栈深度超出了 <code>0xffff</code>，该如何查看完整的调用栈呢？下篇更精彩，敬请期待~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近，遇到了一个由于递归导致的卡死问题。这个问题非常有意思，值得总结。&lt;/p&gt;
&lt;p&gt;你知道什么情况下无限递归会卡死，而不崩溃吗？你知道递归层数过多时，如何找到导致递归调用的函数吗？你知道如何快速找到关键线程吗？你知道如何附加到一个正在被调试的进程吗？你知道如何在 &lt;code&gt;windbg&lt;/code&gt; 中显示指定数量的栈帧吗？&lt;/p&gt;
&lt;p&gt;带着这些疑问，一起来看看这个非常有意思的问题吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 文章末尾有这些问题的答案，可以直接跳到末尾查看。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="stack" scheme="https://bianchengnan.github.io/tags/stack/"/>
    
      <category term="递归" scheme="https://bianchengnan.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://bianchengnan.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 从转储文件找出抛出的异常 —— 实战</title>
    <link href="https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part2/"/>
    <id>https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part2/</id>
    <published>2023-12-31T10:36:41.000Z</published>
    <updated>2025-12-13T05:48:33.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我在<a href="https://bianchengnan.github.io/articles/search-throwing-exception-from-dump-file-part1/">上一篇文章</a>中介绍了定位抛出异常的理论知识，本文会通过几个实例介绍各种情况下的定位方法。有调试符号如何定位？没有调试符号如何定位？<code>32</code> 位程序如何定位？<code>64</code> 位程序又该如何定位？</p><p>其实，<code>32</code> 位程序和 <code>64</code> 位程序定位过程大同小异，只不过在解析过程中需要注意，很多关键字段在 <code>64</code> 位程序中是偏移，需要加上模块基址得到虚拟地址后才能使用，而在 <code>32</code> 位程序中对应的字段就是虚拟地址，可以直接使用。</p><p>没有调试符号的时候定位异常类型会比较困难，需要根据上一篇文章中总结的步骤一步步的找到异常类型。有调试符号的情况会比较容易，有很多简便的查看方法。</p><p>一起来实战吧！</p><a id="more"></a><p>在开始实战之前，把相关结构体再贴一下，方便参考。</p><h2 id="32-位关键结构"><a href="#32-位关键结构" class="headerlink" title="32 位关键结构"></a>32 位关键结构</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">TestThrowException!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr32 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">TestThrowException!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pExceptionObject : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> pThrowInfo       : Ptr32 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">TestThrowException!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Ptr32     <span class="keyword">int</span> </span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Ptr32 _s_CatchableTypeArray <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableTypeArray</span><br><span class="line">TestThrowException!_s_CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Ptr32 _s_CatchableType <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableType</span><br><span class="line">TestThrowException!_s_CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Ptr32 TypeDescriptor <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Ptr32     <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">TestThrowException!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> hash             : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> spare            : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><h2 id="64-位关键结构"><a href="#64-位关键结构" class="headerlink" title="64 位关键结构"></a>64 位关键结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">VCRUNTIME140!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr64 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x010</span> ExceptionAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x018</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x020</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">VCRUNTIME140!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> pExceptionObject : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> pThrowInfo       : Ptr64 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x018</span> pThrowImageBase  : Ptr64 Void</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">VCRUNTIME140!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Int4B</span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Int4B</span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableTypeArray</span><br><span class="line">VCRUNTIME140!CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableType</span><br><span class="line">VCRUNTIME140!CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Int4B <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Int4B</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">VCRUNTIME140!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> pVFTable         : Ptr64 Void</span><br><span class="line">   +<span class="number">0x008</span> spare            : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><p>接下来，先介绍无调试符号时的定位方法，然后再介绍有调试符号时的定位方法。</p><h2 id="无调试符号"><a href="#无调试符号" class="headerlink" title="无调试符号"></a>无调试符号</h2><p>如果没有导致异常的模块的调试符号，定位过程会比较复杂，需要根据上一篇文章中总结的方法一步步定位。此方法的坏处是麻烦，好处是比较通用，任何情况下都可以使用。</p><h3 id="64-位程序"><a href="#64-位程序" class="headerlink" title="64 位程序"></a>64 位程序</h3><ol><li><p>获取 <code>EHParameters</code> 的地址。<code>_CxxThrowException</code> 栈帧的 <code>rsp+0x28</code> 指向了 <code>EHParameters</code>。</p><p><code>_CxxThrowException</code> 对应栈帧的 <code>rsp</code> 是 <code>000000b9f2effb80</code>。在 <code>windbg</code> 中输入 <code>? 000000b9f2effb80 + 0x28</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-address-of-EHParameters.png" alt="view-address-of-EHParameters"></p><p>由上图红色高亮部分可知 <code>EHParameters</code> 的地址是 <code>000000b9f2effba8</code>。</p></li><li><p>获取 <code>ThrowInfo</code> 的地址。<code>EHParameters + 0x10</code> 的位置保存了 <code>ThrowInfo</code> 的地址，<code>EHParameters + 0x18</code> 的位置保存了异常模块基址。</p><p>在 <code>windbg</code> 中输入 <code>dq 000000b9f2effba8</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-ThrowInfo-imagebase.png" alt="view-ThrowInfo-imagebase"></p><p>由上图红色高亮部分可知 <code>ThrowInfo</code> 的地址是 <code>00007ff71c542a20</code>，异常模块基址是 <code>00007ff71c540000</code>。</p><blockquote><p><strong>说明：</strong> 如果有 <code>vcruntimexxx.dll</code> 的调试符号，可以跳过前两步，直接切换到 <code>_CxxThrowException</code> 对应的栈帧即可得到 <code>ThrowInfo</code> 的地址和异常模块基址。</p></blockquote></li><li><p>获取 <code>CatchableTypeArray</code> 的地址。<code>ThrowInfo + 0xc</code> 保存了 <code>CatchableTypeArray</code> 的偏移。</p><p>在 <code>windbg</code> 中输入 <code>dd 00007ff71c542a20</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-throwinfo.png" alt="view-throwinfo"></p><p>由上图红色高亮部分可知 <code>CatchableTypeArray</code> 的偏移是 <code>000029b8</code>。</p><p>异常模块基址是 <code>00007ff71c540000</code>，所以 <code>CatchableTypeArray</code> 的地址是 <code>00007ff71c540000 + 000029b8 = 00007ff71c5429b8</code>。</p></li><li><p>获取 <code>CatchableType</code> 的地址。<code>CatchableTypeArray + 0x04</code> 保存了第一个 <code>CatchableType</code> 对象的<strong>偏移</strong>，<code>CatchableTypeArray + 0x08</code> 保存了第二个 <code>CatchableType</code> 对象的<strong>偏移</strong>，以此类推。</p><p>在 <code>windbg</code> 中输入 <code>dd 00007ff71c5429b8</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-CatchableTypeArray.png" alt="view-CatchableTypeArray"></p><p>由上图可知，一共有两个 <code>CatchableType</code> 类型的对象，第一个偏移是 <code>000029d0</code>，第二个偏移是 <code>000029f8</code>。</p><p>异常模块基址是 <code>00007ff71c540000</code>，所以第一个 <code>CatchableType</code> 对象的地址是 <code>00007ff71c540000 + 000029d0 = 00007ff71c5429d0</code>。</p></li><li><p>获取 <code>TypeDescriptor</code> 的地址。<code>CatchableType + 0x04</code> 保存了 <code>TypeDescriptor</code> 的偏移。</p><p>在 <code>windbg</code> 中输入 <code>dd 00007ff71c5429d0</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-CatchableType.png" alt="view-CatchableType"></p><p>由上图红色高亮部分可知 <code>TypeDescriptor</code> 的偏移是 <code>00004058</code>。</p><p>异常模块基址是 <code>00007ff71c540000</code>，所以 <code>TypeDescriptor</code> 的地址是 <code>00007ff71c540000 + 00004058 = 00007ff71c544058</code>。</p></li><li><p>获取异常类型名。<code>TypeDescriptor + 0x10</code> 保存了编码后的异常类型名。</p><p>在 <code>windbg</code> 中输入 <code>da 00007ff71c544058 + 0x10</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-TypeDescriptor.png" alt="view-TypeDescriptor"></p><p>从上图可知，异常类型是 <code>.?AVbad_alloc@std@@</code>，也就是 <code>std::bad_alloc</code>。</p></li></ol><h3 id="32-位程序"><a href="#32-位程序" class="headerlink" title="32 位程序"></a>32 位程序</h3><p><code>32</code> 位程序和 <code>64</code> 位程序定位过程大同小异，只需要把 <code>64</code> 位程序定位过程中的偏移值当成地址使用即可。这里就不赘述了，参考下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-exception-type-32-bit.png" alt="view-exception-type-32-bit"></p><p>其实，对于 <code>32</code> 位程序，如果有 <code>vcruntimexxx.dll</code> 对应的符号，还有一种极其简单的方法，在 <code>windbg</code> 中输入 <code>dt -r3 ThrowInfo address</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-exception-type-by-dt-r3.png" alt="view-exception-type-by-dt-r3"></p><h2 id="有调试符号"><a href="#有调试符号" class="headerlink" title="有调试符号"></a>有调试符号</h2><p>对于有调试符号的情况，不仅可以使用无调试符号的定位方法，还可以使用更简单的方法查看——通过查看 <code>pExceptionObject</code> 对象的虚函数表来推断对应的对象类型。</p><p>在测试程序中，<code>pExceptionObject</code> 的地址是 <code>0x000000b9f2effc00</code>，可以在 <code>windbg</code> 中执行 <code>dps 0x000000b9f2effc00</code> 即可查看异常对象对应的虚表，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-exception-object-vtable.png" alt="view-exception-object-vtable"></p><p>从上图可知，异常类型是 <code>std::bad_alloc</code>，其虚表内容都是其基类（<code>std::exception</code>）的虚函数，因为  <code>std::bad_alloc</code> 没重写任何虚函数，也没新增任何虚函数。</p><p>为什么没调试符号的时候不能用这个方法呢？因为没有调试符号的情况下，从 <code>dps</code> 的输出结果中看不到关键的虚表名称，也就不能推断出具体的异常类型了。</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/dps-result-no-symbol.png" alt="dps-result-no-symbol"></p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>对应的程序源码工程文件及对应的转储文件已经上传到我的个人仓库了，感兴趣的小伙伴儿可以从以下链接自行下载：</p><p><a href="https://github.com/bianchengnan/MyBlogStuff/tree/master/search-throwing-exception-from-dump-file-part2/TestThrowException" target="_blank" rel="noopener">https://github.com/bianchengnan/MyBlogStuff/tree/master/search-throwing-exception-from-dump-file-part2/TestThrowException</a></p><p>还有一个更真实的转储文件，可以实战一把。因为比较大，我传到百度云了，可以到这里下载：</p><p><a href="https://pan.baidu.com/s/1K7FzsseMlU6kmrMwm3jn4Q?pwd=8t47" target="_blank" rel="noopener">https://pan.baidu.com/s/1K7FzsseMlU6kmrMwm3jn4Q?pwd=8t47</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>获取通过 <code>throw</code> 抛出的异常的突破点在 <code>_CxxThrowException()</code> 函数，该函数有源码，涉及到的关键结构体都有源码可以查询。</li><li>查找 <code>throw</code> 抛出的异常，关在是掌握对应的数据结构，务必要把关键的数据结构牢记于心。</li><li>如果有调试符号，还可以直接查看  <code>pExceptionObject</code> 对象的虚函数表来进行推断。</li><li>在解析过程中，需要注意的是在 <code>64</code> 位程序中，很多成员变量都是相对于发生异常模块的偏移，而不是直接可用的地址，需要先把偏移转换成虚拟地址后再使用。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>vs</code> 源码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;我在&lt;a href=&quot;https://bianchengnan.github.io/articles/search-throwing-exception-from-dump-file-part1/&quot;&gt;上一篇文章&lt;/a&gt;中介绍了定位抛出异常的理论知识，本文会通过几个实例介绍各种情况下的定位方法。有调试符号如何定位？没有调试符号如何定位？&lt;code&gt;32&lt;/code&gt; 位程序如何定位？&lt;code&gt;64&lt;/code&gt; 位程序又该如何定位？&lt;/p&gt;
&lt;p&gt;其实，&lt;code&gt;32&lt;/code&gt; 位程序和 &lt;code&gt;64&lt;/code&gt; 位程序定位过程大同小异，只不过在解析过程中需要注意，很多关键字段在 &lt;code&gt;64&lt;/code&gt; 位程序中是偏移，需要加上模块基址得到虚拟地址后才能使用，而在 &lt;code&gt;32&lt;/code&gt; 位程序中对应的字段就是虚拟地址，可以直接使用。&lt;/p&gt;
&lt;p&gt;没有调试符号的时候定位异常类型会比较困难，需要根据上一篇文章中总结的步骤一步步的找到异常类型。有调试符号的情况会比较容易，有很多简便的查看方法。&lt;/p&gt;
&lt;p&gt;一起来实战吧！&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="异常" scheme="https://bianchengnan.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="转储文件" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6/"/>
    
      <category term="part2" scheme="https://bianchengnan.github.io/tags/part2/"/>
    
      <category term="exception" scheme="https://bianchengnan.github.io/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 从转储文件找出抛出的异常 —— 理论</title>
    <link href="https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part1/"/>
    <id>https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part1/</id>
    <published>2023-12-30T00:36:41.000Z</published>
    <updated>2025-12-13T05:48:33.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近在分析转储文件时，遇到了一个由 <code>throw</code> 抛出的异常。尽管在 <code>windbg</code> 中使用 <code>!analyze -v</code> 迅速知道了异常码是 <code>0xe06d7363</code>（对应的 <code>ASCII</code> 码是 <code>.msc</code>），但是根据异常码并不能确定具体抛出来的是哪种异常。针对这种情况，确定具体的异常类型才有意义。</p><p>本篇文章会简单介绍与抛出异常相关的内容，包括关键的函数及结构体。下一篇文章会通过实例介绍几种典型情况（有调试符号 / 没有调试符号 / <code>32</code> 位程序 / <code>64</code> 位程序）下的定位方法。</p><a id="more"></a><blockquote><p><strong>说明：</strong> 对源码不感兴趣的小伙伴而可以直接跳到【解析方法小结】查看结论。</p></blockquote><h2 id="突破口"><a href="#突破口" class="headerlink" title="突破口"></a>突破口</h2><p><code>throw</code> 关键字编译后对应的函数是 <code>_CxxThrowException()</code>，该函数内部会通过 <code>RaiseException()</code> 触发异常。<code>_CxxThrowException()</code> 是有源码可查的，我们可以从这个函数入手，先来熟悉下这个函数以及相关的结构体。</p><h2 id="CxxThrowException"><a href="#CxxThrowException" class="headerlink" title="_CxxThrowException"></a>_CxxThrowException</h2><p>该函数定义在 <code>vs</code> 自带的 <code>throw.cpp</code> 中，一般在 <code>crt\src\vcruntime\</code> 目录下。直接用 <code>everything</code> 搜索 <code>throw.cpp</code>，然后打开即可。<code>vs2019</code> 中的实现代码如下，有删减：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(noreturn) <span class="keyword">void</span> __stdcall</span><br><span class="line">_CxxThrowException(</span><br><span class="line">  <span class="keyword">void</span>*       pExceptionObject, <span class="comment">// The object thrown</span></span><br><span class="line">  _ThrowInfo* pThrowInfo        <span class="comment">// Everything we need to know about it</span></span><br><span class="line">) &#123;</span><br><span class="line">    EHTRACE_ENTER_FMT1(<span class="string">"Throwing object @ 0x%p"</span>, pExceptionObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> EHExceptionRecord ExceptionTemplate = &#123; <span class="comment">// A generic exception record</span></span><br><span class="line">      EH_EXCEPTION_NUMBER,       <span class="comment">// Exception number</span></span><br><span class="line">      EXCEPTION_NONCONTINUABLE,  <span class="comment">// Exception flags (we don't do resume)</span></span><br><span class="line">      <span class="literal">nullptr</span>,                   <span class="comment">// Additional record (none)</span></span><br><span class="line">      <span class="literal">nullptr</span>,                   <span class="comment">// Address of exception (OS fills in)</span></span><br><span class="line">      EH_EXCEPTION_PARAMETERS,   <span class="comment">// Number of parameters</span></span><br><span class="line">      &#123; EH_MAGIC_NUMBER1,        <span class="comment">// Our version control magic number</span></span><br><span class="line">        <span class="literal">nullptr</span>,                 <span class="comment">// pExceptionObject</span></span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">#<span class="keyword">if</span> EH_EXCEPTION_PARAMETERS == <span class="number">4</span></span><br><span class="line">        <span class="literal">nullptr</span>                  <span class="comment">// Image base of thrown object</span></span><br><span class="line">#endif</span><br><span class="line">      &#125;                          <span class="comment">// pThrowInfo</span></span><br><span class="line">    &#125;;</span><br><span class="line">    EHExceptionRecord ThisException = ExceptionTemplate; <span class="comment">// This exception</span></span><br><span class="line"></span><br><span class="line">    ThrowInfo* pTI = (ThrowInfo*)pThrowInfo;</span><br><span class="line">    <span class="comment">// deleted ...</span></span><br><span class="line">    </span><br><span class="line">    ThisException.params.pExceptionObject = pExceptionObject;</span><br><span class="line">    ThisException.params.pThrowInfo = pTI;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">    PVOID ThrowImageBase = RtlPcToFileHeader((PVOID)pTI, &amp;ThrowImageBase);</span><br><span class="line">    ThisException.params.pThrowImageBase = ThrowImageBase;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// deleted ...</span></span><br><span class="line"></span><br><span class="line">    EHTRACE_EXIT;</span><br><span class="line">    RaiseException( ThisException.ExceptionCode,</span><br><span class="line">      ThisException.ExceptionFlags,</span><br><span class="line">      ThisException.NumberParameters,</span><br><span class="line">      (PULONG_PTR)&amp;ThisException.params );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码可知， <code>_CxxThrowException()</code> 内部会调用 <code>RaiseException()</code>，<code>RaiseException()</code> 的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">RaiseException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD dwExceptionCode,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD dwExceptionFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD nNumberOfArguments,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_reads_opt_(nNumberOfArguments) CONST ULONG_PTR* lpArguments</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p> <code>_CxxThrowException</code> 调用 <code>RaiseException()</code> 时传递的各个参数值如下：</p><ul><li><p><code>dwExceptionCode</code> 的值是 <code>EH_EXCEPTION_NUMBER</code>，对应的十六进制值是 <code>0xe06d7363</code>，也就是 <code>.msc</code>。</p></li><li><p><code>dwExceptionFlags</code> 的值是 <code>EXCEPTION_NONCONTINUABLE</code>，对应的十六进制值是 <code>0x1</code>。</p></li><li><p><code>nNumberOfArguments</code> 的值是 <code>EH_EXCEPTION_PARAMETERS</code>，在 <code>32</code> 位程序中是 <code>3</code>，在 <code>64</code> 位程序中是 <code>4</code>。定义如下：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(_M_AMD64) || defined(_M_ARM) || defined(_M_ARM64)) &amp;&amp; !defined(_CHPE_X86_ARM64_EH_)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH_EXCEPTION_PARAMETERS 4  <span class="comment">// Number of parameters in exception record</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH_EXCEPTION_PARAMETERS 3  <span class="comment">// Number of parameters in exception record</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>lpArguments</code> 指向具体的参数，来自 <code>ThisException.params</code>。<code>ThisException</code> 的类型是 <code>EHExceptionRecord</code>，其定义如下：</li></ul><h2 id="EHExceptionRecord"><a href="#EHExceptionRecord" class="headerlink" title="EHExceptionRecord"></a>EHExceptionRecord</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHExceptionRecord</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>ExceptionCode;  <span class="comment">// The code of this exception. (= EH_EXCEPTION_NUMBER)</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>ExceptionFlags;<span class="comment">// Flags determined by NT</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span>* <span class="title">ExceptionRecord</span>;</span> <span class="comment">// An extra exception record (not used)</span></span><br><span class="line">  <span class="keyword">void</span>* ExceptionAddress;  <span class="comment">// Address at which exception occurred</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> NumberParameters; <span class="comment">// Number of extended parameters. (= EH_EXCEPTION_PARAMETERS)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">EHParameters</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> magicNumber; <span class="comment">// = EH_MAGIC_NUMBER1</span></span><br><span class="line">    <span class="keyword">void</span> * pExceptionObject;   <span class="comment">// Pointer to the actual object thrown</span></span><br><span class="line">    ThrowInfo* pThrowInfo;     <span class="comment">// Description of thrown object</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">  <span class="keyword">void</span> * pThrowImageBase;    <span class="comment">// Image base of thrown object</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; params; <span class="comment">// &lt;-----</span></span><br><span class="line"></span><br><span class="line">&#125; EHExceptionRecord;</span><br></pre></td></tr></table></figure><p>根据定义可知，<code>ThisException.params</code> 的类型是 <code>EHExceptionRecord::EHParameters</code>，如果 <code>_EH_RELATIVE_TYPEINFO</code> 为 <code>0</code>，则包含 <code>3</code> 个成员，否则就会包含第 4 个成员 <code>pThrowImageBase</code>。</p><p>而 <code>_EH_RELATIVE_TYPEINFO</code> 在 <code>32</code> 位程序中是 <code>0</code>，在 <code>64</code> 位程序中是 <code>1</code>，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_CEE_PURE) || defined(BUILDING_C1XX_FORCEINCLUDE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 0  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_CHPE_X86_ARM64_EH_)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 0  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_M_ARM)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 1  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_M_AMD64) || defined(_M_ARM64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 1  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 0  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>EHExceptionRecord::EHParameters</code> 结构体的成员数量与调用 <code>RaiseException()</code> 时的 <code>nNumberOfArguments</code> 参数值是对应的。</p><p>在 <code>32</code> 位程序中，<code>nNumberOfArguments</code> 的值是 <code>3</code>，<code>EHExceptionRecord::EHParameters</code> 刚好有 <code>3</code> 个成员，在 <code>64</code> 位程序中 <code>nNumberOfArguments</code> 的值是 <code>4</code>，<code>EHExceptionRecord::EHParameters</code> 刚好有 <code>4</code> 个成员。</p><p><code>EHExceptionRecord::EHParameters</code> 中的 <code>pExceptionObject</code> 和 <code>pThrowInfo</code> 是查找异常类型的关键。</p><p>其中，<code>pExceptionObject</code> 是异常对象的地址，<code>pThrowInfo</code> 的类型是 <code>ThrowInfo</code>，用来描述异常对象的类型信息。一起来看看 <code>ThrowInfo</code> 的定义。</p><h2 id="ThrowInfo"><a href="#ThrowInfo" class="headerlink" title="ThrowInfo"></a>ThrowInfo</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">s_ThrowInfo</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> attributes; <span class="comment">// Throw Info attributes (Bit field)</span></span><br><span class="line">  PMFN pmfnUnwind; <span class="comment">// Destructor to call when exception has been handled or aborted</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO &amp;&amp; !defined(BUILDING_C1XX_FORCEINCLUDE)</span></span><br><span class="line">  <span class="keyword">int</span> pForwardCompat;  <span class="comment">// Image relative offset of Forward compatibility frame handler</span></span><br><span class="line">  <span class="keyword">int</span> pCatchableTypeArray; <span class="comment">// Image relative offset of CatchableTypeArray</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> (__cdecl * pForwardCompat)(...); <span class="comment">// Forward compatibility frame handler</span></span><br><span class="line">  CatchableTypeArray* pCatchableTypeArray; <span class="comment">// Pointer to list of pointers to types</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; ThrowInfo;</span><br></pre></td></tr></table></figure><ul><li><p><code>pmfnUnwind</code> 是处理异常时会调用的回卷函数，一般是析构函数，可以根据此值判断异常对象的类型！</p></li><li><p><code>pForwardCompat</code> 一般情况下都是 <code>0</code>，不用太关心</p></li><li><p><code>pCatchableTypeArray</code> <strong>非常重要</strong>，记录了类型信息</p></li></ul><p><code>_EH_RELATIVE_TYPEINFO</code> 在上面已经贴出来了，在 <code>32</code> 位程序中被定义为 <code>0</code>，在 <code>64</code> 位程序中被定义为 <code>1</code>。</p><p>所以，<code>pForwardCompat</code> 和 <code>pCatchableTypeArray</code> 在 <code>32</code> 位程序中是地址，在 <code>64</code> 位程序中是偏移。</p><p>还记得 <code>EHExceptionRecord::EHParameters</code> 在 <code>64</code> 位程序中有 <code>4</code> 个成员吗？第 <code>4</code> 个成员就是抛出异常对应的模块基址，用这个基址加上这里的偏移就得到了对应成员在内存中的位置。<strong>一定要记住这个结论</strong>，在分析 <code>64</code> 位程序的异常对象类型时会用到！</p><p>接下来看看关键的 <code>CatchableTypeArray</code> 类型的定义，摘录如下：</p><h2 id="CatchableTypeArray"><a href="#CatchableTypeArray" class="headerlink" title="CatchableTypeArray"></a>CatchableTypeArray</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">s_CatchableTypeArray</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nCatchableTypes;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">  <span class="keyword">int</span> arrayOfCatchableTypes[];<span class="comment">// Image relative offset of Catchable Types</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  CatchableType* arrayOfCatchableTypes[];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; CatchableTypeArray;</span><br></pre></td></tr></table></figure><ul><li><code>nCatchableTypes</code> 记录了数组 <code>arrayOfCatchableTypes</code> 的数量。</li><li><code>arrayOfCatchableTypes</code> 记录了异常类型信息。同样的，在 <code>32</code> 位程序中是地址，在 <code>64</code> 位程序中是偏移。</li></ul><blockquote><p><strong>说明：</strong> 这里为什么使用数组呢？因为抛出的异常可能继承自某个基类。<code>arrayOfCatchableTypes</code> 会把继承链上的所有类型信息按照从子类到基类的顺序记录下来。拿 <code>std::bad_alloc</code> 举例，它继承自 <code>std::exception</code>。所以，<code>nCatchableTypes</code> 的值为 <code>2</code>，<code>arrayOfCatchableTypes[0]</code> 记录了 <code>std::bad_alloc</code> 的类型信息，<code>arrayOfCatchableTypes[1]</code> 记录了 <code>std::exception</code> 的类型信息。</p></blockquote><p>再来看看结构体 <code>CatchableType</code> 的定义，摘录如下：</p><h2 id="CatchableType"><a href="#CatchableType" class="headerlink" title="CatchableType"></a>CatchableType</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">s_CatchableType</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> properties; <span class="comment">// Catchable Type properties (Bit field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">  <span class="keyword">int</span> pType; <span class="comment">// Image relative offset of TypeDescriptor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  TypeDescriptor* pType; <span class="comment">// Pointer to the type descriptor for this type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  PMD thisDisplacement;<span class="comment">// Pointer to instance of catch type within thrown object.</span></span><br><span class="line">  <span class="keyword">int</span> sizeOrOffset;  <span class="comment">// Size of simple-type object or offset into</span></span><br><span class="line">           <span class="comment">// buffer of 'this' pointer for catch object</span></span><br><span class="line">  PMFN copyFunction; <span class="comment">// Copy constructor or CC-closure</span></span><br><span class="line">&#125; CatchableType;</span><br></pre></td></tr></table></figure><p>我们只需要关注 <code>pType</code> 成员即可。同样的，在 <code>32</code> 位程序中是地址，在 <code>64</code> 位程序中是偏移。 <code>pType</code> 对应的类型是 <code>TypeDescriptor</code>，接下来看看 <code>TypeDescriptor</code> 的定义。</p><h2 id="TypeDescriptor"><a href="#TypeDescriptor" class="headerlink" title="TypeDescriptor"></a>TypeDescriptor</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN64) || defined(_RTTI) || defined(BUILDING_C1XX_FORCEINCLUDE)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* pVFTable; <span class="comment">// Field overloaded by RTTI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>hash; <span class="comment">// Hash value computed from type's decorated name</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">void</span>*spare; <span class="comment">// reserved, possible for RTTI</span></span><br><span class="line">  <span class="keyword">char</span> name[]; <span class="comment">// The decorated name of the type; 0 terminated.</span></span><br><span class="line">&#125; TypeDescriptor;</span><br></pre></td></tr></table></figure><p>其中，<code>name</code> 成员是经过名字改编后的异常类型，它是一个以 <code>\0</code> 结尾的字符串，可以在 <code>windbg</code> 中通过 <code>da</code> 查看。</p><p>源码有点乱，还是在 <code>windbg</code> 中看的直观舒服，还可以看到偏移。以下是  <code>32</code> 位和 <code>64</code> 位程序中对应的结构体定义：</p><h2 id="关键结构"><a href="#关键结构" class="headerlink" title="关键结构"></a>关键结构</h2><h3 id="32-位关键结构"><a href="#32-位关键结构" class="headerlink" title="32 位关键结构"></a>32 位关键结构</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">TestThrowException!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr32 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">TestThrowException!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pExceptionObject : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> pThrowInfo       : Ptr32 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">TestThrowException!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Ptr32     <span class="keyword">int</span> </span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Ptr32 _s_CatchableTypeArray <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableTypeArray</span><br><span class="line">TestThrowException!_s_CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Ptr32 _s_CatchableType <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableType</span><br><span class="line">TestThrowException!_s_CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Ptr32 TypeDescriptor <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Ptr32     <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">TestThrowException!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> hash             : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> spare            : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><h3 id="64-位关键结构"><a href="#64-位关键结构" class="headerlink" title="64 位关键结构"></a>64 位关键结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">VCRUNTIME140!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr64 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x010</span> ExceptionAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x018</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x020</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">VCRUNTIME140!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> pExceptionObject : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> pThrowInfo       : Ptr64 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x018</span> pThrowImageBase  : Ptr64 Void</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">VCRUNTIME140!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Int4B</span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Int4B</span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableTypeArray</span><br><span class="line">VCRUNTIME140!CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableType</span><br><span class="line">VCRUNTIME140!CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Int4B <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Int4B</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">VCRUNTIME140!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> pVFTable         : Ptr64 Void</span><br><span class="line">   +<span class="number">0x008</span> spare            : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>划重点：</strong> 务必记住以上结构体的定义，尤其是关键字段的偏移。这是解析的依据！</p></blockquote><h2 id="解析方法小结"><a href="#解析方法小结" class="headerlink" title="解析方法小结"></a>解析方法小结</h2><ol><li><p>先找到 <code>EHParameters</code> 类型的对象（可省略此步）</p><p>可以通过 <code>RaiseException()</code> 的第四个参数查找。</p><p>在 <code>32</code> 位程序中，定位方法非常简单，可以直接查看 <code>RaiseException()</code> 的第 <code>4</code> 个参数，<code>ebp+0x14</code>。</p><p>在 <code>x64</code> 位中可以通过 <code>_CxxThrowException()</code> 的 <code>rsp + 0x28</code> 定位。因为在调用 <code>RaiseException()</code> 的时候， <code>_CxxThrowException()</code> 会把此参数存在自己栈帧中 <code>rsp + 0x28</code> 的位置。</p></li></ol><ol start="2"><li><p>再找到  <code>ThrowInfo</code> 类型的对象</p><p>解析 <code>EHParameters</code> 中的第 <code>3</code> 个成员 <code>pThrowInfo</code>，在 <code>32</code> 位程序中偏移是 <code>0x8</code>，在 <code>64</code> 位程序中偏移是 <code>0x10</code>。</p><blockquote><p><strong>说明：</strong> 还有两种查看方法： </p><ol><li><p>对于 <code>32</code> 位程序可以通过 <code>_CxxThrowException()</code> 对应栈帧的第 <code>2</code> 个参数（<code>ebp+c</code>）直接查看。</p></li><li><p>如果有 <code>vcruntimexxx.dll</code> 的调试符号，可以直接切到 <code>_CxxThrowException()</code> 对应的栈帧，<code>windbg</code> 会自动帮忙列出对应的值。 </p></li></ol></blockquote></li></ol><ol start="3"><li><p>再找到 <code>CatchableTypeArray</code> 类型的对象</p><p>解析 <code>ThrowInfo</code> 的第 <code>4</code> 个成员 <code>pCatchableTypeArray</code>，其偏移是 <code>0xc</code>（<code>32</code>位 <code>64</code> 位通用）。</p><p><strong>需要注意的是，此成员在 <code>32</code> 位程序中是地址；在 <code>64</code> 位程序中是偏移，需要加上镜像基址得到最终的地址。</strong></p></li></ol><ol start="4"><li><p>再找到 <code>CatchableType</code> 类型的对象</p><p>解析 <code>CatchableTypeArray</code> 的第 <code>2</code>个成员 <code>arrayOfCatchableTypes</code> ，偏移是 <code>0x4</code>（<code>32</code>位 <code>64</code> 位通用）。</p><p>该成员记录了 <code>CatchableType</code> 数组的首地址或者偏移。</p><p><strong>需要注意的是，此成员在 <code>32</code> 位程序中是地址；在 <code>64</code> 位程序中是偏移，需要加上镜像基址得到最终的地址。</strong></p><blockquote><p><strong>说明：</strong> 第 <code>1</code> 个成员 <code>nCatchableTypes</code> 记录了 <code>CatchableType</code> 数组的个数。</p></blockquote></li></ol><ol start="5"><li><p>再找到 <code>TypeDescriptor</code> 类型的对象</p><p>解析 <code>CatchableType</code> 数组中的每个对象（其实，只需要解析第一个即可）。重点关注第 <code>2</code> 个成员 <code>pType</code>，偏移是 <code>0x4</code>（<code>32</code>位 <code>64</code> 位通用）。</p><p><strong>需要注意的是，此成员在 <code>32</code> 位程序中是地址；在 <code>64</code> 位程序中是偏移，需要加上镜像基址得到最终的地址。</strong></p></li></ol><ol start="6"><li><p>最后找到异常类型名</p><p>解析 <code>TypeDescriptor</code> 对象，只需要关注第 <code>3</code> 个成员 <code>name</code> 成员即可，在 <code>32</code> 位程序中偏移是 <code>0x8</code>，在 <code>64</code> 位程序中偏移是 <code>0x10</code>。</p><p>它是一个以 <code>\0</code> 结尾的字符串，可以在 <code>windbg</code> 用 <code>da</code> 显示其内容。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>throw</code> 对应的实现函数是 <code>_CxxThrowException()</code> 函数，该函数定义在 <code>throw.cpp</code> 中，可以查看源码。</li><li><code>_CxxThrowException()</code> 内部会调用 <code>RaiseException()</code>，调用时传递的错误码是 <code>0xe06d7363</code>（对应的字符是 <code>.msc</code>）。</li><li>【关键结构】中的结构体是解析时的依据，务必要熟悉。</li><li>【解析方法小结】中总结的方法是通用方法，适用于任何情况。在实际解析过程中还可以利用虚表等其它相关信息进行解析。</li><li>在解析过程中，需要注意的是在 <code>64</code> 位程序中，很多成员变量都是相对于发生异常模块的偏移，而不是直接可用的地址，需要先把偏移转换成虚拟地址后再使用。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>vs</code> 源码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近在分析转储文件时，遇到了一个由 &lt;code&gt;throw&lt;/code&gt; 抛出的异常。尽管在 &lt;code&gt;windbg&lt;/code&gt; 中使用 &lt;code&gt;!analyze -v&lt;/code&gt; 迅速知道了异常码是 &lt;code&gt;0xe06d7363&lt;/code&gt;（对应的 &lt;code&gt;ASCII&lt;/code&gt; 码是 &lt;code&gt;.msc&lt;/code&gt;），但是根据异常码并不能确定具体抛出来的是哪种异常。针对这种情况，确定具体的异常类型才有意义。&lt;/p&gt;
&lt;p&gt;本篇文章会简单介绍与抛出异常相关的内容，包括关键的函数及结构体。下一篇文章会通过实例介绍几种典型情况（有调试符号 / 没有调试符号 / &lt;code&gt;32&lt;/code&gt; 位程序 / &lt;code&gt;64&lt;/code&gt; 位程序）下的定位方法。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="异常" scheme="https://bianchengnan.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="转储文件" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6/"/>
    
      <category term="part1" scheme="https://bianchengnan.github.io/tags/part1/"/>
    
      <category term="exception" scheme="https://bianchengnan.github.io/tags/exception/"/>
    
  </entry>
  
</feed>
