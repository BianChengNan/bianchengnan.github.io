<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BianChengNan&#39;s Blog</title>
  
  <subtitle>Coding is hard, you can make it easy!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bianchengnan.github.io/"/>
  <updated>2026-02-16T10:40:27.506Z</updated>
  <id>https://bianchengnan.github.io/</id>
  
  <author>
    <name>BianChengNan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>置顶声明</title>
    <link href="https://bianchengnan.github.io//articles/top-most-announcement/"/>
    <id>https://bianchengnan.github.io//articles/top-most-announcement/</id>
    <published>2029-03-01T01:29:14.000Z</published>
    <updated>2026-02-16T10:40:27.506Z</updated>
    
    <content type="html"><![CDATA[<p>实在抱歉，因为图片使用的是 <code>http</code> 链接，在 <code>chrome</code> 或者 <code>edge</code> 浏览器中打开本博客的时候，看不到文章中的图片。</p><p>可以在 <code>chrome</code> 中通过 <code>chrome://flags</code> （在 <code>edge</code> 中通过 <code>edge://flags</code>）启用 <code>Insecure origins treated as secure</code>，</p><p>并且把图床地址 <a href="http://resources.bianchengnan.tech" target="_blank" rel="noopener">http://resources.bianchengnan.tech</a> 加入到信任列表的方式查看图片。（非常感谢群友 张帆 的提示）</p><p>整个操作如下图：</p><p><img src="http://resources.bianchengnan.tech/top-most-announcement/enable-show-image-in-chrome.png" alt="enable-show-image-in-chrome"></p><p>如果还不能查看相关图片，请联系我，或者到我的公众号里查看。</p><p>我的个人微信号是 <code>BianChengNan</code>，公众号是 <code>编程难</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实在抱歉，因为图片使用的是 &lt;code&gt;http&lt;/code&gt; 链接，在 &lt;code&gt;chrome&lt;/code&gt; 或者 &lt;code&gt;edge&lt;/code&gt; 浏览器中打开本博客的时候，看不到文章中的图片。&lt;/p&gt;
&lt;p&gt;可以在 &lt;code&gt;chrome&lt;/code&gt; 中通过 
      
    
    </summary>
    
      <category term="原" scheme="https://bianchengnan.github.io/categories/%E5%8E%9F/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 谁“锁”住了我的 SpaceSniffer？一次由 Shell 扩展引发的 Windows 死锁侦探之旅</title>
    <link href="https://bianchengnan.github.io//articles/debug-spacesniffer-deadlock/"/>
    <id>https://bianchengnan.github.io//articles/debug-spacesniffer-deadlock/</id>
    <published>2026-02-16T10:16:45.000Z</published>
    <updated>2026-02-16T10:40:27.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在一次使用 <code>SpaceSniffer</code> 分析磁盘占用时，我遇到了一个非常容易复现的界面卡死问题。为查明原因，我首先通过 <code>procdump</code> 周期性保存完整转储文件，并使用 <code>WinDbg</code> 对调用栈进行对比分析，确认程序确实陷入阻塞而非假死。逐层追踪后，我最终将问题定位到第三方 <code>Shell</code> 扩展在 <code>COM</code> 激活过程中的异常阻塞，并由此引发死锁。</p><a id="more"></a><h2 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h2><p>遇到卡死问题，可以先使用 <code>process explorer</code> 观察一下线程运行情况，看看是假死，还是真的卡死了。还可以隔一段时间抓取一个转储文件，如果几次转储文件的调用栈都一样，大概率是真的卡死了。</p><p><code>procdump</code> 有一个非常方便的功能，可以每隔一段时间自动保存转储文件，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump.exe -ma -n 3 -s 5 SpaceSniffer.exe</span><br></pre></td></tr></table></figure><p>以上命令可以每隔 <code>5</code> 秒（<code>-s 5</code>）为 <code>SpaceSniffer.exe</code> 保存一份<strong>完整</strong>（<code>-ma</code>）转储文件，一共保存 <code>3</code> 次（<code>-n 3</code>）。效果如下：</p><p><img src="http://resources.bianchengnan.tech/debug-spacesniffer-deadlock/save-dump-files-by-procdump.png" alt="save-dump-files-by-procdump"></p><p>简单查看保存的三份转储文件，发现调用栈是一样的，大概率是真卡死了。用 <code>windbg</code> 打开其中一份转储文件，进行分析。</p><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>执行 <code>~* kn</code> 命令查看所有线程的调用栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ~* kvn</span><br><span class="line"></span><br><span class="line">.  0  Id: 2620.5e4 Suspend: 0 Teb: 00383000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 0019bb38 764f2839     00000730 00000000 00000000 ntdll!NtWaitForSingleObject+0xc (FPO: [3,0,0])</span><br><span class="line">01 0019bbac 764f2792     00000730 ffffffff 00000000 KERNELBASE!WaitForSingleObjectEx+0x99 (FPO: [SEH])</span><br><span class="line">02 0019bbc0 76d5a11a     00000730 ffffffff 0019bc7c KERNELBASE!WaitForSingleObject+0x12 (FPO: [Non-Fpo])</span><br><span class="line">03 0019bc28 76d5a008     00000208 756d1cc0 00000000 SHCore!_CreateThreadWorker+0x10e (FPO: [Non-Fpo])</span><br><span class="line">04 0019bc3c 756d20ee     756d2170 0019bc60 00000208 SHCore!SHCreateThread+0x18 (FPO: [Non-Fpo])</span><br><span class="line">05 0019bc68 756d25f4     0019bc7c 752f79f0 00000000 windows_storage!GetItemHandlerCache+0x7e (FPO: [Non-Fpo])</span><br><span class="line">06 0019bc94 756d1fa4     0019bcc0 00000000 00000000 windows_storage!SyncGetItemHandlerThreadProc+0x44 (FPO: [Non-Fpo])</span><br><span class="line">07 0019bce8 75459c0f     00000000 7522d51c 7523651c windows_storage!GetHandlerFromCache+0xe3 (FPO: [Non-Fpo])</span><br><span class="line">08 0019bdb0 752d9374     00000000 7522d5e4 00000000 windows_storage!CFileSysItemString::LoadHandler+0x15dbfe</span><br><span class="line">09 0019c074 752d6a56     00948878 00948882 00000000 windows_storage!CFSFolder::_CreatePerInstanceDefExtIcon+0x96 (FPO: [Non-Fpo])</span><br><span class="line">0a 0019c340 752d696e     00948878 00948882 00000000 windows_storage!CFSFolder::_CreateDefExtIcon+0xe4 (FPO: [Non-Fpo])</span><br><span class="line">0b 0019c35c 752fba08     008b6e10 00000000 00000000 windows_storage!CFSFolder::s_GetExtractIcon+0x1e (FPO: [Non-Fpo])</span><br><span class="line">0c 0019c63c 752d43ac     00000000 00000001 0019c66c windows_storage!CFSFolder::_BindHandler+0xcd8 (FPO: [Non-Fpo])</span><br><span class="line">0d 0019c674 7544e680     008b6e6c 00948878 00000000 windows_storage!CFSFolder::GetThumbnailHandler+0x4c (FPO: [Non-Fpo])</span><br><span class="line">0e 0019c6d4 752b351b     0778b88c 00948878 00000000 windows_storage!CRegFolder::GetThumbnailHandler+0x17a4b0</span><br><span class="line">0f 0019c764 75344f04     078a63fc 00000000 752365ac windows_storage!_CreateThumbnailHandler+0x9b (FPO: [Non-Fpo])</span><br><span class="line">10 0019ca34 752d5831     078a63fc 00000000 752365ac windows_storage!CShellItem::BindToHandler+0x864 (FPO: [Non-Fpo])</span><br><span class="line">11 0019ca88 752d577f     00000002 0019caa8 0019cbb8 windows_storage!GetExtractIconW+0x73 (FPO: [Non-Fpo])</span><br><span class="line">12 0019cad0 75291084     00000000 0019cb20 7fb7eb65 windows_storage!_GetILIndexFromItem+0x5d (FPO: [Non-Fpo])</span><br><span class="line">13 0019cb70 752db5de     20000004 00000000 0019cbb8 windows_storage!CShellItem::_GetIcon+0x72 (FPO: [Non-Fpo])</span><br><span class="line">14 0019cbec 7529427b     078a5800 00000000 00000000 windows_storage!CShellItem::GetSharedBitmap+0xfe (FPO: [Non-Fpo])</span><br><span class="line">15 0019cc3c 76b0ea6a     078a5800 00000000 00000000 windows_storage!CShellItem::GetImage+0x6b (FPO: [Non-Fpo])</span><br><span class="line">16 0019ccf8 76b0dbed     0093a1c8 00000007 76b0dba0 shell32!CIncludeInLibraryContextMenuHelper::_PopulateSubMenu+0x15e (FPO: [2,37,4])</span><br><span class="line">17 0019cd1c 7673417b     07877568 008bbd70 00000002 shell32!CIncludeInLibraryContextMenuHelper::OnSetChanged+0x4d (FPO: [Non-Fpo])</span><br><span class="line">18 0019cd74 76141c0b     000208d6 00000402 00000000 shell32!CShellFolderSet::s_WndProc+0x8b (FPO: [Non-Fpo])</span><br><span class="line">19 0019cda0 761382ca     767340f0 000208d6 00000402 user32!_InternalCallWinProc+0x2b</span><br><span class="line">1a 0019ce88 76137ee0     767340f0 00000000 00000402 user32!UserCallWinProcCheckWow+0x33a (FPO: [SEH])</span><br><span class="line">1b 0019ceec 7613c3af     0112fe40 00000000 00000402 user32!DispatchClientMessage+0x190 (FPO: [Non-Fpo])</span><br><span class="line">1c 0019cf28 77c356cd     0019cf44 00000020 0019d530 user32!__fnDWORD+0x3f (FPO: [Non-Fpo])</span><br><span class="line">1d 0019cf60 7630174c     76130ae4 00000000 0000c2da ntdll!KiUserCallbackDispatcher+0x4d (FPO: [0,0,0])</span><br><span class="line">1e 0019cf64 76130ae4     00000000 0000c2da 0000c2da win32u!NtUserCreateWindowEx+0xc (FPO: [17,0,0])</span><br><span class="line">1f 0019d244 761303f7     00000000 56000000 80000000 user32!VerNtUserCreateWindowEx+0x229 (FPO: [Non-Fpo])</span><br><span class="line">20 0019d32c 761302c8     00000000 56000000 80000000 user32!CreateWindowInternal+0x12b (FPO: [Non-Fpo])</span><br><span class="line">21 0019d36c 69d2e92a     00000000 0000c2da 00000000 user32!CreateWindowExW+0x38 (FPO: [Non-Fpo])</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">22 0019d3ac 69d5dc8e     fffffffd 69dd583c 00000000 YunShellExtV1+0xae92a</span><br><span class="line">23 0019d4f4 69d62663     00000001 0019d540 69d6766f YunShellExtV1+0xddc8e</span><br><span class="line">24 0019d500 69d6766f     69c80000 00000001 00000000 YunShellExtV1!DllGetClassObject+0x63</span><br><span class="line">25 0019d540 69d67741     69c80000 00000001 00000000 YunShellExtV1!DllUnregisterServer+0x4faf</span><br><span class="line">26 0019d554 77c331a6     69c80000 00000001 00000000 YunShellExtV1!DllUnregisterServer+0x5081</span><br><span class="line">27 0019d574 77c0e012     69d67725 69c80000 00000001 ntdll!LdrxCallInitRoutine+0x16</span><br><span class="line">28 0019d5c0 77c11d43     00000001 00000000 eb259821 ntdll!LdrpCallInitRoutine+0x51 (FPO: [Non-Fpo])</span><br><span class="line">29 0019d650 77c11eb1     0783d7f8 00000000 0019d70c ntdll!LdrpInitializeNode+0x135 (FPO: [Non-Fpo])</span><br><span class="line">2a 0019d674 77c12785     0019d68f 0019d718 0019d70c ntdll!LdrpInitializeGraphRecurse+0x5d (FPO: [Non-Fpo])</span><br><span class="line">2b 0019d690 77c0e542     eb2598a9 00002009 0019d8b0 ntdll!LdrpPrepareModuleForExecution+0x8f (FPO: [Non-Fpo])</span><br><span class="line">2c 0019d6d8 77c0e186     00000600 00000004 00000000 ntdll!LdrpLoadDllInternal+0x11e (FPO: [SEH])</span><br><span class="line">2d 0019d878 764f1de6     00002009 0019d8a0 0019d8b0 ntdll!LdrLoadDll+0xf6 (FPO: [Non-Fpo])</span><br><span class="line">2e 0019d8bc 75efd18f     0019d990 00000000 00002008 KERNELBASE!LoadLibraryExW+0x156 (FPO: [Non-Fpo])</span><br><span class="line">2f 0019d8e0 75efd118     00002008 0019d958 0019d990 combase!LoadLibraryWithLogging+0x1b (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\common\internal\loadfree.cxx @ 160] </span><br><span class="line">30 0019d904 75efcf2d     0019d950 0019d954 0019d958 combase!CClassCache::CDllPathEntry::LoadDll+0x45 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\dllcache.cxx @ 2341] </span><br><span class="line">31 0019d964 75efdf8a     0019d988 07792c10 00000000 combase!CClassCache::CDllPathEntry::Create+0x32 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\dllcache.cxx @ 2170] </span><br><span class="line">32 0019dbbc 75eda06e     00000001 0019df90 0019dbfc combase!CClassCache::CClassEntry::CreateDllClassEntry+0xf3 (FPO: [Non-Fpo]) (CONV: thiscall) [onecore\com\combase\objact\dllcache.cxx @ 1103] </span><br><span class="line">33 0019df14 75eab44c     0019df3c 75ee0cb0 0019e684 combase!CClassCache::GetClassObjectActivator+0x73e (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\dllcache.cxx @ 5398] </span><br><span class="line">34 0019df48 75ea8c65     0019e684 75ea8b00 00000000 combase!CClassCache::GetClassObject+0x30 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\dllcache.cxx @ 5155] </span><br><span class="line">35 (Inline) --------     -------- -------- -------- combase!CCGetClassObject+0x42 (Inline Function @ 75ea8c65) (CONV: stdcall) [onecore\com\combase\objact\dllcache.cxx @ 8366] </span><br><span class="line">36 0019e038 75eb23b5     7605f168 00000000 0019e684 combase!CServerContextActivator::CreateInstance+0x165 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\actvator.cxx @ 856] </span><br><span class="line">37 0019e084 75ea832f     0019e684 00000000 0019ed14 combase!ActivationPropertiesIn::DelegateCreateInstance+0xf5 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\actprops\actprops.cxx @ 1931] </span><br><span class="line">38 0019e0e4 75ea7aba     7605f16c 00000000 0019e684 combase!CApartmentActivator::CreateInstance+0xbf (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\actvator.cxx @ 2189] </span><br><span class="line">39 0019e110 75f40c55     7605f164 00000001 00000000 combase!CProcessActivator::CCICallback+0x5a (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\actvator.cxx @ 1645] </span><br><span class="line">3a 0019e130 75f40b0d     7605f164 0019e4b0 00000000 combase!CProcessActivator::AttemptActivation+0x35 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\actvator.cxx @ 1527] </span><br><span class="line">3b 0019e170 75f40a91     7605f164 0019e4b0 00000000 combase!CProcessActivator::ActivateByContext+0x6d (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\actvator.cxx @ 1393] </span><br><span class="line">3c 0019e1a0 75eb237d     7605f164 00000000 0019e684 combase!CProcessActivator::CreateInstance+0x61 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\actvator.cxx @ 1271] </span><br><span class="line">3d 0019e1ec 75eb2b5d     0019e684 00000000 0019ed14 combase!ActivationPropertiesIn::DelegateCreateInstance+0xbd (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\actprops\actprops.cxx @ 1931] </span><br><span class="line">3e 0019e450 75eb2384     7605f160 00000000 0019e684 combase!CClientContextActivator::CreateInstance+0xfd (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\actvator.cxx @ 570] </span><br><span class="line">3f 0019e49c 75edbde2     0019e684 00000000 0019ed14 combase!ActivationPropertiesIn::DelegateCreateInstance+0xc4 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\actprops\actprops.cxx @ 1983] </span><br><span class="line">40 0019efe0 75edb051     00000401 00000000 00000001 combase!ICoCreateInstanceEx+0xc12 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\objact.cxx @ 2032] </span><br><span class="line">41 0019f0d4 75edadbe     00000401 00000000 00000001 combase!CComActivator::DoCreateInstance+0x231 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\immact.hxx @ 401] </span><br><span class="line">42 (Inline) --------     -------- -------- -------- combase!CoCreateInstanceEx+0xa2 (Inline Function @ 75edadbe) (CONV: stdcall) [onecore\com\combase\objact\actapi.cxx @ 177] </span><br><span class="line">43 0019f110 767730f0     07835f60 00000000 00000401 combase!CoCreateInstance+0xbe (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\objact\actapi.cxx @ 121] </span><br><span class="line">44 0019f3b8 7677ebce     00000401 00000001 00000002 shell32!_SHCoCreateInstance+0x15e (FPO: [Non-Fpo])</span><br><span class="line">45 0019f598 767a0f77     00000003 0787bcc4 0787bdc4 shell32!HDXA_QueryContextMenu+0x251 (FPO: [Non-Fpo])</span><br><span class="line">46 0019f64c 00432b6e     0787bc38 07e108b7 00000000 shell32!CDefFolderMenu::QueryContextMenu+0x487 (FPO: [Non-Fpo])</span><br><span class="line">47 0019f6b4 0043305f     03294260 00886b48 0c8b281c SpaceSniffer!Ntfs_sourceFinalize+0x262</span><br><span class="line">48 0019f718 0042636b     03294260 074d8bfc 0c8b281c SpaceSniffer!Ntfs_sourceFinalize+0x753</span><br><span class="line">49 0019f778 00423d62     031c8f50 0056b58c 031c8f50 SpaceSniffer!Frmstart_sourceFinalize+0x3953</span><br><span class="line">4a 0019f7cc 004bd382     00000081 000002ae 00000010 SpaceSniffer!Frmstart_sourceFinalize+0x134a</span><br><span class="line">4b 0019f7e8 0056b5d2     00000081 000002ae 0019f9f0 SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x74ac6</span><br><span class="line">4c 0019f808 004bd419     00000081 000002ae 00000204 SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x122d16</span><br><span class="line">4d 0019f82c 004bd5a2     00000000 031c8f50 0019f9f0 SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x74b5d</span><br><span class="line">4e 0019f96c 004c1685     000706c4 031c8f50 0091dd18 SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x74ce6</span><br><span class="line">4f 0019f9b8 004c0d23     0019f9cc 004c0d3b 0019f9e8 SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x78dc9</span><br><span class="line">50 0019f9e8 0051a9aa     00000204 00000002 008102ae SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x78467</span><br><span class="line">51 0019fa00 76141c0b     000706c4 00000204 00000002 SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0xd20ee</span><br><span class="line">52 0019fa2c 761382ca     02cb097c 000706c4 00000204 user32!_InternalCallWinProc+0x2b</span><br><span class="line">53 0019fb14 76136b70     02cb097c 00000000 00000204 user32!UserCallWinProcCheckWow+0x33a (FPO: [SEH])</span><br><span class="line">54 0019fb90 761366a0     00000104 000706c4 0049e8c8 user32!DispatchMessageWorker+0x4c0 (FPO: [Non-Fpo])</span><br><span class="line">55 0019fb9c 0049e8c8     0019fbc0 00190100 0019fc0c user32!DispatchMessageW+0x10 (FPO: [Non-Fpo])</span><br><span class="line">56 0019fbb8 0049e90b     000706c4 00000204 00000002 SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x5600c</span><br><span class="line">57 0019fbdc 0049ec36     0019fbf0 0049ec40 0019fc0c SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x5604f</span><br><span class="line">58 0019fc0c 0043ce2b     00000000 005ba048 00884354 SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x5637a</span><br><span class="line">59 0019ff38 005b4443     00400000 00000000 00884354 SpaceSniffer!showCommandLineHelp$qv+0x268b</span><br><span class="line">5a 0019ff70 76fcfcc9     00380000 76fcfcb0 0019ffdc SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x16bb87</span><br><span class="line">5b 0019ff80 77c282ae     00380000 eb25b1ad 00000000 kernel32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">5c 0019ffdc 77c2827e     ffffffff 77c493c6 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">5d 0019ffec 00000000     0040187c 00380000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">   1  Id: 2620.13cc Suspend: 0 Teb: 0038f000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 02c6f38c 7650bc33     00000002 02c6f560 00000001 ntdll!NtWaitForMultipleObjects+0xc (FPO: [5,0,0])</span><br><span class="line">01 02c6f520 7650bb18     00000002 02c6f560 00000000 KERNELBASE!WaitForMultipleObjectsEx+0x103 (FPO: [SEH])</span><br><span class="line">02 02c6f53c 73f9266e     00000002 02c6f560 00000000 KERNELBASE!WaitForMultipleObjects+0x18 (FPO: [Non-Fpo])</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">03 02c6fa9c 73fa002a     fb52e036 73f9fa10 73f9fa10 cpbgrd+0x1266e</span><br><span class="line">04 02c6ff68 76fcfcc9     000002b0 76fcfcc9 000002b0 cpbgrd!X64Call+0xd79a</span><br><span class="line">05 02c6ff80 77c282ae     000002b0 e9fab1ad 00000000 kernel32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">06 02c6ffdc 77c2827e     ffffffff 77c493c6 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">07 02c6ffec 00000000     73f9fa10 000002b0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">   2  Id: 2620.1044 Suspend: 0 Teb: 00392000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 041afecc 764f2839     000002b0 00000000 041aff14 ntdll!NtWaitForSingleObject+0xc (FPO: [3,0,0])</span><br><span class="line">01 041aff40 764f2792     000002b0 000003e8 00000000 KERNELBASE!WaitForSingleObjectEx+0x99 (FPO: [SEH])</span><br><span class="line">02 041aff54 73f95bd8     000002b0 000003e8 73f95b80 KERNELBASE!WaitForSingleObject+0x12 (FPO: [Non-Fpo])</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">03 041aff70 76fcfcc9     000002b0 76fcfcb0 041affdc cpbgrd!X64Call+0x3348</span><br><span class="line">04 041aff80 77c282ae     000002b0 ef26b1ad 00000000 kernel32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">05 041affdc 77c2827e     ffffffff 77c493c6 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">06 041affec 00000000     73f95b80 000002b0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">   3  Id: 2620.2bdc Suspend: 0 Teb: 00395000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 06d5fd94 77c1204e     0000007c 00000000 00000000 ntdll!NtWaitForSingleObject+0xc (FPO: [3,0,0])</span><br><span class="line">01 06d5fdb8 77c0f9ae     ede9b029 00000000 00000000 ntdll!LdrpDrainWorkQueue+0x14f (FPO: [Non-Fpo])</span><br><span class="line">02 06d5fe58 77c2bd0c     0055a428 00000000 00000000 ntdll!LdrShutdownThread+0x7e (FPO: [SEH])</span><br><span class="line">03 06d5ff34 0055a4f6     00000000 00000000 00518378 ntdll!RtlExitUserThread+0x4c (FPO: [Non-Fpo])</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">04 06d5ff5c 0055a452     06d5ffcc 00559f28 06d5ff70 SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x111c3a</span><br><span class="line">05 06d5ff70 76fcfcc9     03294250 76fcfcb0 06d5ffdc SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x111b96</span><br><span class="line">06 06d5ff80 77c282ae     03294250 ede9b1ad 00000000 kernel32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">07 06d5ffdc 77c2827e     ffffffff 77c493c6 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">08 06d5ffec 00000000     0055a428 03294250 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">   4  Id: 2620.3a34 Suspend: 0 Teb: 00398000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 06e9fe2c 76558b20     000003d4 00000000 00000000 ntdll!NtNotifyChangeDirectoryFileEx+0xc (FPO: [10,0,0])</span><br><span class="line">01 06e9fe7c 76558b84     000003d4 0427eb80 00007fff KERNELBASE!ReadDirectoryChangesExW+0x100 (FPO: [Non-Fpo])</span><br><span class="line">02 06e9fea8 0043dda8     000003d4 0427eb80 00007fff KERNELBASE!ReadDirectoryChangesW+0x24 (FPO: [Non-Fpo])</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">03 06e9ff2c 00518319     06e9ff40 00518323 06e9ff5c SpaceSniffer!Snifthread_sourceFinalize+0x198</span><br><span class="line">04 06e9ff5c 0055a452     06e9ffcc 00559f28 06e9ff70 SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0xcfa5d</span><br><span class="line">05 06e9ff70 76fcfcc9     03294260 76fcfcb0 06e9ffdc SpaceSniffer!Unknownspacetreemapnode_sourceFinalize+0x111b96</span><br><span class="line">06 06e9ff80 77c282ae     03294260 edd5b1ad 00000000 kernel32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">07 06e9ffdc 77c2827e     ffffffff 77c493c6 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">08 06e9ffec 00000000     0055a428 03294260 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">   5  Id: 2620.2900 Suspend: 0 Teb: 003ad000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 0f29fb3c 7613934a     000208d6 00000402 00000000 win32u!NtUserMessageCall+0xc (FPO: [7,0,0])</span><br><span class="line">01 0f29fba0 7613653f     0112fe40 00000000 0353c320 user32!SendMessageWorker+0x97a (FPO: [4,13,4])</span><br><span class="line">02 0f29fc00 766fd52f     000208d6 00000402 00000000 user32!SendMessageW+0x6f (FPO: [Non-Fpo])</span><br><span class="line">03 0f29fc74 767867d4     078a7f48 0789fa90 767866b0 shell32!CShellFolderSetEnumTask::InternalResumeRT+0xdf (FPO: [Non-Fpo])</span><br><span class="line">04 0f29fc9c 752de338     078a7f48 00000000 008bd1d0 shell32!CRunnableTask::Run+0x124 (FPO: [Non-Fpo])</span><br><span class="line">05 0f29fcb4 752ddf5c     0f29fcd0 00cedc98 008bd1d0 windows_storage!CShellTask::TT_Run+0x3d (FPO: [Non-Fpo])</span><br><span class="line">06 0f29fcf8 752ddd1e     752ddce0 0789fb28 003adf60 windows_storage!CShellTaskThread::ThreadProc+0x9b (FPO: [Non-Fpo])</span><br><span class="line">07 0f29fd20 76d5c4f9     008bd1d0 76d5c4e0 7ffe0386 windows_storage!CShellTaskThread::s_ThreadProc+0x3e (FPO: [Non-Fpo])</span><br><span class="line">08 0f29fd34 77c29cc0     00cedc98 e415b3cd 008807c0 SHCore!ExecuteWorkItemThreadProc+0x19 (FPO: [Non-Fpo])</span><br><span class="line">09 0f29fdbc 77bf612a     0f29fe9c 0789fb28 e415b101 ntdll!RtlpTpWorkCallback+0x120 (FPO: [SEH])</span><br><span class="line">0a 0f29ff70 76fcfcc9     008807c0 76fcfcb0 0f29ffdc ntdll!TppWorkerThread+0x6ea (FPO: [SEH])</span><br><span class="line">0b 0f29ff80 77c282ae     008807c0 e415b1ad 00000000 kernel32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">0c 0f29ffdc 77c2827e     ffffffff 77c493c6 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">0d 0f29ffec 00000000     77bf5a40 008807c0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">   6  Id: 2620.3840 Suspend: 0 Teb: 003b0000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 0f39fdb0 77bf5ce0     00000058 07840048 00000010 ntdll!NtWaitForWorkViaWorkerFactory+0xc (FPO: [5,0,0])</span><br><span class="line">01 0f39ff70 76fcfcc9     008807c0 76fcfcb0 0f39ffdc ntdll!TppWorkerThread+0x2a0 (FPO: [Non-Fpo])</span><br><span class="line">02 0f39ff80 77c282ae     008807c0 e405b1ad 00000000 kernel32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">03 0f39ffdc 77c2827e     ffffffff 77c493c6 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">04 0f39ffec 00000000     77bf5a40 008807c0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">   7  Id: 2620.584 Suspend: 0 Teb: 003b3000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 0f49ee98 7613d01a     00000001 0f49efe8 ffffffff win32u!NtUserMsgWaitForMultipleObjectsEx+0xc (FPO: [5,0,0])</span><br><span class="line">01 0f49ef0c 7613cf4c     00000001 0f49efe8 ffffffff user32!RealMsgWaitForMultipleObjectsEx+0x7a (FPO: [Non-Fpo])</span><br><span class="line">02 0f49ef2c 75eb51c2     00000001 0f49efe8 ffffffff user32!MsgWaitForMultipleObjectsEx+0x4c (FPO: [Non-Fpo])</span><br><span class="line">03 0f49efac 75eb53a0     0f49efe8 00000001 0f49efd0 combase!CCliModalLoop::BlockFn+0x14b (FPO: [Non-Fpo]) (CONV: thiscall) [onecore\com\combase\dcomrem\callctrl.cxx @ 2156] </span><br><span class="line">04 0f49eff4 75eb3718     75eb36d0 07841a98 078a2c00 combase!ModalLoop+0xa1 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\dcomrem\chancont.cxx @ 166] </span><br><span class="line">05 0f49f010 75ecf229     0f49f4e8 0356f8f0 078a2c00 combase!ClassicSTAThreadDispatchCrossApartmentCall+0x48 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\dcomrem\chancont.cxx @ 319] </span><br><span class="line">06 (Inline) --------     -------- -------- -------- combase!CSyncClientCall::SwitchAptAndDispatchCall+0xa5a (Inline Function @ 75ecf229) (CONV: thiscall) [onecore\com\combase\dcomrem\channelb.cxx @ 5856] </span><br><span class="line">07 0f49f1f0 75eb40a8     0f49f4e8 0f49f4c4 0f49f4c4 combase!CSyncClientCall::SendReceive2+0xb49 (FPO: [Non-Fpo]) (CONV: thiscall) [onecore\com\combase\dcomrem\channelb.cxx @ 5459] </span><br><span class="line">08 (Inline) --------     -------- -------- -------- combase!SyncClientCallRetryContext::SendReceiveWithRetry+0x29 (Inline Function @ 75eb40a8) (CONV: thiscall) [onecore\com\combase\dcomrem\callctrl.cxx @ 1542] </span><br><span class="line">09 (Inline) --------     -------- -------- -------- combase!CSyncClientCall::SendReceiveInRetryContext+0x29 (Inline Function @ 75eb40a8) (CONV: thiscall) [onecore\com\combase\dcomrem\callctrl.cxx @ 565] </span><br><span class="line">0a 0f49f2b4 75ed1638     078a2c00 0f49f4e8 0f49f4c4 combase!ClassicSTAThreadSendReceive+0x98 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\dcomrem\callctrl.cxx @ 547] </span><br><span class="line">0b 0f49f4a0 75e9a1f8     0f49f4e8 0f49f4c4 0f49f4e8 combase!CSyncClientCall::SendReceive+0x538 (FPO: [Non-Fpo]) (CONV: thiscall) [onecore\com\combase\dcomrem\ctxchnl.cxx @ 722] </span><br><span class="line">0c (Inline) --------     -------- -------- -------- combase!CClientChannel::SendReceive+0x79 (Inline Function @ 75e9a1f8) (CONV: stdcall) [onecore\com\combase\dcomrem\ctxchnl.cxx @ 655] </span><br><span class="line">0d 0f49f4c8 770a60e3     00933784 0f49f53c f4410821 combase!NdrExtpProxySendReceive+0xc8 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\ndr\ndrole\proxy.cxx @ 1998] </span><br><span class="line">0e 0f49f918 75f6ff80     75e2a860 75e4cad0 0f49f950 rpcrt4!NdrClientCall2+0x9e3 (FPO: [Non-Fpo])</span><br><span class="line">0f 0f49f938 75f67f1f     0f49f950 00000009 0f49f9e4 combase!ObjectStublessClient+0x70 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\ndr\ndrole\i386\stblsclt.cxx @ 227] </span><br><span class="line">10 0f49f948 75f00bb3     00933784 0f49f990 0357d700 combase!ObjectStubless+0xf [onecore\com\combase\ndr\ndrole\i386\stubless.asm @ 171] </span><br><span class="line">11 0f49f9e4 75ea6161     035344c8 75f24e70 00000902 combase!CObjectContext::InternalContextCallback+0x273 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\dcomrem\context.cxx @ 4328] </span><br><span class="line">12 0f49fa54 767a1859     7605f1e8 00000902 7669699c combase!CGIPTable::GetInterfaceFromGlobal+0x371 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\dcomrem\giptbl.cxx @ 1683] </span><br><span class="line">13 0f49fa88 76ae136e     0f49faa0 0091a7f0 0787a3dc shell32!UnMarshalFromGIT+0x76 (FPO: [Non-Fpo])</span><br><span class="line">14 0f49fab4 76ae09da     0787a3dc 00000000 0091a804 shell32!CSendToMenu::_IsDropTarget+0x8a (FPO: [Non-Fpo])</span><br><span class="line">15 0f49fb10 76adff3e     0787a3dc 00000000 76adfef0 shell32!CSendToMenu::_AddSendToItem+0x2e (FPO: [Non-Fpo])</span><br><span class="line">16 0f49fb30 7543e29b     0091a804 0783fe10 07834678 shell32!CSendToMenu::FoundItem+0x4e (FPO: [Non-Fpo])</span><br><span class="line">17 0f49fb5c 752d2905     0783fe10 07834678 70e7db81 windows_storage!CNamespaceWalk::_AddItem+0x186471</span><br><span class="line">18 0f49fb94 7566f0a2     0783fe10 00000000 00000000 windows_storage!CNamespaceWalk::_WalkFolder+0x8c (FPO: [Non-Fpo])</span><br><span class="line">19 0f49fde8 7566f1a7     0783fbf0 07831410 00000000 windows_storage!CNamespaceWalk::_WalkFolderItem+0x180 (FPO: [4,141,4])</span><br><span class="line">1a 0f49fe1c 7566f245     0783fbf0 07831410 00000000 windows_storage!CNamespaceWalk::_WalkIDList+0xa2 (FPO: [Non-Fpo])</span><br><span class="line">1b 0f49fe4c 75447b54     0787a45c 00000001 70e7deb1 windows_storage!CNamespaceWalk::_WalkShellItem+0x76 (FPO: [Non-Fpo])</span><br><span class="line">1c 0f49fea4 7566f660     0090f858 03570e8c 00000404 windows_storage!CNamespaceWalk::Walk+0x1755d4</span><br><span class="line">1d 0f49feec 76d58e10     07835a28 76d58d50 76d58d50 windows_storage!CNamespaceWalk::s_AsyncWalkThreadProc+0xa0 (FPO: [Non-Fpo])</span><br><span class="line">1e 0f49ff70 76fcfcc9     0019f198 76fcfcb0 0f49ffdc SHCore!_WrapperThreadProc+0xc0 (FPO: [Non-Fpo])</span><br><span class="line">1f 0f49ff80 77c282ae     0019f198 e475b1ad 00000000 kernel32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">20 0f49ffdc 77c2827e     ffffffff 77c493c6 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">21 0f49ffec 00000000     76d58d50 0019f198 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">   8  Id: 2620.2bd0 Suspend: 0 Teb: 003b6000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 0f5dfc54 7650bc33     00000002 0f5dfe20 00000001 ntdll!NtWaitForMultipleObjects+0xc (FPO: [5,0,0])</span><br><span class="line">01 0f5dfde8 75eb3543     00000002 0f5dfe20 00000000 KERNELBASE!WaitForMultipleObjectsEx+0x103 (FPO: [SEH])</span><br><span class="line">02 0f5dff24 75eb33c7     0090fad8 00007530 00007530 combase!WaitCoalesced+0xb5 (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\published\comutils\coalescedwait.cxx @ 72] </span><br><span class="line">03 0f5dff60 75ea33bf     75ea33a0 75ea33a0 0f5dff80 combase!CRpcThread::WorkerLoop+0xd6 (FPO: [Non-Fpo]) (CONV: thiscall) [onecore\com\combase\dcomrem\threads.cxx @ 329] </span><br><span class="line">04 0f5dff70 76fcfcc9     0090fad8 76fcfcb0 0f5dffdc combase!CRpcThreadCache::RpcWorkerThreadEntry+0x1f (FPO: [Non-Fpo]) (CONV: stdcall) [onecore\com\combase\dcomrem\threads.cxx @ 77] </span><br><span class="line">05 0f5dff80 77c282ae     0090fad8 e461b1ad 00000000 kernel32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">06 0f5dffdc 77c2827e     ffffffff 77c493c6 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">07 0f5dffec 00000000     75ea33a0 0090fad8 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">   9  Id: 2620.1f14 Suspend: 0 Teb: 003b9000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 0f80fdac 77c1204e     0000007c 00000000 00000000 ntdll!NtWaitForSingleObject+0xc (FPO: [3,0,0])</span><br><span class="line">01 0f80fdd0 77c0f9ae     e4bcb001 00000000 76d3c650 ntdll!LdrpDrainWorkQueue+0x14f (FPO: [Non-Fpo])</span><br><span class="line">02 0f80fe70 77c2bd0c     76d3c650 76d3c650 76d20000 ntdll!LdrShutdownThread+0x7e (FPO: [SEH])</span><br><span class="line">03 0f80ff48 7651b694     00000000 76d3c650 00cedf18 ntdll!RtlExitUserThread+0x4c (FPO: [Non-Fpo])</span><br><span class="line">04 0f80ff5c 76d3c66c     76d20000 00000000 76d20000 KERNELBASE!FreeLibraryAndExitThread+0x34 (FPO: [Non-Fpo])</span><br><span class="line">05 0f80ff70 76fcfcc9     00cedf18 76fcfcb0 0f80ffdc SHCore!&lt;lambda_19624ae0f12adae645db6df842454482&gt;::&lt;lambda_invoker_stdcall&gt;+0x1c (FPO: [Non-Fpo])</span><br><span class="line">06 0f80ff80 77c282ae     00cedf18 e4bcb1ad 00000000 kernel32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">07 0f80ffdc 77c2827e     ffffffff 77c493c6 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">08 0f80ffec 00000000     76d3c650 00cedf18 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">  10  Id: 2620.df8 Suspend: 0 Teb: 003bc000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 0ff6fbf4 77c1204e     0000007c 00000000 00000000 ntdll!NtWaitForSingleObject+0xc (FPO: [3,0,0])</span><br><span class="line">01 0ff6fc18 77c0ddc1     e4cab2dd 00380000 00000000 ntdll!LdrpDrainWorkQueue+0x14f (FPO: [Non-Fpo])</span><br><span class="line">02 0ff6fcac 77c26c0b     e4cab375 00000000 00000000 ntdll!LdrpInitializeThread+0x78 (FPO: [SEH])</span><br><span class="line">03 0ff6fd04 77c26b31     00000000 00000000 00000000 ntdll!_LdrpInitialize+0x84 (FPO: [Non-Fpo])</span><br><span class="line">04 0ff6fd10 00000000     0ff6fd24 77bc0000 00000000 ntdll!LdrInitializeThunk+0x11 (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">  11  Id: 2620.393c Suspend: 0 Teb: 003bf000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 10cefbf4 77c1204e     0000007c 00000000 00000000 ntdll!NtWaitForSingleObject+0xc (FPO: [3,0,0])</span><br><span class="line">01 10cefc18 77c0ddc1     fbf2b2dd 00380000 00000000 ntdll!LdrpDrainWorkQueue+0x14f (FPO: [Non-Fpo])</span><br><span class="line">02 10cefcac 77c26c0b     fbf2b375 00000000 00000000 ntdll!LdrpInitializeThread+0x78 (FPO: [SEH])</span><br><span class="line">03 10cefd04 77c26b31     00000000 00000000 00000000 ntdll!_LdrpInitialize+0x84 (FPO: [Non-Fpo])</span><br><span class="line">04 10cefd10 00000000     10cefd24 77bc0000 00000000 ntdll!LdrInitializeThunk+0x11 (FPO: [Non-Fpo])</span><br><span class="line"></span><br><span class="line">  12  Id: 2620.1894 Suspend: 0 Teb: 003c2000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 137cfbf4 77c1204e     0000007c 00000000 00000000 ntdll!NtWaitForSingleObject+0xc (FPO: [3,0,0])</span><br><span class="line">01 137cfc18 77c0ddc1     f840b2dd 00380000 00000000 ntdll!LdrpDrainWorkQueue+0x14f (FPO: [Non-Fpo])</span><br><span class="line">02 137cfcac 77c26c0b     f840b375 00000000 00000000 ntdll!LdrpInitializeThread+0x78 (FPO: [SEH])</span><br><span class="line">03 137cfd04 77c26b31     00000000 00000000 00000000 ntdll!_LdrpInitialize+0x84 (FPO: [Non-Fpo])</span><br><span class="line">04 137cfd10 00000000     137cfd24 77bc0000 00000000 ntdll!LdrInitializeThunk+0x11 (FPO: [Non-Fpo])</span><br></pre></td></tr></table></figure><p>可以看到底部的几个线程都在等待同一个句柄 <code>0x7c</code>，而且都是由 <code>LdrpDrainWorkQueue()</code> 发起的。由上篇文章——<a href="https://bianchengnan.github.io/articles/debugging-deadlock-when-dll-unload-on-win10">《调试实战 | DllMain 的陷阱：当 Windows 10 并行加载遇上线程等待引发的死锁》</a>可知，这个句柄大概率是 <code>ntdll!LdrpLoadCompleteEvent</code>。在 <code>windbg</code> 中输入 <code>dd ntdll!LdrpLoadCompleteEvent L1</code> 可以查看其值，果然是 <code>0x7c</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd ntdll!LdrpLoadCompleteEvent L1</span><br><span class="line">77ce5cc8  0000007c</span><br></pre></td></tr></table></figure><p>大概率又是一个加载器相关的死锁！这些线程中，<code>1</code> 号线程和 <code>7</code> 号线程的调用栈比较值得怀疑，尤其是 <code>1</code> 号线程。先来看看 <code>1</code> 号线程在等待什么？由以上输出可知，<code>1</code> 号线程调用 <code>ntdll!NtWaitForSingleObject()</code> 时的参数是 <code>0x730</code>。执行 <code>!handle 00000730 f</code> 查看句柄信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !handle 00000730 f</span><br><span class="line">Handle 00000730</span><br><span class="line">  Type         Event</span><br><span class="line">  Attributes   0</span><br><span class="line">  GrantedAccess0x1f0003:</span><br><span class="line">         Delete,ReadControl,WriteDac,WriteOwner,Synch</span><br><span class="line">         QueryState,ModifyState</span><br><span class="line">  HandleCount  2</span><br><span class="line">  PointerCount 65538</span><br><span class="line">  Name         &lt;none&gt;</span><br><span class="line">  Object specific information</span><br><span class="line">    Event Type Auto Reset</span><br><span class="line">    Event is Waiting</span><br></pre></td></tr></table></figure><p>看来 <code>1</code> 号线程在等待一个 <code>Event</code>，接着看一下 <code>7</code> 号线程在等待什么？<code>7</code> 号线程调用 <code>win32u!NtUserMsgWaitForMultipleObjectsEx()</code> 进入的等待.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7  Id: 2620.584 Suspend: 0 Teb: 003b3000 Unfrozen</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 0f49ee98 7613d01a     00000001 0f49efe8 ffffffff win32u!NtUserMsgWaitForMultipleObjectsEx+0xc (FPO: [5,0,0])</span><br></pre></td></tr></table></figure><p>第一个参数是句柄数组数量，第二个参数是句柄数组。执行 <code>dd 0f49efe8 L1</code> 查看句柄值，然后再使用 <code>!handle</code> 命令查看句柄信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd 0f49efe8 L1</span><br><span class="line">0f49efe8  000005c4</span><br><span class="line">0:000&gt; !handle 000005c4 f</span><br><span class="line">Handle 000005c4</span><br><span class="line">  Type         Event</span><br><span class="line">  Attributes   0</span><br><span class="line">  GrantedAccess0x1f0003:</span><br><span class="line">         Delete,ReadControl,WriteDac,WriteOwner,Synch</span><br><span class="line">         QueryState,ModifyState</span><br><span class="line">  HandleCount  2</span><br><span class="line">  PointerCount 65536</span><br><span class="line">  Name         &lt;none&gt;</span><br><span class="line">  Object specific information</span><br><span class="line">    Event Type Auto Reset</span><br><span class="line">    Event is Waiting</span><br></pre></td></tr></table></figure><p>也在等待一个 <code>Event</code>，但是由于 <code>7</code> 号线程调用的是 <code>NtUserMsgWaitForMultipleObjectsEx()</code>，所以有消息的时候也会被唤醒，重点关注 <code>1</code> 号线程。</p><h2 id="细看调用栈"><a href="#细看调用栈" class="headerlink" title="细看调用栈"></a>细看调用栈</h2><p>如果仔细查看 <code>1</code> 号线程的调用栈，可以发现 <code>1</code> 号线程的等待是在 <code>ntdll!LdrpCallInitRoutine()</code> 内部，我们知道 <code>LdrpCallInitRoutine()</code> 内部会调用每个模块的 <code>DllMain()</code>，在执行到 <code>YunShellExtV1.dll</code> 对应的 <code>DllMain()</code>（由于没有对应的调试符号，所以不能直接从调用栈看出来在调用 <code>DllMain()</code> 函数）时，其内部调用了 <code>user32!CreateWindowExW()</code> 创建窗口，又间接调用到了 <code>SHCore!_CreateThreadWorker()</code>，而 <code>SHCore!_CreateThreadWorker()</code> 内部又会调用 <code>KernalBase!WaitForSingleObject()</code> 来永久等待一个事件。相当于间接的在 <code>DllMain()</code> 中执行了等待操作！这是一个<strong>非常危险</strong>的信号。关键调用栈帧可以参考下图红色高亮部分。</p><p><img src="http://resources.bianchengnan.tech/debug-spacesniffer-deadlock/view-callstack-of-thread-1.png" alt="view-callstack-of-thread-1"></p><p>那 <code>SHCore!_CreateThreadWorker()</code> 内部在等待什么事件呢？只能从反汇编代码中找答案了。</p><h2 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h2><p>打开 <code>32</code> 位的 <code>IDA</code>，加载 <code>32</code> 位的 <code>SHCore.dll</code>，找到 <code>CreateThreadWorker()</code>，使用 <code>F5</code> 查看伪代码，如下（有删减）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">BOOL __<span class="function">fastcall <span class="title">CreateThreadWorker</span><span class="params">(LPCWSTR lpModuleName, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, _DWORD *a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> Parameter[<span class="number">12</span>]; <span class="comment">// [esp+28h] [ebp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (a3 &amp; <span class="number">2</span>) == <span class="number">0</span> || (v11 = (<span class="keyword">void</span> *)SHGetThreadRef((IUnknown **)&amp;Parameter[<span class="number">5</span>]), (<span class="keyword">int</span>)v11 &gt;= <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    Parameter[<span class="number">2</span>] = (<span class="keyword">int</span>)CreateEventW(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//&lt;----</span></span><br><span class="line">    <span class="keyword">if</span> ( Parameter[<span class="number">2</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = CreateThread(<span class="number">0</span>, <span class="number">0</span>, WrapperThreadProc, Parameter, <span class="number">0</span>, &amp;ThreadId); <span class="comment">//&lt;----</span></span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        v24 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !Parameter[<span class="number">1</span>] || (v6 &amp; <span class="number">0x200</span>) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          WaitForSingleObject((HANDLE)Parameter[<span class="number">2</span>], <span class="number">0xFFFFFFFF</span>); <span class="comment">//&lt;----</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( (v6 &amp; <span class="number">0x40</span>) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          pHandles = (HANDLE)Parameter[<span class="number">2</span>];</span><br><span class="line">          CoWaitForMultipleHandles(<span class="number">8u</span>, <span class="number">0xFFFFFFFF</span>, <span class="number">1u</span>, &amp;pHandles, &amp;dwindex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          SHWaitForThreadWithWakeMask((HANDLE)Parameter[<span class="number">2</span>], <span class="number">0xFFFFFFFF</span>, <span class="number">0x40</span>u);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v8 &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很明显的看到关键代码（带有 <code>//&lt;----</code> 注释的行）。先创建一个 <code>Event</code>，然后创建线程，把带 <code>Event</code> 的参数传递给新线程，最后再<strong>无限</strong>等待 <code>Event</code>。猜测新线程执行完必要的操作后，会触发事件。</p><p>看到这段逻辑，我立刻就知道了原因：当前可是在 <code>DllMain()</code> 里啊，如果执行不完，新线程没有机会得到执行，也就没办法触发事件，<code>DllMain()</code> 也就会永远的等下去。</p><p>没想到这么容易就破案了！捡了个大漏！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在 <code>DllMain()</code> 中不要做危险操作！尤其不要做等待操作！</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://github.com/ElliotKillick/operating-system-design-review/blob/main/README.md" target="_blank" rel="noopener">https://github.com/ElliotKillick/operating-system-design-review/blob/main/README.md</a></p></li><li><p><a href="https://stackoverflow.com/questions/42789199/why-there-are-three-unexpected-worker-threads-when-a-win32-console-application-s/42789684#42789684、" target="_blank" rel="noopener">https://stackoverflow.com/questions/42789199/why-there-are-three-unexpected-worker-threads-when-a-win32-console-application-s/42789684#42789684、</a></p></li><li><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn633971(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/dn633971(v=vs.85).aspx</a></p></li><li><p><a href="https://bianchengnan.github.io/articles/debugging-deadlock-when-dll-unload-on-win10/">https://bianchengnan.github.io/articles/debugging-deadlock-when-dll-unload-on-win10/</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在一次使用 &lt;code&gt;SpaceSniffer&lt;/code&gt; 分析磁盘占用时，我遇到了一个非常容易复现的界面卡死问题。为查明原因，我首先通过 &lt;code&gt;procdump&lt;/code&gt; 周期性保存完整转储文件，并使用 &lt;code&gt;WinDbg&lt;/code&gt; 对调用栈进行对比分析，确认程序确实陷入阻塞而非假死。逐层追踪后，我最终将问题定位到第三方 &lt;code&gt;Shell&lt;/code&gt; 扩展在 &lt;code&gt;COM&lt;/code&gt; 激活过程中的异常阻塞，并由此引发死锁。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="IDA" scheme="https://bianchengnan.github.io/tags/IDA/"/>
    
      <category term="死锁" scheme="https://bianchengnan.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="deadlock" scheme="https://bianchengnan.github.io/tags/deadlock/"/>
    
      <category term="spacesniffer" scheme="https://bianchengnan.github.io/tags/spacesniffer/"/>
    
      <category term="win10" scheme="https://bianchengnan.github.io/tags/win10/"/>
    
      <category term="Parallel Loader" scheme="https://bianchengnan.github.io/tags/Parallel-Loader/"/>
    
      <category term="并行加载" scheme="https://bianchengnan.github.io/tags/%E5%B9%B6%E8%A1%8C%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | DllMain 的陷阱：当 Windows 10 并行加载遇上线程等待引发的死锁</title>
    <link href="https://bianchengnan.github.io//articles/debugging-deadlock-when-dll-unload-on-win10/"/>
    <id>https://bianchengnan.github.io//articles/debugging-deadlock-when-dll-unload-on-win10/</id>
    <published>2026-02-08T04:36:45.000Z</published>
    <updated>2026-02-16T10:40:27.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>这篇文章分析了在 <code>Win10</code> 系统上 <code>DLL</code> 卸载时发生死锁的根本原因。通过调试发现，死锁是由于 <code>Win10</code> 引入了并行加载器机制，导致线程在退出时等待全局事件 <code>LdrpLoadCompleteEvent</code>，而该事件又因 <code>DllMain()</code> 在处理 <code>DLL_PROCESS_DETACH</code> 时调用 <code>WaitForSingleObject()</code> 无限等待工作线程结束而无法被触发。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我在上一篇文章 <a href="https://bianchengnan.github.io/articles/debugging-deadlock-when-dll-unload-continue">《调试实战 | 从无法复现到真相大白：DLL卸载死锁背后的版本陷阱》</a>中弄清楚了为什么之前卡死的程序不卡死的原因—— <code>crt</code> 调整了 <code>_beginthreadex()</code> 的逻辑，在其内部会增加 <code>dll</code> 引用计数，导致 <code>FreeLibrary()</code> 的时候没有正常卸载 <code>dll</code>，进而导致卡死的现象未重现。调整为 <code>vs2010</code> 后，就可以重现了。虽然重现了卡死的现象，但是在 <code>win10</code> 系统上卡死时的调用栈跟 <code>win7</code> 系统不太一样。通过 <code>!cs -l</code> 命令并不能看任何结果。本着打破砂锅问到底的原则，便有了今天的这篇总结。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>这里再简单贴一下关键代码，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WaitDllUnloadExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE <span class="keyword">module</span> = LoadLibraryA(<span class="string">".\\DllUnload.dll"</span>);</span><br><span class="line">    Sleep(<span class="number">1000</span>);</span><br><span class="line">    FreeLibrary(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dllmain.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"process.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> g_quit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">stdcall <span class="title">procThread</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!g_quit)</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugStringA(<span class="string">"====procThread running.\n"</span>);</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OutputDebugStringA(<span class="string">"====procThread quitting.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">stdcall <span class="title">quitDemoProc</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx++ &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugStringA(<span class="string">"====quitDemoProc running!!!!!!!!\n"</span>);</span><br><span class="line">        Sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    OutputDebugStringA(<span class="string">"====quitDemoProc quitting!!!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        g_hThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;procThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        CloseHandle((HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;quitDemoProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugStringA(<span class="string">"====DLL_THREAD_ATTACH called.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugStringA(<span class="string">"====DLL_THREAD_DETACH called.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">256</span>] = <span class="string">""</span>;</span><br><span class="line">        sprintf_s(buffer, <span class="string">"====DLL_PROCESS_DETACH begin wait for thread=%x\n"</span>, (<span class="keyword">int</span>)g_hThread);</span><br><span class="line">        OutputDebugStringA(buffer);</span><br><span class="line">        g_quit = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// change INFINITE to some other value (e.g. 5000) to exit normally</span></span><br><span class="line">        DWORD waitResult = WaitForSingleObject(g_hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">        sprintf_s(buffer, <span class="string">"====DLL_PROCESS_DETACH end wait for thread=%x, result=%x\n"</span>, (<span class="keyword">int</span>)g_hThread, waitResult);</span><br><span class="line">        OutputDebugStringA(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初步调查"><a href="#初步调查" class="headerlink" title="初步调查"></a>初步调查</h2><p>待程序卡死后，使用 <code>windbg</code> 附加。使用 <code>~* kn</code> 命令查看所有线程的调用栈，可以发现 <code>0</code> 号线程和 <code>6</code> 号线程是我们需要关注的线程，而且这两个线程都在等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ~*kn</span><br><span class="line"></span><br><span class="line">.  0  Id: 5680.3434 Suspend: 1 Teb: 00000000`00d90000 Unfrozen</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 00000000`00eff388 00007ffc`745cb6ae     ntdll!NtWaitForSingleObject+0x14</span><br><span class="line">01 00000000`00eff390 00007ffc`4cbd1289     KERNELBASE!WaitForSingleObjectEx+0x8e</span><br><span class="line">02 00000000`00eff430 00007ffc`4cbd1d4e     DllUnload!DllMain+0x159 [d:\myblogstuff\debugging-deadlock-when-dll-unload-win10\dllunload\dllmain.cpp @ 66] </span><br><span class="line">03 00000000`00eff5a0 00007ffc`4cbd1c91     DllUnload!__DllMainCRTStartup+0xae [f:\dd\vctools\crt_bld\self_64_amd64\crt\src\crtdll.c @ 512] </span><br><span class="line">04 00000000`00eff5f0 00007ffc`76d09a1d     DllUnload!_DllMainCRTStartup+0x31 [f:\dd\vctools\crt_bld\self_64_amd64\crt\src\crtdll.c @ 477] </span><br><span class="line">05 00000000`00eff620 00007ffc`76d5badb     ntdll!LdrpCallInitRoutine+0x61</span><br><span class="line">06 00000000`00eff690 00007ffc`76d5b537     ntdll!LdrpProcessDetachNode+0x107</span><br><span class="line">07 00000000`00eff760 00007ffc`76cffd0a     ntdll!LdrpUnloadNode+0x3f</span><br><span class="line">08 00000000`00eff7b0 00007ffc`76cffc84     ntdll!LdrpDecrementModuleLoadCountEx+0x72</span><br><span class="line">09 00000000`00eff7e0 00007ffc`745d32de     ntdll!LdrUnloadDll+0x94</span><br><span class="line">0a 00000000`00eff810 00007ff7`536b1059     KERNELBASE!FreeLibrary+0x1e</span><br><span class="line">0b 00000000`00eff840 00007ff7`536b13cc     WaitDllUnloadExe!main+0x49 [d:\myblogstuff\debugging-deadlock-when-dll-unload-win10\waitdllunloadexe\waitdllunloadexe.cpp @ 8] </span><br><span class="line">0c 00000000`00eff880 00007ff7`536b121e     WaitDllUnloadExe!__tmainCRTStartup+0x19c [f:\dd\vctools\crt_bld\self_64_amd64\crt\src\crtexe.c @ 555] </span><br><span class="line">0d 00000000`00eff8f0 00007ffc`74f77374     WaitDllUnloadExe!mainCRTStartup+0xe [f:\dd\vctools\crt_bld\self_64_amd64\crt\src\crtexe.c @ 371] </span><br><span class="line">0e 00000000`00eff920 00007ffc`76d3cc91     kernel32!BaseThreadInitThunk+0x14</span><br><span class="line">0f 00000000`00eff950 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br><span class="line"></span><br><span class="line">   1  Id: 5680.5acc Suspend: 1 Teb: 00000000`00d92000 Unfrozen</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 00000000`0128f4b8 00007ffc`76d3d407     ntdll!NtWaitForWorkViaWorkerFactory+0x14</span><br><span class="line">01 00000000`0128f4c0 00007ffc`74f77374     ntdll!TppWorkerThread+0x2f7</span><br><span class="line">02 00000000`0128f7c0 00007ffc`76d3cc91     kernel32!BaseThreadInitThunk+0x14</span><br><span class="line">03 00000000`0128f7f0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br><span class="line"></span><br><span class="line">   2  Id: 5680.9d0 Suspend: 1 Teb: 00000000`00d94000 Unfrozen</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 00000000`0138f598 00007ffc`76d3d407     ntdll!NtWaitForWorkViaWorkerFactory+0x14</span><br><span class="line">01 00000000`0138f5a0 00007ffc`74f77374     ntdll!TppWorkerThread+0x2f7</span><br><span class="line">02 00000000`0138f8a0 00007ffc`76d3cc91     kernel32!BaseThreadInitThunk+0x14</span><br><span class="line">03 00000000`0138f8d0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br><span class="line"></span><br><span class="line">   3  Id: 5680.53ac Suspend: 1 Teb: 00000000`00d96000 Unfrozen</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 00000000`0148f978 00007ffc`76d3d407     ntdll!NtWaitForWorkViaWorkerFactory+0x14</span><br><span class="line">01 00000000`0148f980 00007ffc`74f77374     ntdll!TppWorkerThread+0x2f7</span><br><span class="line">02 00000000`0148fc80 00007ffc`76d3cc91     kernel32!BaseThreadInitThunk+0x14</span><br><span class="line">03 00000000`0148fcb0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br><span class="line"></span><br><span class="line">   4  Id: 5680.23a4 Suspend: 1 Teb: 00000000`00d98000 Unfrozen</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 00000000`03a0fbc8 00007ffc`745f62ce     ntdll!NtDelayExecution+0x14</span><br><span class="line">01 00000000`03a0fbd0 00007ffc`60e798ab     KERNELBASE!SleepEx+0x9e</span><br><span class="line">02 00000000`03a0fc70 00007ffc`74f77374     ObjectVirtualizeDll_x64!ProxyHttpApiHook+0x52cdb</span><br><span class="line">03 00000000`03a0fca0 00007ffc`76d3cc91     kernel32!BaseThreadInitThunk+0x14</span><br><span class="line">04 00000000`03a0fcd0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br><span class="line"></span><br><span class="line">   5  Id: 5680.4914 Suspend: 1 Teb: 00000000`00d9a000 Unfrozen</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 00000000`03b0ee48 00007ffc`74600d00     ntdll!NtWaitForMultipleObjects+0x14</span><br><span class="line">01 00000000`03b0ee50 00007ffc`74600bfe     KERNELBASE!WaitForMultipleObjectsEx+0xf0</span><br><span class="line">02 00000000`03b0f140 00007ffc`5e5754fb     KERNELBASE!WaitForMultipleObjects+0xe</span><br><span class="line">03 00000000`03b0f180 00007ffc`5e5827ba     cpbgrd64+0x154fb</span><br><span class="line">04 00000000`03b0f710 00007ffc`74f77374     cpbgrd64+0x227ba</span><br><span class="line">05 00000000`03b0fc70 00007ffc`76d3cc91     kernel32!BaseThreadInitThunk+0x14</span><br><span class="line">06 00000000`03b0fca0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br><span class="line"></span><br><span class="line">   6  Id: 5680.4474 Suspend: 1 Teb: 00000000`00d9c000 Unfrozen</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 00000000`0406f8b8 00007ffc`76d50022     ntdll!NtWaitForSingleObject+0x14</span><br><span class="line">01 00000000`0406f8c0 00007ffc`76d074ed     ntdll!LdrpDrainWorkQueue+0x15e</span><br><span class="line">02 00000000`0406f900 00007ffc`76d3ec6e     ntdll!LdrShutdownThread+0x9d</span><br><span class="line">03 00000000`0406fa00 00000000`6c8c733e     ntdll!RtlExitUserThread+0x3e</span><br><span class="line">04 00000000`0406fa40 00000000`6c8c72ec     MSVCR100D!_endthreadex+0x2e [f:\dd\vctools\crt_bld\self_64_amd64\crt\src\threadex.c @ 367] </span><br><span class="line">05 00000000`0406fa80 00000000`6c8c72a4     MSVCR100D!_callthreadstartex+0x2c [f:\dd\vctools\crt_bld\self_64_amd64\crt\src\threadex.c @ 315] </span><br><span class="line">06 00000000`0406fad0 00007ffc`74f77374     MSVCR100D!_threadstartex+0xb4 [f:\dd\vctools\crt_bld\self_64_amd64\crt\src\threadex.c @ 297] </span><br><span class="line">07 00000000`0406fb10 00007ffc`76d3cc91     kernel32!BaseThreadInitThunk+0x14</span><br><span class="line">08 00000000`0406fb40 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br><span class="line"></span><br><span class="line">   7  Id: 5680.4194 Suspend: 1 Teb: 00000000`00da0000 Unfrozen</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 00000000`0426f778 00007ffc`745cb6ae     ntdll!NtWaitForSingleObject+0x14</span><br><span class="line">01 00000000`0426f780 00007ffc`5e577e80     KERNELBASE!WaitForSingleObjectEx+0x8e</span><br><span class="line">02 00000000`0426f820 00007ffc`74f77374     cpbgrd64+0x17e80</span><br><span class="line">03 00000000`0426f850 00007ffc`76d3cc91     kernel32!BaseThreadInitThunk+0x14</span><br><span class="line">04 00000000`0426f880 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br><span class="line"></span><br><span class="line">#  8  Id: 5680.3e34 Suspend: 1 Teb: 00000000`00da2000 Unfrozen</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 00000000`0416f738 00007ffc`76dbcb3e     ntdll!DbgBreakPoint</span><br><span class="line">01 00000000`0416f740 00007ffc`74f77374     ntdll!DbgUiRemoteBreakin+0x4e</span><br><span class="line">02 00000000`0416f770 00007ffc`76d3cc91     kernel32!BaseThreadInitThunk+0x14</span><br><span class="line">03 00000000`0416f7a0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br><span class="line"></span><br><span class="line">   9  Id: 5680.50bc Suspend: 0 Teb: 00000000`00da4000 Unfrozen</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 00000000`0436fcf8 00000000`00000000     ntdll!RtlUserThreadStart</span><br></pre></td></tr></table></figure><p>先看一下  <code>0</code> 号线程在等待什么？函数 <code>ntdll!NtWaitForSingleObject()</code> 的第一个参数是等待的句柄，在 <code>64</code> 位程序中函数的第一个参数一般是通过 <code>rcx</code> 传递的。一般寄存器的值是在调用过程中发生变化的，不能直接查看。但是 <code>ntdll!NtWaitForSingleObject()</code>  会直接进内核，用户态的寄存器会被保存起来，不会发生变化，因此可以直接通过 <code>r</code> 命令查看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; uf ntdll!NtWaitForSingleObject</span><br><span class="line">ntdll!NtWaitForSingleObject:</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d8d610 <span class="number">4</span>c8bd1          mov     r10,rcx</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d8d613 b804000000      mov     eax,<span class="number">4</span></span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d8d618 f604250803fe7f01 test    byte ptr [SharedUserData+<span class="number">0x308</span> (<span class="number">00000000</span>`<span class="number">7f</span>fe0308)],<span class="number">1</span></span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d8d620 <span class="number">7503</span>            jne     ntdll!NtWaitForSingleObject+<span class="number">0x15</span> (<span class="number">00007f</span>fc`<span class="number">76</span>d8d625)  Branch</span><br><span class="line"></span><br><span class="line">ntdll!NtWaitForSingleObject+<span class="number">0x12</span>:</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d8d622 <span class="number">0f</span>05            syscall  <span class="comment">//&lt;----</span></span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d8d624 c3              ret</span><br><span class="line"></span><br><span class="line">ntdll!NtWaitForSingleObject+<span class="number">0x15</span>:</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d8d625 cd2e            <span class="keyword">int</span>     <span class="number">2</span>Eh</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d8d627 c3              ret</span><br></pre></td></tr></table></figure><p>执行 <code>r rcx</code> 命令查看 <code>rcx</code> 寄存器的值，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; r rcx</span><br><span class="line">rcx=00000000000002b8</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong> 执行 <code>r</code> 命令时需要确保当前线程是我们关注的线程，<code>0:000</code> 冒号后面的 <code>000</code> 是 <code>windbg</code> 中的线程编号，不是操作系统中的线程 <code>ID</code>。</p></blockquote><p>我们可以进一步通过 <code>!handle</code> 命令验证 <code>0x2b8</code> 是否是合法的句柄值。在 <code>windbg</code> 中执行 <code>!handle 0x2b8 f</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !handle 0x2b8 f</span><br><span class="line">Handle 00000000000002b8</span><br><span class="line">  Type         Thread  //&lt;----</span><br><span class="line">  Attributes   0</span><br><span class="line">  GrantedAccess0x1fffff:</span><br><span class="line">         Delete,ReadControl,WriteDac,WriteOwner,Synch</span><br><span class="line">         Terminate,Suspend,Alert,GetContext,SetContext,SetInfo,QueryInfo,SetToken,Impersonate,DirectImpersonate</span><br><span class="line">  HandleCount  4</span><br><span class="line">  PointerCount 163744</span><br><span class="line">  Name         &lt;none&gt;</span><br><span class="line">  Object specific information</span><br><span class="line">    Thread Id   5680.4474  //&lt;----</span><br><span class="line">    Priority    10</span><br><span class="line">    Base Priority 0</span><br></pre></td></tr></table></figure><p>可以发现 <code>0x2b8</code> 是线程句柄，对应的线程 <code>ID</code> 是 <code>4474</code>，进程 <code>ID</code> 是 <code>5680</code>。使用 <code>~~[4474]s</code> 切换线程，可以发现这个线程正是 <code>6</code> 号线程。（可以通过底部命令行左侧的 <code>0:006</code> 确认）</p><p><img src="http://resources.bianchengnan.tech/debugging-deadlock-when-dll-unload-on-win10/switch-t0-thread-no6.png" alt="switch-t0-thread-no6"></p><p>这与我们的代码完全匹配，我们的代码在 <code>DllMain()</code> 中会无限等待创建的线程结束，对应的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD waitResult = WaitForSingleObject(g_hThread, INFINITE);</span><br></pre></td></tr></table></figure><p>知道 <code>0</code> 号线程在等待什么，接下来使用同样的方法查看 <code>6</code> 号线程在等待什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">006</span>&gt; r rcx</span><br><span class="line">rcx=<span class="number">0000000000000038</span></span><br><span class="line"><span class="number">0</span>:<span class="number">006</span>&gt; !handle <span class="number">0x38</span> f</span><br><span class="line">Handle <span class="number">0000000000000038</span></span><br><span class="line">  Type         Event    <span class="comment">//&lt;----</span></span><br><span class="line">  Attributes   <span class="number">0</span></span><br><span class="line">  GrantedAccess<span class="number">0x1f0003</span>:</span><br><span class="line">         Delete,ReadControl,WriteDac,WriteOwner,Synch</span><br><span class="line">         QueryState,ModifyState</span><br><span class="line">  HandleCount  <span class="number">2</span></span><br><span class="line">  PointerCount <span class="number">65519</span></span><br><span class="line">  Name         &lt;none&gt;</span><br><span class="line">  Object specific information</span><br><span class="line">    Event Type Auto Reset</span><br><span class="line">    Event is Waiting</span><br></pre></td></tr></table></figure><p>可以发现 <code>6</code> 号线程在等待一个事件，句柄值是 <code>0x38</code>。通过调用栈可知，<code>6</code> 号线程正在退出，在退出过程中调用了 <code>LdrpDrainWorkQueue()</code> ，进而导致了等待。至此已经从调用栈上看不出更多的信息了。为什么 <code>6</code> 号线程会陷入等待呢？谁又会触发这个事件呢？</p><h2 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h2><p>在 <code>windbg</code> 中执行 <code>ub 00007ffc76d50022 L50</code>，查看 <code>ntdll!LdrpDrainWorkQueue()</code> 调用 <code>ntdll!NtWaitForSingleObject()</code> 的相关代码，输出结果如下（输出结果有省略）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">006</span>&gt; ub <span class="number">00007f</span>fc`<span class="number">76</span>d50022 L50</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ntdll!LdrpDrainWorkQueue:</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fec4 <span class="number">48895</span>c2408      mov     qword ptr [rsp+<span class="number">8</span>],rbx</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fec9 <span class="number">48896</span>c2410      mov     qword ptr [rsp+<span class="number">10</span>h],rbp</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fece <span class="number">4889742418</span>      mov     qword ptr [rsp+<span class="number">18</span>h],rsi</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fed3 <span class="number">57</span>              push    rdi</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fed4 <span class="number">4154</span>            push    r12</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fed6 <span class="number">4156</span>            push    r14</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fed8 <span class="number">4883</span>ec20        sub     rsp,<span class="number">20</span>h</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fedc <span class="number">4</span>c8b35cdc41000  mov     r14,qword ptr [ntdll!LdrpWorkCompleteEvent (<span class="number">00007f</span>fc`<span class="number">76e5</span>c3b0)] <span class="comment">//&lt;---</span></span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fee3 <span class="number">4</span>c8d2506c51000  lea     r12,[ntdll!LdrpWorkQueue (<span class="number">00007f</span>fc`<span class="number">76e5</span>c3f0)]</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4feea <span class="number">4032f</span>6          xor     sil,sil</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4feed <span class="number">8b</span>f9            mov     edi,ecx</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4feef <span class="number">85</span>c9            test    ecx,ecx</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fef1 <span class="number">4</span>c0f443587c41000 cmove   r14,qword ptr [ntdll!LdrpLoadCompleteEvent (<span class="number">00007f</span>fc`<span class="number">76e5</span>c380)] <span class="comment">//&lt;---</span></span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4fef9 <span class="number">488</span>d0dc0c41000  lea     rcx,[ntdll!LdrpWorkQueueLock (<span class="number">00007f</span>fc`<span class="number">76e5</span>c3c0)]</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d4ff00 e89bfbfcff      call    ntdll!RtlEnterCriticalSection (<span class="number">00007f</span>fc`<span class="number">76</span>d1faa0)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d50015 <span class="number">4533</span>c0          xor     r8d,r8d</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d50018 <span class="number">33</span>d2            xor     edx,edx</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d5001a <span class="number">498b</span>ce          mov     rcx,r14  <span class="comment">//&lt;----</span></span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d5001d e8eed50300      call    ntdll!NtWaitForSingleObject (<span class="number">00007f</span>fc`<span class="number">76</span>d8d610)</span><br></pre></td></tr></table></figure><p>注意查看 <code>//&lt;----</code> 对应的汇编代码，<code>ntdll!NtWaitForSingleObject()</code> 的参数来源自 <code>r14</code>，而 <code>r14</code> 的值可能来源于两个地方，一个是 <code>ntdll!LdrpWorkCompleteEvent</code>，一个是 <code>ntdll!LdrpLoadCompleteEvent</code>。大概逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r14 = ntdll!LdrpWorkCompleteEvent;</span><br><span class="line"><span class="keyword">if</span> (param == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    r14 = ntdll!LdrpLoadCompleteEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下调用 <code>ntdll!LdrpDrainWorkQueue()</code> 的反汇编代码，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">006</span>&gt; ub <span class="number">00007f</span>fc`<span class="number">76</span>d074ed </span><br><span class="line">ntdll!LdrShutdownThread+<span class="number">0x70</span>:</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d074c0 <span class="number">65488b</span>042530000000 mov   rax,qword ptr gs:[<span class="number">30</span>h]</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d074c9 b900100000      mov     ecx,<span class="number">1000</span>h</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d074ce <span class="number">668588</span>ee170000  test    word ptr [rax+<span class="number">17</span>EEh],cx</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d074d5 <span class="number">0f</span>85e0690900    jne     ntdll!LdrShutdownThread+<span class="number">0x96a6b</span> (<span class="number">00007f</span>fc`<span class="number">76</span>d9debb)</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d074db <span class="number">418</span>af4          mov     sil,r12b</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d074de <span class="number">4488</span>a42400010000 mov     byte ptr [rsp+<span class="number">100</span>h],r12b</span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d074e6 <span class="number">33</span>c9            xor     ecx,ecx <span class="comment">//&lt;----</span></span><br><span class="line"><span class="number">00007f</span>fc`<span class="number">76</span>d074e8 e8d7890400      call    ntdll!LdrpDrainWorkQueue (<span class="number">00007f</span>fc`<span class="number">76</span>d4fec4)</span><br></pre></td></tr></table></figure><p>可以发现，<code>ntdll!LdrShutdownThread()</code> 调用 <code>ntdll!LdrpDrainWorkQueue()</code> 时的参数是 <code>0</code>。所以最终等待的句柄是 <code>ntdll!LdrpLoadCompleteEvent</code>。</p><p>使用 <code>dd ntdll!LdrpLoadCompleteEvent L1</code> 查看其值，果然是 <code>0x38</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:006&gt; dd ntdll!LdrpLoadCompleteEvent L1</span><br><span class="line">00007ffc`76e5c380  00000038</span><br></pre></td></tr></table></figure><p>看来 <code>6</code> 号线程在等待 <code>ntdll!LdrpLoadCompleteEvent</code>。那谁会触发这个事件呢？</p><h2 id="继续查看反汇编"><a href="#继续查看反汇编" class="headerlink" title="继续查看反汇编"></a>继续查看反汇编</h2><p>如果能有办法找到 <code>ntdll!LdrpLoadCompleteEvent</code> 所有的引用，就可以进一步查看相关代码。是时候请出 <code>IDA</code> 了，因为 <code>IDA</code> 的静态分析能力简直太香了。用 <code>64</code> 位的 <code>IDA</code> 打开 <code>ntdll.dll</code>，找到所有引用 <code>ntdll!LdrpLoadCompleteEvent</code> 的地方，如下图：</p><p><img src="http://resources.bianchengnan.tech/debugging-deadlock-when-dll-unload-on-win10/view-loadcompleteevent-reference-in-ida.png" alt="view-loadcompleteevent-reference-in-ida"></p><p>可以发现，一共就三个地方：<code>LdrpDropLastInProgressCount+38↑r</code>、<code>LdrpDrainWorkQueue+2D↑r</code> 和<code>LdrpCreateLoaderEvents+12↑o</code>。</p><blockquote><p><strong>小提示：</strong> 还可以在 <code>windbg</code> 中使用 <code>#</code> 命令查找所有用到 <code>LdrpLoadCompleteEvent</code> 的代码。<code>#</code> 命令的大概语法是 <code># [Pattern] [Address [ L Size ]]</code>。可以在 <code>windbg</code> 中输入 <code>.hh #</code> 查看该命令的详细解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0:006&gt; lmm ntdll</span><br><span class="line">&gt; Browse full module list</span><br><span class="line">&gt; start             end                 module name</span><br><span class="line">&gt; 00007ffc`76cf0000 00007ffc`76ee8000   ntdll      (pdb symbols)          d:\mssyms\ntdll.pdb\180BF1B90AA75697D0EFEA5E5630AC7E1\ntdll.pdb</span><br><span class="line">&gt; 0:006&gt; # &quot;ntdll!LdrpLoadCompleteEvent&quot; 00007ffc`76cf0000 L99999</span><br><span class="line">&gt; ntdll!LdrpDropLastInProgressCount+0x38:</span><br><span class="line">&gt; 00007ffc`76d4eeb4 488b0dc5d41000  mov     rcx,qword ptr [ntdll!LdrpLoadCompleteEvent (00007ffc`76e5c380)]</span><br><span class="line">&gt; ntdll!LdrpDrainWorkQueue+0x2d:</span><br><span class="line">&gt; 00007ffc`76d4fef1 4c0f443587c41000 cmove   r14,qword ptr [ntdll!LdrpLoadCompleteEvent (00007ffc`76e5c380)]</span><br><span class="line">&gt; ntdll!LdrpCreateLoaderEvents+0x12:</span><br><span class="line">&gt; 00007ffc`76d6eb22 488d0d57d80e00  lea     rcx,[ntdll!LdrpLoadCompleteEvent (00007ffc`76e5c380)]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>在 <code>IDA</code> 中查看另外两个函数的反汇编，<code>F5</code> 结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">LdrpCreateLoaderEvents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// [rsp+20h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+20h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  result = ZwCreateEvent(&amp;LdrpLoadCompleteEvent, <span class="number">2031619</span>i64, <span class="number">0</span>i64, <span class="number">1</span>i64, v1);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)result &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LOBYTE(v2) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ZwCreateEvent(&amp;LdrpWorkCompleteEvent, <span class="number">2031619</span>i64, <span class="number">0</span>i64, <span class="number">1</span>i64, v2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__<span class="function">int64 <span class="title">LdrpDropLastInProgressCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span> *<span class="title">v0</span>;</span> <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v0 = NtCurrentTeb();</span><br><span class="line">  v0-&gt;SameTebFlags &amp;= ~<span class="number">0x1000</span>u;</span><br><span class="line">  RtlEnterCriticalSection(&amp;LdrpWorkQueueLock);</span><br><span class="line">  LdrpWorkInProgress = <span class="number">0</span>;</span><br><span class="line">  RtlLeaveCriticalSection(&amp;LdrpWorkQueueLock);</span><br><span class="line">  <span class="keyword">return</span> ZwSetEvent(LdrpLoadCompleteEvent, <span class="number">0</span>i64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从伪代码可知，函数 <code>LdrpCreateLoaderEvents()</code> 会创建对应的事件，而函数  <code>LdrpDropLastInProgressCount()</code> 会触发事件。那谁会调用 <code>LdrpDropLastInProgressCount()</code> 呢？继续在 <code>IDA</code> 中查找引用，如下图：</p><p><img src="http://resources.bianchengnan.tech/debugging-deadlock-when-dll-unload-on-win10/view-droplastinprogresscount-reference-in-ida.png" alt="view-droplastinprogresscount-reference-in-ida"></p><p>从图中可知，有很多函数都引用了 <code>LdrpDropLastInProgressCount()</code>，静态分析有点太费事了，如果能动态调试就再好不过了。</p><h2 id="继续调试"><a href="#继续调试" class="headerlink" title="继续调试"></a>继续调试</h2><p>我们之前在 <code>DllMain()</code> 中是无限等待的，如果只等待几秒，程序是可以正常退出的，也就是说 <code>DllMain()</code> 执行后应该是有人调用了 <code>SetEvent()</code> 的。修改代码为只等待 <code>5</code> 秒，等待结束后在 <code>ntdll!NtSetEvent()</code> 函数上设置断点，应该可以看到是谁触发了事件。整个过程比较简单，就省略了，直接给出结果，如下图：</p><p><img src="http://resources.bianchengnan.tech/debugging-deadlock-when-dll-unload-on-win10/setevent-called-in-LdrUnloadDll.png" alt="setevent-called-in-LdrUnloadDll"></p><p>看来，<code>LdrUnloadDll()</code> 函数会先调用 <code>DllMain()</code>，<code>DllMain()</code> 执行完成后，<code>LdrUnloadDll()</code> 会继续调用  <code>LdrpDropLastInProgressCount()</code> ，进而触发事件。如果我们在 <code>DllMain()</code> 中一直等待，<code>LdrUnloadDll()</code> 就没机会调用 <code>LdrpDropLastInProgressCount()</code> ，也就不会触发事件，最终就会导致死锁。</p><p>函数 <code>LdrUnloadDll()</code> 对应的伪代码如下（来自 <code>IDA</code> 的 <code>F5</code>，有删减）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">LdrUnloadDll</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LoadedDllByHandle = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !byte_7FFC76E5C508 )</span><br><span class="line">  &#123;</span><br><span class="line">    LoadedDllByHandle = LdrpFindLoadedDllByHandle(a1, &amp;v6, &amp;v5);</span><br><span class="line">    <span class="keyword">if</span> ( LoadedDllByHandle &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = v6;      </span><br><span class="line">      LoadedDllByHandle = LdrpDecrementModuleLoadCountEx(v6, <span class="number">1u</span>);</span><br><span class="line">      <span class="keyword">if</span> ( LoadedDllByHandle == <span class="number">0xC000022D</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        loadOwnerFlag = NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">0x1000</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !loadOwnerFlag )</span><br><span class="line">          LdrpDrainWorkQueue(<span class="number">0</span>); <span class="comment">//&lt;----</span></span><br><span class="line">        v2 = v6;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 内部会调用 DllMain()</span></span><br><span class="line">        LdrpDecrementModuleLoadCountEx(v6, <span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> ( !loadOwnerFlag )</span><br><span class="line">          LdrpDropLastInProgressCount(); <span class="comment">//&lt;----</span></span><br><span class="line">          </span><br><span class="line">        LoadedDllByHandle = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      LdrpDereferenceModule(v2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)LoadedDllByHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>LdrUnloadDll()</code> 会先调用 <code>LdrpDrainWorkQueue()</code>，然后调用 <code>LdrpDecrementModuleLoadCountEx()</code>（其内部会调用 <code>DllMain()</code>），最后调用 <code>LdrpDropLastInProgressCount()</code>。</p><p>死锁的原因找到了，但是为什么第一个线程可以顺利退出呢？难道第一个线程没有等待吗？</p><h2 id="继续深挖"><a href="#继续深挖" class="headerlink" title="继续深挖"></a>继续深挖</h2><p>在继续深挖之前，非常有必要对相关代码有个了解，以下是 <code>LdrShutdownThread()</code> 和 <code>LdrpDrainWorkQueue()</code> 的伪代码。</p><ul><li><code>LdrShutdownThread()</code> 的伪代码如下（来自 <code>IDA</code> 的 <code>F5</code>，有删减）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">LdrShutdownThread</span><span class="params">(struct _RTLP_FLS_CONTEXT *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 省略若干代码</span></span><br><span class="line">  <span class="keyword">if</span> ( ((NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">8</span>) == <span class="number">0</span> || (NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">0x20</span>) != <span class="number">0</span>)</span><br><span class="line">    &amp;&amp; (v1-&gt;SameTebFlags &amp; <span class="number">0x2000</span>) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">0x1000</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      loadOwner = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      loadOwner = <span class="number">0</span>;</span><br><span class="line">      LdrpDrainWorkQueue(<span class="number">0</span>); <span class="comment">//&lt;----</span></span><br><span class="line">    &#125;</span><br><span class="line">    LdrpAcquireLoaderLock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环调用 LdrpCallInitRoutine()，内部会调用 DllMain()</span></span><br><span class="line">    <span class="comment">// 省略若干代码</span></span><br><span class="line">      </span><br><span class="line">    LdrpReleaseLoaderLock(v5, <span class="number">19</span>i64);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !loadOwner )</span><br><span class="line">      LdrpDropLastInProgressCount(); <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line">    LdrpFreeTls(v9);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略若干代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上伪代码可知，函数 <code>LdrShutdownThread()</code> 调用 <code>LdrpDrainWorkQueue()</code> 时传递的 <code>tastType</code> 参数的值是 <code>0</code>。</p><ul><li><code>LdrpDrainWorkQueue()</code> 的伪代码如下（来自 <code>IDA</code> 的 <code>F5</code>，有删减）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span> *__<span class="title">fastcall</span> <span class="title">LdrpDrainWorkQueue</span>(<span class="title">int</span> <span class="title">taskType</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  HANDLE hEvent; <span class="comment">// r14</span></span><br><span class="line">  hEvent = (HANDLE)LdrpWorkCompleteEvent;</span><br><span class="line">  <span class="keyword">if</span> ( !taskType )</span><br><span class="line">    hEvent = LdrpLoadCompleteEvent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      RtlEnterCriticalSection(&amp;LdrpWorkQueueLock);</span><br><span class="line">      v4 = LdrpDetourExist;</span><br><span class="line">      <span class="comment">// 我机器上有 hook，LdrpDetourExist 的值是 1，</span></span><br><span class="line">      <span class="comment">// 而且 LdrShutdownThread 调用此函数的时候传递的是 0，</span></span><br><span class="line">      <span class="comment">// 也就是 taskType 的值是 0，我机器上永远会走 else</span></span><br><span class="line">      <span class="keyword">if</span> ( !LdrpDetourExist || taskType == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = (__int64 *)LdrpWorkQueue;</span><br><span class="line">        <span class="keyword">if</span> ( *(__int64 **)(LdrpWorkQueue + <span class="number">8</span>) != &amp;LdrpWorkQueue</span><br><span class="line">          || (v6 = *(_QWORD *)LdrpWorkQueue, *(_QWORD *)(*(_QWORD *)LdrpWorkQueue + <span class="number">8</span>i64) != LdrpWorkQueue) )</span><br><span class="line">        &#123;</span><br><span class="line">          __fastfail(<span class="number">3u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LdrpWorkQueue = *(_QWORD *)LdrpWorkQueue;</span><br><span class="line">        *(_QWORD *)(v6 + <span class="number">8</span>) = &amp;LdrpWorkQueue;</span><br><span class="line">        <span class="keyword">if</span> ( &amp;LdrpWorkQueue == v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( LdrpWorkInProgress == taskType )</span><br><span class="line">          &#123;</span><br><span class="line">            LdrpWorkInProgress = <span class="number">1</span>;</span><br><span class="line">            v2 = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( !v4 )</span><br><span class="line">            ++LdrpWorkInProgress;</span><br><span class="line">          LdrpUpdateStatistics();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// LdrpWorkInProgress 如果是 0（表明没有工作在进行中），</span></span><br><span class="line">        <span class="comment">// 那么 v2 会被设置成 1 (因为 taskType 的值是 0)</span></span><br><span class="line">        <span class="keyword">if</span> ( LdrpWorkInProgress == taskType )</span><br><span class="line">        &#123;</span><br><span class="line">          LdrpWorkInProgress = <span class="number">1</span>;</span><br><span class="line">          v2 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v5 = &amp;LdrpWorkQueue;</span><br><span class="line">      &#125;</span><br><span class="line">      RtlLeaveCriticalSection(&amp;LdrpWorkQueueLock);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 关键判断，如果 v2 不是 0，则跳出内层循环，不会等待</span></span><br><span class="line">      <span class="keyword">if</span> ( v2 ) <span class="comment">//&lt;----</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 如果队列中无需要处理的项，则等待，否则处理</span></span><br><span class="line">      <span class="keyword">if</span> ( &amp;LdrpWorkQueue == v5 )</span><br><span class="line">        NtWaitForSingleObject(hEvent, <span class="number">0</span>, <span class="number">0</span>i64); <span class="comment">//&lt;----</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        LdrpProcessWork((__int64)(v5 - <span class="number">8</span>), v4);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 taskType 是 0，跳出外层循环</span></span><br><span class="line">    <span class="keyword">if</span> ( !taskType || (__int64 *)LdrpRetryQueue == &amp;LdrpRetryQueue )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外层循环，处理 retry 逻辑，省略相关代码</span></span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 LoadOwner 标记，后续调用 LdrpDropLastInProgressCount() 的时候会清除</span></span><br><span class="line">  result = NtCurrentTeb();</span><br><span class="line">  result-&gt;SameTebFlags |= <span class="number">0x1000</span>u;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>LdrpWorkInProgress</code> 的值是 <code>0</code>，则  <code>LdrpWorkInProgress</code> 会被设置成 <code>1</code>。在执行等待代码的上方会跳出循环，因此不会执行等待逻辑。这也就解释了为什么第一个线程退出的时候为什么可以正常退出。</p><blockquote><p><strong>说明：</strong> 仔细阅读这个变量的名字，<code>LdrpWorkInProgress</code> 表示正在处理的工作数量，如果没有工作，则是 <code>0</code>，有工作则非零。</p></blockquote><p>那 <code>LdrpWorkInProgress</code> 什么时候会被改变呢？</p><h2 id="LdrpWorkInProgress"><a href="#LdrpWorkInProgress" class="headerlink" title="LdrpWorkInProgress"></a>LdrpWorkInProgress</h2><p>可以在 <code>windbg</code> 中使用 <code># &quot;LdrpWorkInProgress&quot; 00007ffc76cf0000 L99999</code> 查看 <code>LdrpWorkInProgress</code> 的使用情况，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; # &quot;LdrpWorkInProgress&quot; 00007ffc`76cf0000 L99999</span><br><span class="line">ntdll!LdrpDropLastInProgressCount+0x25:</span><br><span class="line">00007ffc`76d4eea1 832540d5100000  and     dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)],0</span><br><span class="line">ntdll!LdrpDrainWorkQueue+0x83:</span><br><span class="line">00007ffc`76d4ff47 393d9bc41000    cmp     dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)],edi</span><br><span class="line">ntdll!LdrpDrainWorkQueue+0x8b:</span><br><span class="line">00007ffc`76d4ff4f c7058fc4100001000000 mov dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)],1</span><br><span class="line">ntdll!LdrpDrainWorkQueue+0x168:</span><br><span class="line">00007ffc`76d5002c ff05b6c31000    inc     dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)]</span><br><span class="line">ntdll!LdrpWorkCallback+0x4c:</span><br><span class="line">00007ffc`76d500ac ff0536c31000    inc     dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)]</span><br><span class="line">ntdll!LdrpProcessWork+0x1a0:</span><br><span class="line">00007ffc`76d5028c 8b0556c11000    mov     eax,dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)]</span><br><span class="line">ntdll!LdrpProcessWork+0x1a8:</span><br><span class="line">00007ffc`76d50294 89054ec11000    mov     dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)],eax</span><br><span class="line">ntdll!LdrpUpdateStatistics+0x6:</span><br><span class="line">00007ffc`76d502ea 3b0df8c01000    cmp     ecx,dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)]</span><br><span class="line">ntdll!LdrpUpdateStatistics+0x15:</span><br><span class="line">00007ffc`76d502f9 0f420de8c01000  cmovb   ecx,dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)]</span><br><span class="line">ntdll!LdrpProcessWork$fin$0+0x41:</span><br><span class="line">00007ffc`76d96085 8b055d630c00    mov     eax,dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)]</span><br><span class="line">ntdll!LdrpProcessWork$fin$0+0x49:</span><br><span class="line">00007ffc`76d9608d 890555630c00    mov     dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)],eax</span><br><span class="line">ntdll!LdrpDrainWorkQueue+0x5d3bd:</span><br><span class="line">00007ffc`76dad281 393d61f10a00    cmp     dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)],edi</span><br><span class="line">ntdll!LdrpDrainWorkQueue+0x5d3c5:</span><br><span class="line">00007ffc`76dad289 c70555f10a0001000000 mov dword ptr [ntdll!LdrpWorkInProgress (00007ffc`76e5c3e8)],1</span><br></pre></td></tr></table></figure><p>可以发现在 <code>LdrpDrainWorkQueue()</code>、<code>LdrpProcessWork()</code>、<code>LdrpDropLastInProgressCount()</code>、<code>LdrpWorkCallback()</code> 中会修改它的值。</p><p>结合 <code>LdrUnloadDll()</code>、<code>LdrpDrainWorkQueue()</code> 和 <code>LdrpDropLastInProgressCount()</code> 的代码可知，其在调用 <code>DllMain()</code> 之前会通过 <code>LdrpDrainWorkQueue()</code> 设置 <code>LdrpWorkInProgress</code> 标志，在调用完 <code>DllMain()</code> 之后，又会通过调用 <code>LdrpDropLastInProgressCount()</code> 把这个值设置为 <code>0</code>。</p><p>其实，<code>LdrShutdownThread()</code> 也有类似的逻辑，也是会先调用 <code>LdrpDrainWorkQueue()</code> ，然后执行一些业务代码，最后会调用 <code>LdrpDropLastInProgressCount()</code> 。我们再看观察其它几个会调用 <code>LdrpDropLastInProgressCount()</code> 的函数，注意观察以下代码中的 <code>//&lt;----</code> 标记。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><ul><li><code>LdrpLoadDllInternal()</code> 的伪代码如下（来自 <code>IDA</code> 的 <code>F5</code>，有删减）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">LdrpLoadDllInternal</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, __int64 a5, __int64 a6, __int64 *a7, <span class="keyword">int</span> *a8)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  result = LdrpFastpthReloadedDll(a1, a3, a6, a7);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)result &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">0x1000</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      loadOwnerFlag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      loadOwnerFlag = <span class="number">0</span>;</span><br><span class="line">      LdrpDrainWorkQueue(<span class="number">0</span>); <span class="comment">//&lt;----</span></span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> ( !a6 || loadOwnerFlag || *(_DWORD *)(*(_QWORD *)(a6 + <span class="number">152</span>) + <span class="number">24</span>i64) )</span><br><span class="line">    &#123;</span><br><span class="line">      LdrpDetectDetour();</span><br><span class="line">      v12 = a8;</span><br><span class="line">      v14 = LdrpFindOrPrepareLoadingModule(a1, a2, a3, a4, a5, (__int64)&amp;v19, (__int64)a8);</span><br><span class="line">      <span class="keyword">if</span> ( v14 == <span class="number">-1073741515</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        LdrpProcessWork(*(_QWORD *)(v19 + <span class="number">176</span>), <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v14 != <span class="number">-1073741267</span> &amp;&amp; v14 &lt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *a8 = v14;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v12 = a8;</span><br><span class="line">      *a8 = <span class="number">-1073741515</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> ( !loadOwnerFlag )</span><br><span class="line">      result = LdrpDropLastInProgressCount(); <span class="comment">//&lt;----</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v12 = a8;</span><br><span class="line">    *a8 = result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>LdrpInitializeThread()</code> 的伪代码如下（来自 <code>IDA</code> 的 <code>F5</code>，有删减）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">LdrpInitializeThread</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  RtlpInitializeThreadActivationContextStack(v3, a2, a3, a1);</span><br><span class="line">  <span class="keyword">if</span> ( (NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">8</span>) == <span class="number">0</span></span><br><span class="line">    || (result = (__int64)NtCurrentTeb(), (*(_BYTE *)(result + <span class="number">0x17EE</span>) &amp; <span class="number">0x20</span>) != <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0x2000</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( (*(_WORD *)(v5 + <span class="number">6126</span>) &amp; <span class="number">0x2000</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      LdrpDrainWorkQueue(<span class="number">0</span>); <span class="comment">//&lt;----</span></span><br><span class="line">      LdrpAcquireLoaderLock();</span><br><span class="line">      <span class="keyword">for</span> ( i = qword_7FFC76E5C4D0; (__int64 *)i != &amp;qword_7FFC76E5C4D0; i = *(_QWORD *)i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(<span class="keyword">int</span> *)(*(_QWORD *)(i + <span class="number">152</span>) + <span class="number">56</span>i64) &gt;= <span class="number">9</span></span><br><span class="line">          &amp;&amp; ProcessEnvironmentBlock-&gt;ImageBaseAddress != *(<span class="keyword">void</span> **)(i + <span class="number">48</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v11 = *(_DWORD *)(i + <span class="number">104</span>);</span><br><span class="line">          <span class="keyword">if</span> ( (v11 &amp; <span class="number">0x40000</span>) == <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v12 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64))(i + <span class="number">56</span>);</span><br><span class="line">            <span class="keyword">if</span> ( v12 )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( (v11 &amp; <span class="number">0x80004</span>) == <span class="number">524292</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span> ( byte_7FFC76E5C508 )</span><br><span class="line">                  <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">                RtlActivateActivationContextUnsafeFast(&amp;v13, *(_QWORD *)(i + <span class="number">136</span>));</span><br><span class="line">                <span class="keyword">if</span> ( *(_WORD *)(i + <span class="number">110</span>) )</span><br><span class="line">                  LdrpCallTlsInitializers(<span class="number">2</span>i64, i);</span><br><span class="line">                LdrpCallInitRoutine(v12, *(_QWORD *)(i + <span class="number">48</span>), <span class="number">2u</span>, <span class="number">0</span>i64);</span><br><span class="line">                RtlDeactivateActivationContextUnsafeFast((__int64)&amp;v13);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *(_WORD *)(LdrpImageEntry + <span class="number">110</span>) &amp;&amp; !byte_7FFC76E5C508 )</span><br><span class="line">      &#123;</span><br><span class="line">        RtlActivateActivationContextUnsafeFast(&amp;v19, *(_QWORD *)(LdrpImageEntry + <span class="number">136</span>));</span><br><span class="line">        LdrpCallTlsInitializers(<span class="number">2</span>i64, LdrpImageEntry);</span><br><span class="line">        RtlDeactivateActivationContextUnsafeFast((__int64)&amp;v19);</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_22:</span><br><span class="line">      LdrpReleaseLoaderLock(v9, <span class="number">21</span>i64);</span><br><span class="line">      <span class="keyword">return</span> LdrpDropLastInProgressCount(); <span class="comment">//&lt;----</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>LdrEnumerateLoadedModules()</code> 的伪代码如下（来自 <code>IDA</code> 的 <code>F5</code>，有删减）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">LdrEnumerateLoadedModules</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">void</span> (__fastcall *a2)(__int64 *, __int64, <span class="keyword">char</span> *), __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">0x1000</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    loadOwnerFlag = <span class="number">1</span>;</span><br><span class="line">    v10 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    loadOwnerFlag = <span class="number">0</span>;</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    LdrpDrainWorkQueue(<span class="number">0</span>); <span class="comment">//&lt;----</span></span><br><span class="line">  &#125;</span><br><span class="line">  LdrpAcquireLoaderLock();</span><br><span class="line">  <span class="keyword">for</span> ( i = (__int64 *)qword_7FFC76E5C4D0; i != &amp;qword_7FFC76E5C4D0; i = (__int64 *)*i )</span><br><span class="line">  &#123;</span><br><span class="line">    a2(i, a3, &amp;v9);</span><br><span class="line">    <span class="keyword">if</span> ( v9 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LdrpReleaseLoaderLock(v6, <span class="number">15</span>i64);</span><br><span class="line">  <span class="keyword">if</span> ( !loadOwnerFlag )</span><br><span class="line">    LdrpDropLastInProgressCount(); <span class="comment">//&lt;----</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码中可以发现一个通用的模式，基本上会分成以下三个部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// part 1</span></span><br><span class="line"><span class="keyword">if</span> ( (NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">0x1000</span>) == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    loadOwnerFlag = <span class="number">0</span>;</span><br><span class="line">    LdrpDrainWorkQueue(<span class="number">0</span>); <span class="comment">//&lt;----</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part 2</span></span><br><span class="line"><span class="comment">// 业务处理代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// part 3</span></span><br><span class="line"><span class="keyword">if</span> ( !loadOwnerFlag )</span><br><span class="line">    LdrpDropLastInProgressCount(); <span class="comment">//&lt;----</span></span><br></pre></td></tr></table></figure><p>有点类似于用全局变量 <code>LdrpWorkInProgress</code> 做了一个锁。<code>part1</code> 先检查这个全局变量，如果已经设置了标记就等待，否则就设置标记。然后在 <code>part2</code> 执行业务代码，最后在 <code>part3</code> 清除这个标记。如果在 <code>part2</code> 中卡住了，其它线程就要执行等待逻辑。</p><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>至此，整个卡死的前因后果都非常清晰了。</p><p>第一个线程结束的时候，我们没有执行 <code>FreeLibrary()</code>，也就不会执行 <code>LdrUnloadDll()</code>，<code>LdrpWorkInProgress</code> 的值是 <code>0</code>，<code>LdrShutdownThread()</code> 内部调用 <code>LdrpDrainWorkQueue()</code> 的时候，由于 <code>LdrpWorkInProgress</code> 的值是 <code>0</code>，所以不会等待。</p><p>当第二个线程结束的时候，<code>LdrUnloadDll()</code> 正在 <code>DllMain()</code> 中等待其结束，而在此之前 <code>LdrpWorkInProgress</code> 已经被 <code>LdrUnloadDll()</code> 设置成 <code>1</code> 了。所以第二个线程对应的 <code>LdrShutdownThread()</code> 内部调用 <code>LdrpDrainWorkQueue()</code> 的时候，对应的 <code>LdrpWorkInProgress</code> 的值是 <code>1</code>，因此需要等待。而 <code>DllMain()</code> 由于在等待线程结束，但是线程永远不会结束，<code>LdrUnloadDll()</code> 也就没机会调用后面的 <code>LdrpDropLastInProgressCount()</code> 触发事件，于是死锁了。</p><h2 id="TEB-SameTebFlags"><a href="#TEB-SameTebFlags" class="headerlink" title="TEB.SameTebFlags"></a>TEB.SameTebFlags</h2><p>关于 <code>SameTebFlags</code> 可能的标志位信息，我问了一下 <code>AI</code>，看着比较靠谱，未经证实，各位谨慎参考。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标志位掩码（共 16 位）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _TEB_SAME_TEB_FLAGS &#123;</span><br><span class="line"></span><br><span class="line">    SafeThunkCall               = <span class="number">0x0001</span>,  <span class="comment">// 0x0001</span></span><br><span class="line">    InDebugPrint                = <span class="number">0x0002</span>,  <span class="comment">// 0x0002</span></span><br><span class="line">    HasFiberData                = <span class="number">0x0004</span>,  <span class="comment">// 0x0004</span></span><br><span class="line">    SkipThreadAttach            = <span class="number">0x0008</span>,  <span class="comment">// 0x0008</span></span><br><span class="line"></span><br><span class="line">    WerInShipAssertCode         = <span class="number">0x0010</span>,  <span class="comment">// 0x0010</span></span><br><span class="line">    RanProcessInit              = <span class="number">0x0020</span>,  <span class="comment">// 0x0020</span></span><br><span class="line">    ClonedThread                = <span class="number">0x0040</span>,  <span class="comment">// 0x0040</span></span><br><span class="line">    SuppressDebugMsg            = <span class="number">0x0080</span>,  <span class="comment">// 0x0080</span></span><br><span class="line">    </span><br><span class="line">    DisableUserStackWalk        = <span class="number">0x0100</span>,  <span class="comment">// 0x0100</span></span><br><span class="line">    RtlExceptionAttached        = <span class="number">0x0200</span>,  <span class="comment">// 0x0200</span></span><br><span class="line">    InitialThread               = <span class="number">0x0400</span>,  <span class="comment">// 0x0400</span></span><br><span class="line">    SessionAware                = <span class="number">0x0800</span>,  <span class="comment">// 0x0800</span></span><br><span class="line">    </span><br><span class="line">    LoadOwner                   = <span class="number">0x1000</span>,  <span class="comment">// 0x1000</span></span><br><span class="line">    LoaderWorker                = <span class="number">0x2000</span>,  <span class="comment">// 0x2000</span></span><br><span class="line">    </span><br><span class="line">    SkipLoaderInit              = <span class="number">0x4000</span>,  <span class="comment">// 0x4000</span></span><br><span class="line">    SkipFileAPIBrokering        = <span class="number">0x8000</span>,  <span class="comment">// 0x8000</span></span><br><span class="line">&#125; TEB_SAME_TEB_FLAGS;</span><br></pre></td></tr></table></figure><p>主要关注 <code>LoadOwner</code> 和 <code>LoaderWorker</code> 标志。</p><h2 id="Parallel-Loader"><a href="#Parallel-Loader" class="headerlink" title="Parallel Loader"></a>Parallel Loader</h2><p>在调查整个问题的过程中，查询了各种资料，才对这个问题有了一个粗浅的认识。原来在 <code>win10</code> 之前，所有涉及模块的操作都是串行完成的，通过加载器锁进行保护，如果遇到死锁，基本上可以通过 <code>!cs -l</code> 查看出来。而在 <code>win10</code> 中引入了并行加载器，加载工作改由多个工作线程并行执行。<strong>强烈建议</strong>阅读参考资料中的前两篇文章，以便对并行加载有个更深入的了解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>win10</code> 开启了并行加载，提高了加载速度，但是增大了调试难度。</li><li>永远不要在 <code>DllMain</code> 中做一些复杂操作，尤其是执行等待操作。</li><li><code>!handle handle flag</code> 命令可以查看句柄的信息，具体参考 <code>windbg</code> 帮助文档</li><li>可以在 <code>windbg</code> 中执行 <code># &quot;assembly_string&quot; memory_range</code> 搜索相关指令</li><li>在 <code>win10</code> 下查看加载器相关的逻辑可以关注 <code>ntdll!LdrpLoadCompleteEvent</code>、<code>LdrpWorkInProgress</code> 等全局变量</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://github.com/ElliotKillick/operating-system-design-review/blob/main/README.md" target="_blank" rel="noopener">https://github.com/ElliotKillick/operating-system-design-review/blob/main/README.md</a></p></li><li><p><a href="https://stackoverflow.com/questions/42789199/why-there-are-three-unexpected-worker-threads-when-a-win32-console-application-s/42789684#42789684" target="_blank" rel="noopener">https://stackoverflow.com/questions/42789199/why-there-are-three-unexpected-worker-threads-when-a-win32-console-application-s/42789684#42789684</a></p></li><li><p><a href="https://infocon.org/mirrors/vx%20underground%20-%202025%20June/Papers/Windows/Internals%20and%20Analysis/2017-10-03%20-%20Windows%2010%20Parallel%20Loading%20Breakdown.pdf" target="_blank" rel="noopener">https://infocon.org/mirrors/vx%20underground%20-%202025%20June/Papers/Windows/Internals%20and%20Analysis/2017-10-03%20-%20Windows%2010%20Parallel%20Loading%20Breakdown.pdf</a></p></li><li><p><a href="https://github.com/java-native-access/jna/issues/1479" target="_blank" rel="noopener">https://github.com/java-native-access/jna/issues/1479</a></p></li><li><p><a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/teb/sametebflags.htm" target="_blank" rel="noopener">https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/teb/sametebflags.htm</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;这篇文章分析了在 &lt;code&gt;Win10&lt;/code&gt; 系统上 &lt;code&gt;DLL&lt;/code&gt; 卸载时发生死锁的根本原因。通过调试发现，死锁是由于 &lt;code&gt;Win10&lt;/code&gt; 引入了并行加载器机制，导致线程在退出时等待全局事件 &lt;code&gt;LdrpLoadCompleteEvent&lt;/code&gt;，而该事件又因 &lt;code&gt;DllMain()&lt;/code&gt; 在处理 &lt;code&gt;DLL_PROCESS_DETACH&lt;/code&gt; 时调用 &lt;code&gt;WaitForSingleObject()&lt;/code&gt; 无限等待工作线程结束而无法被触发。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="IDA" scheme="https://bianchengnan.github.io/tags/IDA/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="死锁" scheme="https://bianchengnan.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="win10" scheme="https://bianchengnan.github.io/tags/win10/"/>
    
      <category term="引用计数" scheme="https://bianchengnan.github.io/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    
      <category term="Parallel Loader" scheme="https://bianchengnan.github.io/tags/Parallel-Loader/"/>
    
      <category term="并行加载" scheme="https://bianchengnan.github.io/tags/%E5%B9%B6%E8%A1%8C%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="LdrpLoadCompleteEvent" scheme="https://bianchengnan.github.io/tags/LdrpLoadCompleteEvent/"/>
    
      <category term="WaitForSingleObject" scheme="https://bianchengnan.github.io/tags/WaitForSingleObject/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 从无法复现到真相大白：DLL卸载死锁背后的版本陷阱</title>
    <link href="https://bianchengnan.github.io//articles/debugging-deadlock-when-dll-unload-continue/"/>
    <id>https://bianchengnan.github.io//articles/debugging-deadlock-when-dll-unload-continue/</id>
    <published>2026-02-07T10:21:33.000Z</published>
    <updated>2026-02-16T10:40:27.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>这篇文章记录了我对 <code>DLL</code> 卸载时死锁问题的进一步探索。多年前，我曾在看雪论坛上发表过一篇关于 <code>DLL</code> 卸载死锁的<a href="https://bbs.kanxue.com/thread-255547-1.htm" target="_blank" rel="noopener">分析文章</a>，但最近有网友反馈无法复现这个问题。通过深入调试，我发现问题根源在于不同版本的 <code>VS</code> 运行时库对引用计数的处理方式不同。本文详细展示了如何使用 <code>Windbg</code> 追踪 <code>DLL</code> 引用计数的变化，解释了为什么在 <code>VS2022</code> 环境下原问题不再出现，最终定位到不同版本的 <code>_beginthreadex</code> 和 <code>_endthreadex</code> 的内部实现差异是关键所在。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，网友跟我说我之前写的一篇文章有问题，他那里不能重现。文章是很糟之前发在看雪上的一篇关于 <code>dll</code> 卸载时死锁的文章。链接为 <a href="https://bbs.kanxue.com/thread-255547-1.htm。我的第一感觉是是不是操作系统不一致导致的加载/卸载行为发生变化导致的。但是这位网友给出的分析很可信。于是我自己也快速用" target="_blank" rel="noopener">https://bbs.kanxue.com/thread-255547-1.htm。我的第一感觉是是不是操作系统不一致导致的加载/卸载行为发生变化导致的。但是这位网友给出的分析很可信。于是我自己也快速用</a> <code>vs2022</code> 建了一个测试工程，发现没死锁。虽然网友已经给了他的结论，但还是很有必要整体梳理一下。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>这里再简单贴一下关键代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WaitDllUnloadExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE <span class="keyword">module</span> = LoadLibraryA(<span class="string">".\\DllUnload.dll"</span>);</span><br><span class="line">    Sleep(<span class="number">1000</span>);</span><br><span class="line">    FreeLibrary(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dllmain.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"process.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> g_quit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">stdcall <span class="title">procThread</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!g_quit)</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugStringA(<span class="string">"====procThread running.\n"</span>);</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OutputDebugStringA(<span class="string">"====procThread quitting.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">stdcall <span class="title">quitDemoProc</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx++ &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugStringA(<span class="string">"====quitDemoProc running!!!!!!!!\n"</span>);</span><br><span class="line">        Sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    OutputDebugStringA(<span class="string">"====quitDemoProc quitting!!!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        g_hThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;procThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        CloseHandle((HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;quitDemoProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugStringA(<span class="string">"====DLL_THREAD_ATTACH called.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugStringA(<span class="string">"====DLL_THREAD_DETACH called.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">256</span>] = <span class="string">""</span>;</span><br><span class="line">        sprintf_s(buffer, <span class="string">"====DLL_PROCESS_DETACH begin wait for thread=%x\n"</span>, (<span class="keyword">int</span>)g_hThread);</span><br><span class="line">        OutputDebugStringA(buffer);</span><br><span class="line">        g_quit = <span class="literal">true</span>;</span><br><span class="line">        DWORD waitResult = WaitForSingleObject(g_hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">        sprintf_s(buffer, <span class="string">"====DLL_PROCESS_DETACH end wait for thread=%x, result=%x\n"</span>, (<span class="keyword">int</span>)g_hThread, waitResult);</span><br><span class="line">        OutputDebugStringA(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初步观察"><a href="#初步观察" class="headerlink" title="初步观察"></a>初步观察</h2><p>运行新编译出来的程序，简单观察了一下程序行为，可以发现执行完 <code>FreeLibrary(module);</code> 后，<code>DllUnload.dll</code> 并没有被卸载，引用计数是 <code>1</code>。</p><p><img src="http://resources.bianchengnan.tech/debugging-deadlock-when-dll-unload-continue/view-dll-loadcount.png" alt="view-dll-loadcount"></p><p>继续执行，<code>main()</code> 函数结束后，如果还有其它线程在运行，这些线程会被自动杀掉。所以并没有出现卡死的现象。</p><p>那为什么引用计数不是 <code>0</code> 呢？按理说 <code>LoadLibraryA()</code> 和 <code>FreeLibrary()</code> 是成对儿出现的，引用计数应该归零才对。</p><h2 id="追踪引用计数"><a href="#追踪引用计数" class="headerlink" title="追踪引用计数"></a>追踪引用计数</h2><p>从上篇文章中可知，在 <code>win10</code> 系统下，每个模块的信息存储在 <code>Peb.Ldr.InLoadOrderModuleList</code> 中，引用计数存储在 <code>_LDR_DATA_TABLE_ENTRY</code> 的 <code>DdagNode-&gt;LoadCount</code> 中。可以在 <code>LoadCount</code> 上设置一个内存写断点。但是等一下，如果模块信息还没添加到 <code>InLoadOrderModuleList</code> 中，该如何设置断点呢？很简单，从 <code>InLoadOrderModuleList</code> 的名字可知，链表里存储的模块信息是按加载顺序来的。最新加载的模块会放到链表的末尾的位置，也就是 <code>BLink</code> 的位置，可以先对此字段设置内存写断点，有新模块被加载时，会修改此字段的值。</p><h2 id="监视添加模块"><a href="#监视添加模块" class="headerlink" title="监视添加模块"></a>监视添加模块</h2><p>重新运行程序，在调用 <code>LoadLibrary()</code> 的那行代码处设置断点，中断后，对 <code>Peb.Ldr.InLoadOrderModuleList</code> 的 <code>BLink</code> 设置写断点，然后让程序重新运行起来。很快断点便命中了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1 hit</span><br><span class="line">ntdll!LdrpInsertDataTableEntry+0x7f:</span><br><span class="line">00007ffc`e16e469f 488d0d3a7e1500  lea     rcx,[ntdll!PebLdr+0x20 (00007ffc`e183c4e0)]</span><br></pre></td></tr></table></figure><p>执行 <code>ub rip L3</code> 查看最近的三条汇编指令，可以发现正在把 <code>rbx</code> 的值写入 <code>rcx</code> 指向的地址，因此触发了断点。执行 <code>r rbx</code> 命令查看寄存器的值。可以发现 <code>rbx</code> 的值是 <code>00000217843326f0</code>，也就是说 <code>ntdll!_LDR_DATA_TABLE_ENTRY</code> 对象的地址是  <code>00000217843326f0</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ub rip L3</span><br><span class="line">ntdll!LdrpInsertDataTableEntry+0x74:</span><br><span class="line">00007ffc`e16e4694 488d4310        lea     rax,[rbx+10h]</span><br><span class="line">00007ffc`e16e4698 48894b08        mov     qword ptr [rbx+8],rcx</span><br><span class="line">00007ffc`e16e469c 488919          mov     qword ptr [rcx],rbx</span><br><span class="line"></span><br><span class="line">0:000&gt; r rbx</span><br><span class="line">rbx=00000217843326f0</span><br></pre></td></tr></table></figure><p>执行以下命令查看 <code>dll</code> 名称及引用计数。可以发现正是我们关注的 <code>dll</code>，而且当前的引用计数是 <code>1</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt ntdll!_LDR_DATA_TABLE_ENTRY 00000217843326f0 -y BaseDllName DdagNode-&gt;LoadCount</span><br><span class="line">   +0x058 BaseDllName         : _UNICODE_STRING &quot;DllUnload.dll&quot;</span><br><span class="line">   +0x098 DdagNode            : </span><br><span class="line">      +0x018 LoadCount           : 1</span><br></pre></td></tr></table></figure><p>可以执行 <code>k</code> 命令查看调用栈，可以知道是 <code>ntdll!LdrpInsertDataTableEntry()</code> 执行的插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; k</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 0000004b`86efe880 00007ffc`e16e4b73     ntdll!LdrpInsertDataTableEntry+0x7f</span><br><span class="line">01 0000004b`86efe8b0 00007ffc`e1731243     ntdll!LdrpMapDllWithSectionHandle+0xe3</span><br><span class="line">02 0000004b`86efe900 00007ffc`e1730ca0     ntdll!LdrpMapDllNtFileName+0x19f</span><br><span class="line">03 0000004b`86efea00 00007ffc`e1730160     ntdll!LdrpMapDllSearchPath+0x1d0</span><br><span class="line">04 0000004b`86efec60 00007ffc`e16efb53     ntdll!LdrpProcessWork+0x74</span><br><span class="line">05 0000004b`86efecc0 00007ffc`e16e73e4     ntdll!LdrpLoadDllInternal+0x13f</span><br><span class="line">06 0000004b`86efed40 00007ffc`e16e6af4     ntdll!LdrpLoadDll+0xa8</span><br><span class="line">07 0000004b`86efeef0 00007ffc`df1bdb72     ntdll!LdrLoadDll+0xe4</span><br><span class="line">08 0000004b`86efefe0 00007ffc`cb58f266     KERNELBASE!LoadLibraryExW+0x162</span><br><span class="line">09 0000004b`86eff050 00007ffc`df1b6af1     ObjectVirtualizeDll_x64!ProxyHttpApiHook+0x48696</span><br><span class="line">0a 0000004b`86eff4e0 00007ffc`df20a05f     KERNELBASE!LoadLibraryExA+0x31</span><br><span class="line">0b 0000004b`86eff520 00007ff7`bfc317c0     KERNELBASE!LoadLibraryA+0x3f</span><br><span class="line">0c 0000004b`86eff550 00007ff7`bfc31cc9     WaitDllUnloadExe!main+0x30</span><br><span class="line">0d 0000004b`86eff670 00007ff7`bfc31b6e     WaitDllUnloadExe!invoke_main+0x39</span><br><span class="line">0e 0000004b`86eff6c0 00007ff7`bfc31a2e     WaitDllUnloadExe!__scrt_common_main_seh+0x12e</span><br><span class="line">0f 0000004b`86eff730 00007ff7`bfc31d5e     WaitDllUnloadExe!__scrt_common_main+0xe</span><br><span class="line">10 0000004b`86eff760 00007ffc`e15d7374     WaitDllUnloadExe!mainCRTStartup+0xe</span><br><span class="line">11 0000004b`86eff790 00007ffc`e171cc91     KERNEL32!BaseThreadInitThunk+0x14</span><br><span class="line">12 0000004b`86eff7c0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br></pre></td></tr></table></figure><h2 id="监视引用计数修改"><a href="#监视引用计数修改" class="headerlink" title="监视引用计数修改"></a>监视引用计数修改</h2><p>从上面的分析可知，<code>DllUnload.dll</code> 模块对应的 <code>ntdll!_LDR_DATA_TABLE_ENTRY</code> 的地址是 <code>00000217843326f0</code>，其 <code>LoadCount</code> 的地址是 <code>poi(00000217843326f0 + 0x98) + 0x18</code> 也就是 <code>0000021784338e28</code>。可以执行以下命令对此地址设置内存写断点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ba w4 00000217`84338e28</span><br></pre></td></tr></table></figure><p>设置好内存写断点后，重新运行程序，很快就断下来了。执行 <code>k</code> 命令，可以发现引用计数是被谁修改的。调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 2 hit</span><br><span class="line">ntdll!LdrpIncrementModuleLoadCount+0x37:</span><br><span class="line">00007ffc`e16ef57b 488d0dfedc1400  lea     rcx,[ntdll!LdrpModuleDatatableLock (00007ffc`e183d280)]</span><br><span class="line">0:000&gt; k</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 0000004b`86efe630 00007ffc`e16e0182     ntdll!LdrpIncrementModuleLoadCount+0x37</span><br><span class="line">01 0000004b`86efe660 00007ffc`df1f082d     ntdll!LdrAddRefDll+0x42</span><br><span class="line">02 0000004b`86efe690 00007ffb`a6be33bf     KERNELBASE!GetModuleHandleExW+0xad</span><br><span class="line">03 0000004b`86efe6d0 00007ffb`a6be3804     ucrtbased!create_thread_parameter+0xcf</span><br><span class="line">04 0000004b`86efe730 00007ffb`aadc19b0     ucrtbased!_beginthreadex+0xd4 </span><br><span class="line">05 0000004b`86efe7b0 00007ffb`aadc2598     DllUnload!DllMain+0xb0</span><br><span class="line">06 0000004b`86efea00 00007ffb`aadc2771     DllUnload!dllmain_dispatch+0x98  </span><br><span class="line">07 0000004b`86efea50 00007ffc`e16e9a1d     DllUnload!_DllMainCRTStartup+0x31  </span><br><span class="line">08 0000004b`86efea80 00007ffc`e173d2f7     ntdll!LdrpCallInitRoutine+0x61</span><br><span class="line">09 0000004b`86efeaf0 00007ffc`e173d08a     ntdll!LdrpInitializeNode+0x1d3</span><br><span class="line">0a 0000004b`86efec40 00007ffc`e170d947     ntdll!LdrpInitializeGraphRecurse+0x42</span><br><span class="line">0b 0000004b`86efec80 00007ffc`e16efbae     ntdll!LdrpPrepareModuleForExecution+0xbf</span><br><span class="line">0c 0000004b`86efecc0 00007ffc`e16e73e4     ntdll!LdrpLoadDllInternal+0x19a</span><br><span class="line">0d 0000004b`86efed40 00007ffc`e16e6af4     ntdll!LdrpLoadDll+0xa8</span><br><span class="line">0e 0000004b`86efeef0 00007ffc`df1bdb72     ntdll!LdrLoadDll+0xe4</span><br><span class="line">0f 0000004b`86efefe0 00007ffc`cb58f266     KERNELBASE!LoadLibraryExW+0x162</span><br><span class="line">10 0000004b`86eff050 00007ffc`df1b6af1     ObjectVirtualizeDll_x64!ProxyHttpApiHook+0x48696</span><br><span class="line">11 0000004b`86eff4e0 00007ffc`df20a05f     KERNELBASE!LoadLibraryExA+0x31</span><br><span class="line">12 0000004b`86eff520 00007ff7`bfc317c0     KERNELBASE!LoadLibraryA+0x3f</span><br><span class="line">13 0000004b`86eff550 00007ff7`bfc31cc9     WaitDllUnloadExe!main+0x30</span><br><span class="line">14 0000004b`86eff670 00007ff7`bfc31b6e     WaitDllUnloadExe!invoke_main+0x39</span><br><span class="line">15 0000004b`86eff6c0 00007ff7`bfc31a2e     WaitDllUnloadExe!__scrt_common_main_seh+0x12e</span><br><span class="line">16 0000004b`86eff730 00007ff7`bfc31d5e     WaitDllUnloadExe!__scrt_common_main+0xe</span><br><span class="line">17 0000004b`86eff760 00007ffc`e15d7374     WaitDllUnloadExe!mainCRTStartup+0xe</span><br><span class="line">18 0000004b`86eff790 00007ffc`e171cc91     KERNEL32!BaseThreadInitThunk+0x14</span><br><span class="line">19 0000004b`86eff7c0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br></pre></td></tr></table></figure><p>可以发现是 <code>_beginthreadex()</code> 内部会间接调用 <code>KERNELBASE!GetModuleHandleExW()</code> 进而调用 <code>ntdll!LdrpIncrementModuleLoadCount()</code> 增加了引用计数。再次执行 <code>g</code> 命令，让程序重新运行起来。很快断点又再次命中。因为我们的 <code>DllMain()</code> 中创建了两个线程。</p><p><img src="http://resources.bianchengnan.tech/debugging-deadlock-when-dll-unload-continue/callstack-of-modify-dll-loadcount-second-time.png" alt="callstack-of-modify-dll-loadcount-second-time"></p><p>查看 <code>_beginthreadex()</code> 和 <code>_beginthread()</code> 的源码可知，这两个函数内部都会调用这段代码 <code>unique_thread_parameter parameter(create_thread_parameter(procedure, context));</code> 这段代码内部会调用 <code>GetModuleHandleExW()</code> 间接增加引用计数。</p><p><img src="http://resources.bianchengnan.tech/debugging-deadlock-when-dll-unload-continue/view-beginthread-source.png" alt="view-beginthread-source"></p><p>再次让程序运行，可以发现断点又触发了，引用计数变成了 <code>2</code>。这次是 <code>_endthreadex()</code> 调用触发的，入口函数是 <code>quitDemoProc</code> 对应的线程结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 2 hit</span><br><span class="line">ntdll!LdrpDecrementNodeLoadCountLockHeld+0x58:</span><br><span class="line">00007ffc`e16dfd80 418bd1          mov     edx,r9d</span><br><span class="line">0:010&gt; k</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 0000004b`878ffa58 00007ffc`e16dfcda     ntdll!LdrpDecrementNodeLoadCountLockHeld+0x58</span><br><span class="line">01 0000004b`878ffa60 00007ffc`e16dfc30     ntdll!LdrpDecrementModuleLoadCountEx+0x42</span><br><span class="line">02 0000004b`878ffa90 00007ffc`df2098ac     ntdll!LdrUnloadDll+0x40</span><br><span class="line">03 0000004b`878ffac0 00007ffb`a6be32cb     KERNELBASE!FreeLibraryAndExitThread+0x3c</span><br><span class="line">04 0000004b`878ffaf0 00007ffb`a6be3931     ucrtbased!common_end_thread+0xab</span><br><span class="line">05 0000004b`878ffb30 00007ffb`a6be3017     ucrtbased!_endthreadex+0x11 </span><br><span class="line">06 0000004b`878ffb60 00007ffc`e15d7374     ucrtbased!thread_start&lt;unsigned int (__cdecl*)(void *),1&gt;+0xb7 </span><br><span class="line">07 0000004b`878ffbc0 00007ffc`e171cc91     KERNEL32!BaseThreadInitThunk+0x14</span><br><span class="line">08 0000004b`878ffbf0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br><span class="line">0:010&gt; !dlls -c UnloadDll</span><br><span class="line">This is Win8 with the loader DAG.</span><br><span class="line"></span><br><span class="line">0x217842d6d80: C:\Windows\SYSTEM32\ucrtbased.dll</span><br><span class="line">      Base   0x7ffba6b30000  EntryPoint  0x7ffba6b88350  Size        0x00221000    DdagNode     0x217842d6ed0</span><br><span class="line">      Flags  0x0008a2ec  TlsIndex    0x00000000  LoadCount   0x00000002    NodeRefCount 0x00000000</span><br><span class="line">             &lt;unknown&gt;</span><br><span class="line">             LDRP_LOAD_NOTIFICATIONS_SENT</span><br><span class="line">             LDRP_IMAGE_DLL</span><br><span class="line">             LDRP_PROCESS_ATTACH_CALLED</span><br></pre></td></tr></table></figure><p>再次让程序运行，断点再次被触发，这次是 <code>FreeLibrary()</code> 触发的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; g</span><br><span class="line">Breakpoint 2 hit</span><br><span class="line">ntdll!LdrpDecrementNodeLoadCountLockHeld+0x58:</span><br><span class="line">00007ffc`e16dfd80 418bd1          mov     edx,r9d</span><br><span class="line">0:000&gt; k</span><br><span class="line"> # Child-SP          RetAddr               Call Site</span><br><span class="line">00 0000004b`86eff4b8 00007ffc`e16dfcda     ntdll!LdrpDecrementNodeLoadCountLockHeld+0x58</span><br><span class="line">01 0000004b`86eff4c0 00007ffc`e16dfc30     ntdll!LdrpDecrementModuleLoadCountEx+0x42</span><br><span class="line">02 0000004b`86eff4f0 00007ffc`df1b32de     ntdll!LdrUnloadDll+0x40</span><br><span class="line">03 0000004b`86eff520 00007ff7`bfc317d9     KERNELBASE!FreeLibrary+0x1e</span><br><span class="line">04 0000004b`86eff550 00007ff7`bfc31cc9     WaitDllUnloadExe!main+0x49</span><br><span class="line">05 0000004b`86eff670 00007ff7`bfc31b6e     WaitDllUnloadExe!invoke_main+0x39 </span><br><span class="line">06 0000004b`86eff6c0 00007ff7`bfc31a2e     WaitDllUnloadExe!__scrt_common_main_seh+0x12e</span><br><span class="line">07 0000004b`86eff730 00007ff7`bfc31d5e     WaitDllUnloadExe!__scrt_common_main+0xe  </span><br><span class="line">08 0000004b`86eff760 00007ffc`e15d7374     WaitDllUnloadExe!mainCRTStartup+0xe </span><br><span class="line">09 0000004b`86eff790 00007ffc`e171cc91     KERNEL32!BaseThreadInitThunk+0x14</span><br><span class="line">0a 0000004b`86eff7c0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>原来是，<code>vs2022</code> 编译时使用的运行时库中的 <code>_beginthreadex()</code> 会增加引用计数，<code>_endthreadex()</code> 会减少引用计数。两个线程中的一个会及时退出，而另外一个没有退出，导致引用计数没有归零，进而导致模块没有被卸载。所以就没出现卡死的情况。</p><p>而 <code>vs2010</code> 编译时使用的运行时库中的 <code>_endthreadex()</code> 不会修改引用计数（具体参考 <code>vs2010</code> 目录下的 <code>threadex.c</code> 文件）。当调用 <code>FreeLibrary()</code> 时，会触发模块卸载行为，进而会遇到卡死的情况。</p><h2 id="手动实验"><a href="#手动实验" class="headerlink" title="手动实验"></a>手动实验</h2><p>我已经把相关测试工程上传到了这里 todo，感兴趣的小伙伴可以自行测试验证。</p><blockquote><p><strong>说明：</strong> 如果想重现卡死问题，只需要修改【平台工具集】属性的值为 <code>Visual Studio 2010 (v100)</code></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>VS2022</code> 对应的运行时库中，<code>_beginthreadex()</code> 内部会调用 <code>GetModuleHandleExW()</code> 增加 <code>DLL</code> 的引用计数，而 <code>_endthreadex()</code> 则会减少引用计数。而 <code>VS2010</code> 对应的运行时库不会增加 <code>DLL</code> 的引用计数。</li><li>内存断点是必须要掌握的一种断点，适用于监视已知地址的内存变化。</li><li><code>!dlls -c module</code> 命令可以查看 <code>module</code> 对应的引用计数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;这篇文章记录了我对 &lt;code&gt;DLL&lt;/code&gt; 卸载时死锁问题的进一步探索。多年前，我曾在看雪论坛上发表过一篇关于 &lt;code&gt;DLL&lt;/code&gt; 卸载死锁的&lt;a href=&quot;https://bbs.kanxue.com/thread-255547-1.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分析文章&lt;/a&gt;，但最近有网友反馈无法复现这个问题。通过深入调试，我发现问题根源在于不同版本的 &lt;code&gt;VS&lt;/code&gt; 运行时库对引用计数的处理方式不同。本文详细展示了如何使用 &lt;code&gt;Windbg&lt;/code&gt; 追踪 &lt;code&gt;DLL&lt;/code&gt; 引用计数的变化，解释了为什么在 &lt;code&gt;VS2022&lt;/code&gt; 环境下原问题不再出现，最终定位到不同版本的 &lt;code&gt;_beginthreadex&lt;/code&gt; 和 &lt;code&gt;_endthreadex&lt;/code&gt; 的内部实现差异是关键所在。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="thread" scheme="https://bianchengnan.github.io/tags/thread/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="死锁" scheme="https://bianchengnan.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="引用计数" scheme="https://bianchengnan.github.io/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    
      <category term="crt" scheme="https://bianchengnan.github.io/tags/crt/"/>
    
      <category term="_beginthreadex" scheme="https://bianchengnan.github.io/tags/beginthreadex/"/>
    
  </entry>
  
  <entry>
    <title>调试技巧 | 从 Win7 到 Win10，DLL引用计数查看全攻略</title>
    <link href="https://bianchengnan.github.io//articles/how-to-view-dll-ref-count/"/>
    <id>https://bianchengnan.github.io//articles/how-to-view-dll-ref-count/</id>
    <published>2026-01-31T11:11:33.000Z</published>
    <updated>2026-02-16T10:40:27.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有两种常用的方式可以查看 <code>dll</code> 的引用计数。</p><ol><li><p>在 <code>windbg</code> 中通过 <code>!dlls</code> 命令查看 <code>dll</code> 的引用计数。<code>!dlls</code> 输出结果中包含 <code>LoadCount</code> 字段。</p><p><strong>注意：</strong> 不同版本的 <code>windbg</code> 使用的 <code>!exts.dlls</code> 命令解析方式不同，低版本的 <code>windbg</code> 在解析 <code>win10</code> 上运行程序的 <code>dll</code> 引用计数，解析结果很可能是错的。</p></li><li><p>手动解析 <code>PEB</code> 中的 <code>PEB_LDR_DATA</code> 中的模块加载列表数据查看 <code>dll</code> 的引用计数。</p><ul><li><p><code>Win7</code> 及之前系统：<br>找到 <code>PEB</code> 中的 <code>PEB_LDR_DATA</code> (<code>Ldr</code> 字段)，遍历其 <code>InLoadOrderModuleList</code> 链表。链表项为 <code>_LDR_DATA_TABLE_ENTRY</code> 结构，其中的 <code>LoadCount</code> 字段即为引用计数。</p></li><li><p><code>Win8</code> 及之后系统：<br>结构发生变化，需在 <code>_LDR_DATA_TABLE_ENTRY</code> 中找到 <code>DdagNode</code> 字段（它是一个指向 <code>_LDR_DDAG_NODE</code> 的指针），该结构中的 <code>LoadCount</code> 字段为当前引用计数。</p></li></ul></li></ol><a id="more"></a><h2 id="win7-查看方法"><a href="#win7-查看方法" class="headerlink" title="win7 查看方法"></a>win7 查看方法</h2><p>进程的 <code>PEB</code> 中保存了 <code>PEB_LDR_DATA</code>，对应的字段名为 <code>ldr</code>，可以通过 <code>dt _PEB @$peb -b ldr</code> 命令查看 <code>ldr</code> 的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _PEB @$peb -b ldr</span><br><span class="line">ntdll!_PEB</span><br><span class="line">   +0x00c Ldr : 0x77290200</span><br></pre></td></tr></table></figure><p><code>ldr</code> 中有三个链表，分别是 <code>InLoadOrderModuleList</code>，<code>InMemoryOrderModuleList</code> 和 <code>InInitializationOrderModuleList</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt ntdll!_PEB_LDR_DATA 0x77290200 </span><br><span class="line">   +0x000 Length           : 0x30</span><br><span class="line">   +0x004 Initialized      : 0x1 &apos;&apos;</span><br><span class="line">   +0x008 SsHandle         : (null) </span><br><span class="line">   +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x6b27a0 - 0x6b34b0 ]    //&lt;----</span><br><span class="line">   +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x6b27a8 - 0x6b34b8 ]    //&lt;----</span><br><span class="line">   +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x6b2840 - 0x6b34c0 ]    //&lt;----</span><br><span class="line">   +0x024 EntryInProgress  : (null) </span><br><span class="line">   +0x028 ShutdownInProgress : 0 &apos;&apos;</span><br><span class="line">   +0x02c ShutdownThreadId : (null)</span><br></pre></td></tr></table></figure><p>每个链表项的类型是 <code>LDR_DATA_TABLE_ENTRY</code>，结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _LDR_DATA_TABLE_ENTRY <span class="number">0x6b27a0</span> </span><br><span class="line">ntdll!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY [ <span class="number">0x6b2830</span> - <span class="number">0x7729020c</span> ]</span><br><span class="line">   +<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY [ <span class="number">0x6b2838</span> - <span class="number">0x77290214</span> ]</span><br><span class="line">   +<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY [ <span class="number">0x0</span> - <span class="number">0x0</span> ]</span><br><span class="line">   +<span class="number">0x018</span> DllBase          : <span class="number">0x00fa0000</span> Void</span><br><span class="line">   +<span class="number">0x01c</span> EntryPoint       : <span class="number">0x00fb1109</span> Void</span><br><span class="line">   +<span class="number">0x020</span> SizeOfImage      : <span class="number">0x1b000</span></span><br><span class="line">   +<span class="number">0x024</span> FullDllName      : _UNICODE_STRING <span class="string">"C:\Users\bcn\Desktop\WaitDllUnloadExe.exe"</span></span><br><span class="line">   +<span class="number">0x02c</span> BaseDllName      : _UNICODE_STRING <span class="string">"WaitDllUnloadExe.exe"</span></span><br><span class="line">   +<span class="number">0x034</span> Flags            : <span class="number">0x4000</span></span><br><span class="line">   +<span class="number">0x038</span> LoadCount        : <span class="number">0xffff</span>    <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x03a</span> TlsIndex         : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x03c</span> HashLinks        : _LIST_ENTRY [ <span class="number">0x77294818</span> - <span class="number">0x77294818</span> ]</span><br><span class="line">   +<span class="number">0x03c</span> SectionPointer   : <span class="number">0x77294818</span> Void</span><br><span class="line">   +<span class="number">0x040</span> CheckSum         : <span class="number">0x77294818</span></span><br><span class="line">   +<span class="number">0x044</span> TimeDateStamp    : <span class="number">0x696f76bc</span></span><br><span class="line">   +<span class="number">0x044</span> LoadedImports    : <span class="number">0x696f76bc</span> Void</span><br><span class="line">   +<span class="number">0x048</span> EntryPointActivationContext : (null) </span><br><span class="line">   +<span class="number">0x04c</span> PatchInformation : (null) </span><br><span class="line">   +<span class="number">0x050</span> ForwarderLinks   : _LIST_ENTRY [ <span class="number">0x6b27f0</span> - <span class="number">0x6b27f0</span> ]</span><br><span class="line">   +<span class="number">0x058</span> ServiceTagLinks  : _LIST_ENTRY [ <span class="number">0x6b27f8</span> - <span class="number">0x6b27f8</span> ]</span><br><span class="line">   +<span class="number">0x060</span> StaticLinks      : _LIST_ENTRY [ <span class="number">0x6b3568</span> - <span class="number">0x6b3488</span> ]</span><br><span class="line">   +<span class="number">0x068</span> ContextInformation : <span class="number">0x771cc924</span> Void</span><br><span class="line">   +<span class="number">0x06c</span> OriginalBase     : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x070</span> LoadTime         : _LARGE_INTEGER <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>可以通过如下命令显示出每个 <code>dll</code> 的引用计数。</p><p><code>!list -t nt!_LIST_ENTRY.FLink -x &quot;dt nt!_LDR_DATA_TABLE_ENTRY LoadCount BaseDllName @$extret&quot; 0x76ff5da0+0x00c</code>，其中 <code>0x77b80200</code> 为 <code>ldr</code> 的基址。</p><h2 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h2><p>关于以上命令的 <code>AI</code> 解释如下：</p><ol><li><p><strong><code>!list</code></strong></p><ul><li>专门用于遍历链表的 <code>Windbg</code> 扩展命令</li><li>可以遍历 <code>LIST_ENTRY</code> 结构定义的双向链表</li></ul></li><li><p><strong><code>-t nt!_LIST_ENTRY.FLink</code></strong></p><ul><li><code>-t</code> 指定链表节点的类型</li><li><code>nt!_LIST_ENTRY.FLink</code> 指定链表结构体中的前向指针字段</li><li>表示链表通过 <code>FLink</code> 字段连接</li></ul></li><li><p><strong><code>-x</code>选项及其参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-x &quot;dt nt!_LDR_DATA_TABLE_ENTRY LoadCount BaseDllName @$extret&quot;</span><br></pre></td></tr></table></figure><ul><li><code>-x</code> 表示对每个链表节点执行指定的命令</li><li>执行的命令是：<code>dt nt!_LDR_DATA_TABLE_ENTRY LoadCount BaseDllName @$extret</code></li><li><code>@$extret</code> 是一个伪寄存器，包含当前遍历到的节点地址</li></ul></li><li><p><strong>起始地址：<code>0x76ff5da0+0x00c</code></strong></p><ul><li>链表的起始地址</li><li><code>0x76ff5da0</code> 是基地址</li><li><code>+0x00c</code> 是偏移量</li><li>最终地址是：<code>0x76ff5dac</code>(<code>0x76ff5da0 + 0xc</code>)</li></ul></li></ol><p>这个命令会：</p><ol><li>从地址 <code>0x76ff5dac</code> 开始遍历链表</li><li>对链表中每个节点：<ul><li>将节点地址传递给 <code>@$extret</code></li><li>将该地址解释为 <code>_LDR_DATA_TABLE_ENTRY</code> 结构</li><li>显示该结构中的 <code>LoadCount</code> 和 <code>BaseDllName</code> 字段</li></ul></li></ol><blockquote><p><strong>说明：</strong> 以上查看方法只适用于 <code>win7</code> 及以前的系统，从 <code>win8</code> 开始，结构体发生了改变。</p></blockquote><h2 id="win8-及-win10-查看方法"><a href="#win8-及-win10-查看方法" class="headerlink" title="win8 及 win10 查看方法"></a>win8 及 win10 查看方法</h2><p>从 <code>win8</code> 开始，<code>_LDR_DATA_TABLE_ENTRY</code> 结构体发生了变化，引入了 <code>LDR_DDAG_NODE</code> 结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; dt _LDR_DATA_TABLE_ENTRY</span><br><span class="line">ntdll!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> DllBase          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> EntryPoint       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> SizeOfImage      : Uint4B</span><br><span class="line">   +<span class="number">0x024</span> FullDllName      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x02c</span> BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x034</span> FlagGroup        : [<span class="number">4</span>] UChar</span><br><span class="line">   +<span class="number">0x034</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x034</span> PackagedBinary   : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> MarkedForRemoval : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ImageDll         : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> LoadNotificationsSent : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> TelemetryEntryProcessed : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ProcessStaticImport : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> InLegacyLists    : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> InIndexes        : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ShimDll          : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> InExceptionTable : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ReservedFlags1   : Pos <span class="number">10</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x034</span> LoadInProgress   : Pos <span class="number">12</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> LoadConfigProcessed : Pos <span class="number">13</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> EntryProcessed   : Pos <span class="number">14</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ProtectDelayLoad : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ReservedFlags3   : Pos <span class="number">16</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x034</span> DontCallForThreads : Pos <span class="number">18</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ProcessAttachCalled : Pos <span class="number">19</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ProcessAttachFailed : Pos <span class="number">20</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> CorDeferredValidate : Pos <span class="number">21</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> CorImage         : Pos <span class="number">22</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> DontRelocate     : Pos <span class="number">23</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> CorILOnly        : Pos <span class="number">24</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ChpeImage        : Pos <span class="number">25</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ReservedFlags5   : Pos <span class="number">26</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x034</span> Redirected       : Pos <span class="number">28</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x034</span> ReservedFlags6   : Pos <span class="number">29</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x034</span> CompatDatabaseProcessed : Pos <span class="number">31</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x038</span> ObsoleteLoadCount : Uint2B</span><br><span class="line">   +<span class="number">0x03a</span> TlsIndex         : Uint2B</span><br><span class="line">   +<span class="number">0x03c</span> HashLinks        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x044</span> TimeDateStamp    : Uint4B</span><br><span class="line">   +<span class="number">0x048</span> EntryPointActivationContext : Ptr32 _ACTIVATION_CONTEXT</span><br><span class="line">   +<span class="number">0x04c</span> Lock             : Ptr32 Void</span><br><span class="line">   +<span class="number">0x050</span> DdagNode         : Ptr32 _LDR_DDAG_NODE    <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x054</span> NodeModuleLink   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x05c</span> LoadContext      : Ptr32 _LDRP_LOAD_CONTEXT</span><br><span class="line">   +<span class="number">0x060</span> ParentDllBase    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x064</span> SwitchBackContext : Ptr32 Void</span><br><span class="line">   +<span class="number">0x068</span> BaseAddressIndexNode : _RTL_BALANCED_NODE</span><br><span class="line">   +<span class="number">0x074</span> MappingInfoIndexNode : _RTL_BALANCED_NODE</span><br><span class="line">   +<span class="number">0x080</span> OriginalBase     : Uint4B</span><br><span class="line">   +<span class="number">0x088</span> LoadTime         : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x090</span> BaseNameHashValue : Uint4B</span><br><span class="line">   +<span class="number">0x094</span> LoadReason       : _LDR_DLL_LOAD_REASON</span><br><span class="line">   +<span class="number">0x098</span> ImplicitPathOptions : Uint4B</span><br><span class="line">   +<span class="number">0x09c</span> ReferenceCount   : Uint4B</span><br><span class="line">   +<span class="number">0x0a0</span> DependentLoadFlags : Uint4B</span><br><span class="line">   +<span class="number">0x0a4</span> SigningLevel     : UChar</span><br></pre></td></tr></table></figure><p> <code>LDR_DDAG_NODE</code> 结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt ntdll!_LDR_DDAG_NODE</span><br><span class="line">   +<span class="number">0x000</span> Modules          : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x008</span> ServiceTagList   : Ptr32 _LDR_SERVICE_TAG_RECORD</span><br><span class="line">   +<span class="number">0x00c</span> LoadCount        : Uint4B       <span class="comment">// &lt;----</span></span><br><span class="line">   +<span class="number">0x010</span> LoadWhileUnloadingCount : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> LowestLink       : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Dependencies     : _LDRP_CSLIST</span><br><span class="line">   +<span class="number">0x01c</span> IncomingDependencies : _LDRP_CSLIST</span><br><span class="line">   +<span class="number">0x020</span> State            : _LDR_DDAG_STATE</span><br><span class="line">   +<span class="number">0x024</span> CondenseLink     : _SINGLE_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x028</span> PreorderNumber   : Uint4B</span><br></pre></td></tr></table></figure><p>其中的 <code>LoadCount</code> 表示引用计数。</p><h2 id="快捷命令"><a href="#快捷命令" class="headerlink" title="快捷命令"></a>快捷命令</h2><p>按上面的操作步骤，每次查看引用计数都需要执行几次 <code>dt</code> 命令，效率太低，可以通过 <code>dx</code> 命令查看，非常灵活高效。</p><p>在 <code>win7</code> 系统下查看指定 <code>dll</code> 引用计数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dx @$modules = Debugger.Utility.Collections.FromListEntry(@$peb-&gt;Ldr-&gt;InLoadOrderModuleList, &quot;ntdll!_LDR_DATA_TABLE_ENTRY&quot;, &quot;InLoadOrderLinks&quot;)</span><br><span class="line"></span><br><span class="line">dx -r2 @$modules.Select(m =&gt; new &#123; Name = ((wchar_t*)m.BaseDllName.Buffer).ToDisplayString(&quot;su&quot;), Base = m.DllBase, Count = m.LoadCount &#125;).Where(m =&gt; m.Name.ToLower().Contains(&quot;your_dll_name&quot;))</span><br></pre></td></tr></table></figure><p>在 <code>win10</code> 系统下查看指定 <code>dll</code> 引用计数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dx @$modules = Debugger.Utility.Collections.FromListEntry(@$peb-&gt;Ldr-&gt;InLoadOrderModuleList, &quot;ntdll!_LDR_DATA_TABLE_ENTRY&quot;, &quot;InLoadOrderLinks&quot;)</span><br><span class="line"></span><br><span class="line">dx -r2 @$modules.Select(m =&gt; new &#123; Name = ((wchar_t*)m.BaseDllName.Buffer).ToDisplayString(&quot;su&quot;), Base = m.DllBase, Count = m.DdagNode-&gt;LoadCount &#125;).Where(m =&gt; m.Name.ToLower().Contains(&quot;your_dll_name&quot;))</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong> <code>FromListEntry(ListEntry, [&lt;ModuleName | ModuleObject&gt;], TypeName, FieldExpression)</code></p><p>第一个参数是链表地址，第二个参数可省略，第三个参数是链表节点类型，第四个参数是节点类型中指向下一个节点的成员名。以下输出是 <code>dx Debugger.Utility.Collections.FromListEntry</code> 给出的说明。</p><p><code>Debugger.Utility.Collections.FromListEntry [FromListEntry(ListEntry, [&lt;ModuleName | ModuleObject&gt;], TypeName, FieldExpression) - Method which converts a LIST_ENTRY specified by the &#39;ListEntry&#39; parameter of types whose name is specified by the string &#39;TypeName&#39; and whose embedded links within that type are accessed via an expression specified by the string &#39;FieldExpression&#39; into a collection object.  If an optional module name or object is specified, the type name is looked up in the context of such module]</code></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>可以使用 <code>!exts.dlls</code> 扩展命令查看所有 <code>dll</code> 的引用计数。<code>!exts.dlls -c addr</code> 可以查看指定 <code>dll</code> 的引用计数。</li><li>可以手动查看，需要解析 <code>_LDR_DATA_TABLE_ENTRY</code> 结构。</li><li><code>dx</code> 命令非常灵活，可以方便的查看 <code>dll</code> 的引用计数。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.securityxploded.com/dllrefcount.php" target="_blank" rel="noopener">https://www.securityxploded.com/dllrefcount.php</a></p><p><a href="https://stackoverflow.com/questions/3553231/how-to-check-dlls-reference-count-how-to-know-where-the-dll-was-loaded" target="_blank" rel="noopener">https://stackoverflow.com/questions/3553231/how-to-check-dlls-reference-count-how-to-know-where-the-dll-was-loaded</a></p><p><a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntldr/ldr_data_table_entry.htm" target="_blank" rel="noopener">https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntldr/ldr_data_table_entry.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有两种常用的方式可以查看 &lt;code&gt;dll&lt;/code&gt; 的引用计数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;windbg&lt;/code&gt; 中通过 &lt;code&gt;!dlls&lt;/code&gt; 命令查看 &lt;code&gt;dll&lt;/code&gt; 的引用计数。&lt;code&gt;!dlls&lt;/code&gt; 输出结果中包含 &lt;code&gt;LoadCount&lt;/code&gt; 字段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 不同版本的 &lt;code&gt;windbg&lt;/code&gt; 使用的 &lt;code&gt;!exts.dlls&lt;/code&gt; 命令解析方式不同，低版本的 &lt;code&gt;windbg&lt;/code&gt; 在解析 &lt;code&gt;win10&lt;/code&gt; 上运行程序的 &lt;code&gt;dll&lt;/code&gt; 引用计数，解析结果很可能是错的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;手动解析 &lt;code&gt;PEB&lt;/code&gt; 中的 &lt;code&gt;PEB_LDR_DATA&lt;/code&gt; 中的模块加载列表数据查看 &lt;code&gt;dll&lt;/code&gt; 的引用计数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Win7&lt;/code&gt; 及之前系统：&lt;br&gt;找到 &lt;code&gt;PEB&lt;/code&gt; 中的 &lt;code&gt;PEB_LDR_DATA&lt;/code&gt; (&lt;code&gt;Ldr&lt;/code&gt; 字段)，遍历其 &lt;code&gt;InLoadOrderModuleList&lt;/code&gt; 链表。链表项为 &lt;code&gt;_LDR_DATA_TABLE_ENTRY&lt;/code&gt; 结构，其中的 &lt;code&gt;LoadCount&lt;/code&gt; 字段即为引用计数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Win8&lt;/code&gt; 及之后系统：&lt;br&gt;结构发生变化，需在 &lt;code&gt;_LDR_DATA_TABLE_ENTRY&lt;/code&gt; 中找到 &lt;code&gt;DdagNode&lt;/code&gt; 字段（它是一个指向 &lt;code&gt;_LDR_DDAG_NODE&lt;/code&gt; 的指针），该结构中的 &lt;code&gt;LoadCount&lt;/code&gt; 字段为当前引用计数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="引用计数" scheme="https://bianchengnan.github.io/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    
      <category term="LoadCount" scheme="https://bianchengnan.github.io/tags/LoadCount/"/>
    
  </entry>
  
  <entry>
    <title>排错实战 | 使用 chkmatch 和 procmon 速解 MFC 调试符号加载失败</title>
    <link href="https://bianchengnan.github.io//articles/troubleshoot-mfc-pdb-mismatch-by-chkmatch-and-procmon/"/>
    <id>https://bianchengnan.github.io//articles/troubleshoot-mfc-pdb-mismatch-by-chkmatch-and-procmon/</id>
    <published>2025-12-14T11:11:33.000Z</published>
    <updated>2026-02-16T10:40:27.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>最近在调试的时候想查看 <code>mfc140u.dll</code> 中的函数，发现对应的调试符号没有加载，手动加载了几次都是失败。再三确认调试符号确实存在，而且设置的符号路径都对。难道又是调试符号不匹配？于是打算用 <code>chkmatch</code> 确认一下是否匹配。</p><p>最后，发现是调试符号放到了 <code>system32</code> 路径下，<code>chkmatch</code> 是 <code>32</code> 位程序，会自动到 <code>sysWOW64</code> 目录下找。本文简单记录了使用 <code>procmon</code> 快速排查定位，最后使用 <code>chkmatch -c</code> 使调试符号与 <code>mfc140u.dll</code> 强制匹配的过程。  </p><a id="more"></a><h2 id="初遇问题"><a href="#初遇问题" class="headerlink" title="初遇问题"></a>初遇问题</h2><p>今天调试的时候，又是找不到 <code>mfc140u.dll</code> 的符号，如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-mfc-pdb-mismatch-by-chkmatch-and-procmon/mfc140u.pdb-not-loaded-error.png" alt="mfc140u.pdb-not-loaded-error"></p><p>但是有一个很重要的逻辑需要查看该模块中的代码。于是手动加载了几次，再三确认了调试符号确实存在，而且符号路径设置的确实正确。很有可能是符号不匹配导致的。于是想着用 <code>chkmatch</code> 检查一下。</p><h2 id="chkmatch-报错"><a href="#chkmatch-报错" class="headerlink" title="chkmatch 报错"></a>chkmatch 报错</h2><p>没想到，运行 <code>chkmatch</code> 的时候却报找不到调试符号。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-mfc-pdb-mismatch-by-chkmatch-and-procmon/chkmatch-cannot-find-pdb-file.png" alt="chkmatch-cannot-find-pdb-file"></p><p>明明 <code>mfc140u.amd64.pdb</code> 就在 <code>c:\windows\system32</code> 目录下，但 <code>chkmatch</code> 为什么却找不到呢？看来需要请 <code>procmon</code> 出马了。</p><h2 id="procmon-出马"><a href="#procmon-出马" class="headerlink" title="procmon 出马"></a>procmon 出马</h2><p>运行 <code>procmon</code>，然后执行 <code>chkmatch</code>，执行完成后，停止采集。根据进程名过滤后，只保留文件读写操作。很快就看到了关键的事件。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-mfc-pdb-mismatch-by-chkmatch-and-procmon/procmon-view-key-event.png" alt="procmon-view-key-event"></p><p>从 <code>Path</code> 一列，可以清楚的知道，<code>chkmatch</code> 访问的是 <code>c:\windows\sysWOW64\mfc140u.amd64.pdb</code>，而不是 <code>c:\windows\system32\mfc140u.amd64.pdb</code>。</p><p>看到这里，我恍然大悟，在 <code>64</code> 位系统下运行的 <code>32</code> 位进程访问注册表和文件路径时会发生重定向。</p><h2 id="强制匹配"><a href="#强制匹配" class="headerlink" title="强制匹配"></a>强制匹配</h2><p>把 <code>mfc140u.amd64.pdb</code> 拷贝到其它路径下，然后再次执行检查操作，发现确实是调试符号不匹配导致的 <code>mfc140u.dll</code> 加载符号失败。</p><p><code>chkmatch</code> 不仅可以检查调试符号是否匹配，还可以修改调试符号的关键信息，使其与对应的模块文件强制匹配。只需要把 <code>-c</code> 选项换成 <code>-m</code> 选项即可。把修改后的调试符号放到 <code>d:\share\dll-pdbs\</code> 路径下，并在 <code>vs</code> 中设置好调试符号路径，然后右键，重新加载调试符号，这次可以看到期盼已久的函数名及对应的源码了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>procmon</code> 是监控各种操作的神器</p><p><code>chkmatch</code> 不仅可以检查调试符号是否匹配，还可修改调试符号信息使其匹配</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;最近在调试的时候想查看 &lt;code&gt;mfc140u.dll&lt;/code&gt; 中的函数，发现对应的调试符号没有加载，手动加载了几次都是失败。再三确认调试符号确实存在，而且设置的符号路径都对。难道又是调试符号不匹配？于是打算用 &lt;code&gt;chkmatch&lt;/code&gt; 确认一下是否匹配。&lt;/p&gt;
&lt;p&gt;最后，发现是调试符号放到了 &lt;code&gt;system32&lt;/code&gt; 路径下，&lt;code&gt;chkmatch&lt;/code&gt; 是 &lt;code&gt;32&lt;/code&gt; 位程序，会自动到 &lt;code&gt;sysWOW64&lt;/code&gt; 目录下找。本文简单记录了使用 &lt;code&gt;procmon&lt;/code&gt; 快速排查定位，最后使用 &lt;code&gt;chkmatch -c&lt;/code&gt; 使调试符号与 &lt;code&gt;mfc140u.dll&lt;/code&gt; 强制匹配的过程。  &lt;/p&gt;
    
    </summary>
    
      <category term="排错" scheme="https://bianchengnan.github.io/categories/%E6%8E%92%E9%94%99/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工具" scheme="https://bianchengnan.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="pdb" scheme="https://bianchengnan.github.io/tags/pdb/"/>
    
      <category term="procmon" scheme="https://bianchengnan.github.io/tags/procmon/"/>
    
      <category term="chkmatch" scheme="https://bianchengnan.github.io/tags/chkmatch/"/>
    
      <category term="调试符号" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何关闭 ASLR</title>
    <link href="https://bianchengnan.github.io//articles/how-to-disable-ASLR/"/>
    <id>https://bianchengnan.github.io//articles/how-to-disable-ASLR/</id>
    <published>2025-12-13T11:50:01.000Z</published>
    <updated>2026-02-16T10:40:27.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>写文章的时候经常需要截图，有时候截完图程序就关了，但是发现还有另外一个地方需要截图说明。再次启动程序的时候，模块加载位置变了，与原来的截图的内容不匹配了，又要重新截图。为了解决这个问题特意查了一下如何禁用地址空间随机化。有两种方法：一种是全局禁用，一种是针对某个程序禁用。这里做个记录，方便后续查询。</p><a id="more"></a><h2 id="禁用方法"><a href="#禁用方法" class="headerlink" title="禁用方法"></a>禁用方法</h2><p><code>设置</code> -&gt; <code>更新和安全</code> -&gt; <code>windows 安全中心</code> -&gt; <code>应用和浏览器控制</code> -&gt; <code>Exploit Protection</code>，点击 <code>Exploit Protection 设置</code> 按钮进入设置界面。</p><blockquote><p><strong>说明：</strong> 也可以直接按 <code>windows</code> 键，然后输入 <code>windows 安全中心</code> 进入 <code>windows 安全中心</code></p></blockquote><h3 id="全局禁用"><a href="#全局禁用" class="headerlink" title="全局禁用"></a>全局禁用</h3><p>在 <code>系统设置</code> 页下，关闭 <code>高熵 ASLR</code> 和 <code>随机化内存分配(自下而上 ASLR)</code>，确保 <code>强制影像随机化(强制性 ASLR)</code> 是关闭的（默认是关闭的）。修改后<strong>重启生效</strong>。</p><p><img src="http://resources.bianchengnan.tech/how-to-disable-ASLR/disable-aslr-system.png" alt="disable-aslr-system"></p><p>使用 <code>Procmon</code> 观察可以发现，对应的注册表项是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\kernel]</span><br><span class="line">"MitigationOptions"=hex:00,02,22,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"MitigationAuditOptions"=hex:00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"EAFModules"=""</span><br></pre></td></tr></table></figure><h3 id="针对某个程序禁用"><a href="#针对某个程序禁用" class="headerlink" title="针对某个程序禁用"></a>针对某个程序禁用</h3><p>在 <code>程序设置</code> 页下，可以添加或修改指定程序的设置。既可以按程序名称进行设置，也可以按照全路径进行设置。</p><p>勾选 <code>强制映像随机化(强制性 ASLR)</code> 和 <code>随机化内存分配(自下而上 ASLR)</code> 选项下的 <code>替代系统设置</code>，并且确保下方的开关是关闭的（默认是关闭的）。重启应用程序后生效。如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-disable-ASLR/disable-aslr-per-exe.png" alt="disable-aslr-per-exe"></p><p>使用 <code>Procmon</code> 观察可以发现，最终设置的是 <code>Image File Execution Options</code> 注册表项。</p><p>按照程序名称进行配置的注册表项如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LoadDlls.exe]</span><br><span class="line">"MitigationOptions"=hex:00,02,22,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"MitigationAuditOptions"=hex:00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"EAFModules"=""</span><br></pre></td></tr></table></figure><p>按照完整路径进行配置的注册表项如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LoadDlls1.exe]</span><br><span class="line">"UseFilter"=dword:00000001</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LoadDlls1.exe\&#123;aec33db5-c793-77a9-0b18-88d2ce11206b&#125;]</span><br><span class="line">"FilterFullPath"="D:\\MyBlogStuff\\LoadDlls\\x64\\Debug\\LoadDlls1.exe"</span><br><span class="line">"MitigationOptions"=hex:00,02,22,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"MitigationAuditOptions"=hex:00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00</span><br><span class="line">"EAFModules"=""</span><br></pre></td></tr></table></figure><h2 id="修改-PE-文件"><a href="#修改-PE-文件" class="headerlink" title="修改 PE 文件"></a>修改 PE 文件</h2><p>除了修改系统设置外，还可以通过禁用 <code>PE</code> 文件头中的标志位来禁用 <code>ASLR</code>。有两种方式：</p><ol><li><p>如果有程序源码，可以修改 <code>vs</code> 中的工程设置来设置生成的 <code>PE</code> 文件头的标志位。</p><p><code>右键</code> -&gt; <code>属性</code> -&gt; <code>链接器</code> -&gt; <code>高级</code> -&gt; <code>随机地址</code> 选择 <code>否 (/DYNAMICBASE:NO)</code>，如下图：<img src="http://resources.bianchengnan.tech/how-to-disable-ASLR/disable-aslr-in-vs-project.png" alt="disable-aslr-in-vs-project"></p><p>这样编译生成的 <code>PE</code> 文件就不会包含重定位标志。</p><blockquote><p><strong>说明：</strong> 如果 <code>固定基址</code> 设置的值是 <code>是 (/FIXED)</code>，那么 <code>PE</code> 文件的 <code>IMAGE_FILE_HEADER.Characteristics</code> 的第 <code>0</code> 位（<code>IMAGE_FILE_RELOCS_STRIPPED</code> 位）的值是 <code>0</code>，并且生成的 <code>PE</code> 文件中不存在重定位信息（<code>Relocation info stripped</code>）。重定位模块可能会失败。</p></blockquote></li></ol><ol start="2"><li><p>如果程序已经生成，可以通过修改 <code>PE</code> 文件头来禁用 <code>ASLR</code></p><p>可以修改 <code>PE</code> 文件中 <code>IMAGE_OPTIONAL_HEADER32.DllCharacteristics</code> 中的第 <code>6</code> 位（从 <code>0</code> 开始）,也即 <code>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</code> 位的值，如果置 <code>1</code> 表示可以在加载时被重定位。</p><p><img src="http://resources.bianchengnan.tech/how-to-disable-ASLR/disable-aslr-by-NtHeaders-OptionalHeader-DllCharacteristics.png" alt="disable-aslr-by-NtHeaders-OptionalHeader-DllCharacteristics"></p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Windows PE 权威指南》</p><p><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=msvc-170" target="_blank" rel="noopener">https://learn.microsoft.com/zh-cn/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=msvc-170</a></p><p><a href="https://blog.csdn.net/meanong/article/details/80018392" target="_blank" rel="noopener">https://blog.csdn.net/meanong/article/details/80018392</a></p><p><a href="https://www.52pojie.cn/thread-1099755-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1099755-1-1.html</a></p><p><a href="https://blog.nsfocus.net/dynamorio-9/" target="_blank" rel="noopener">https://blog.nsfocus.net/dynamorio-9/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;写文章的时候经常需要截图，有时候截完图程序就关了，但是发现还有另外一个地方需要截图说明。再次启动程序的时候，模块加载位置变了，与原来的截图的内容不匹配了，又要重新截图。为了解决这个问题特意查了一下如何禁用地址空间随机化。有两种方法：一种是全局禁用，一种是针对某个程序禁用。这里做个记录，方便后续查询。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="windows" scheme="https://bianchengnan.github.io/tags/windows/"/>
    
      <category term="ASLR" scheme="https://bianchengnan.github.io/tags/ASLR/"/>
    
      <category term="PE" scheme="https://bianchengnan.github.io/tags/PE/"/>
    
      <category term="procmon" scheme="https://bianchengnan.github.io/tags/procmon/"/>
    
      <category term="注册表" scheme="https://bianchengnan.github.io/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MFC对话框的“双胞胎”控件：隐藏了一个，还有一个在看我</title>
    <link href="https://bianchengnan.github.io//articles/two-interesting-mfc-dialog-bugs/"/>
    <id>https://bianchengnan.github.io//articles/two-interesting-mfc-dialog-bugs/</id>
    <published>2025-12-13T07:30:22.000Z</published>
    <updated>2026-02-16T10:40:27.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前段日子，遇到两个非常有意思的 <code>MFC</code> 对话框相关的 <code>bug</code>：</p><ol><li>为 <code>ComboBox</code> 控件设置了文本，但是却显示为空</li><li>明明已经隐藏了控件，但是控件却没有隐藏</li></ol><p>最后发现这两个问题是同一个问题，对话框中存在相同 <code>ID</code> 的控件。因为这两个问题是同一个问题，本文只介绍其中一个问题的排查思路。</p><a id="more"></a><blockquote><p><strong>说明：</strong> 实际项目中的情况要复杂的多，本文用到的例子都是我准备的示例程序</p></blockquote><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>程序会在某些情况下显式/隐藏某些特定控件，但是却发现对应的控件没有被隐藏，如下图：</p><p><img src="http://resources.bianchengnan.tech/two-interesting-mfc-dialog-bugs/can-not-hide-control.gif" alt="can-not-hide-control"></p><p>对应的控制代码也非常简单，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CString strTitle;</span><br><span class="line">GetDlgItem(IDC_BTN_SHOW_HIDE)-&gt;GetWindowTextW(strTitle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> showStatus = (strTitle == <span class="string">L"Show"</span>) ? SW_SHOW : SW_HIDE;</span><br><span class="line">GetDlgItem(IDC_EDIT_TEXT)-&gt;ShowWindow(showStatus);</span><br><span class="line">  </span><br><span class="line">strTitle = (strTitle == <span class="string">L"Show"</span>) ? <span class="string">L"Hide"</span> : <span class="string">L"Show"</span>;</span><br><span class="line">GetDlgItem(IDC_BTN_SHOW_HIDE)-&gt;SetWindowTextW(strTitle);</span><br></pre></td></tr></table></figure><p>反复确认代码逻辑，没有问题。那会是什么原因呢？<code>GetDlgItem()</code> 获取的控件不对？还是调用 <code>ShowWindow()</code> 失败了？还是其它什么原因？</p><h2 id="深入调查"><a href="#深入调查" class="headerlink" title="深入调查"></a>深入调查</h2><p>通过查看 <code>ShowWindow()</code> 的返回值，发现对 <code>ShowWindow()</code> 的调用是成功的。<code>GetDlgItem()</code> 获取的控件句柄是 <code>0x00020a7c</code>，</p><p><img src="http://resources.bianchengnan.tech/two-interesting-mfc-dialog-bugs/search-target-window.png" alt="search-target-window"></p><p>通过 <code>spyxx</code> 的窗口搜索功能，在 <code>句柄（A）：</code> 对应的位置输入 <code>0x00020a7c</code>，可以发现控件确实已经被隐藏了。</p><p>那么显示着的控件又是哪一个呢？再用 <code>spyxx</code> 的窗口搜索功能，拖动靶心到对应的窗口上，可以发现控件句柄是 <code>00060a5e</code>，在对应的列表项上右键，突出显式，可以确认显示着的控件句柄确实是 <code>0x00060a5e</code>。</p><p><img src="http://resources.bianchengnan.tech/two-interesting-mfc-dialog-bugs/highlight-visible-control.gif" alt="highlight-visible-control"></p><p>难道同一个位置有两个一模一样的控件？赶紧查看一下 <code>rc</code> 文件。</p><h2 id="查看-rc"><a href="#查看-rc" class="headerlink" title="查看 rc"></a>查看 rc</h2><p>果然，在 <code>rc</code> 文件中有重复的控件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IDD_REPEATCONTROLID_DIALOG DIALOGEX <span class="number">0</span>, <span class="number">0</span>, <span class="number">272</span>, <span class="number">110</span></span><br><span class="line">STYLE DS_SETFONT | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME</span><br><span class="line">EXSTYLE WS_EX_APPWINDOW</span><br><span class="line">CAPTION <span class="string">"RepeatControlId"</span></span><br><span class="line">FONT <span class="number">8</span>, <span class="string">"MS Shell Dlg"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x1</span></span><br><span class="line">BEGIN</span><br><span class="line">    DEFPUSHBUTTON   <span class="string">"退出"</span>,IDOK,<span class="number">215</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">14</span></span><br><span class="line">    EDITTEXT        IDC_EDIT_TEXT,<span class="number">89</span>,<span class="number">7</span>,<span class="number">176</span>,<span class="number">15</span>,ES_AUTOHSCROLL <span class="comment">//&lt;----</span></span><br><span class="line">    EDITTEXT        IDC_EDIT_TEXT,<span class="number">89</span>,<span class="number">7</span>,<span class="number">176</span>,<span class="number">15</span>,ES_AUTOHSCROLL</span><br><span class="line">    PUSHBUTTON      <span class="string">"Hide"</span>,IDC_BTN_SHOW_HIDE,<span class="number">7</span>,<span class="number">7</span>,<span class="number">73</span>,<span class="number">15</span></span><br><span class="line">    LTEXT           <span class="string">"点击按钮会隐藏右侧文本框，..."</span>,IDC_STATIC,<span class="number">7</span>,<span class="number">26</span>,<span class="number">258</span>,<span class="number">59</span></span><br><span class="line">END</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong> 实际项目中，对话框中的控件数量超级多，不像示例程序这么明显，一眼就能看出来有重复控件</p></blockquote><p>至此，可以结案了，因为 <code>rc</code> 中有重复的控件，所以导致在隐藏控件时，只隐藏了一个。另外一个 <code>bug</code> 也是同样的问题，不再赘述。</p><h2 id="警示"><a href="#警示" class="headerlink" title="警示"></a>警示</h2><p>按理说，同一个对话框中存在相同 <code>ID</code> 的控件，编译的时候至少会报警告。重新编译程序，观察编译警告，果然发现有提示：</p><p><code>1&gt;RepeatControlId.rc(106): warning RC2182: duplicate dialog control ID 1000</code></p><p>一定要注意编译器的警告啊！</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>示例程序代码已经上传到了<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/two-interesting-mfc-dialog-bugs/RepeatControlId" target="_blank" rel="noopener">github</a>，感兴趣的朋友可以下载体验。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>同一个对话框中不要存在有相同 <code>ID</code> 的控件</p></li><li><p><code>spyxx</code> 是查看窗口句柄的好工具，一定要善加利用</p></li><li><p>务必注意编译器的警告信息！</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前段日子，遇到两个非常有意思的 &lt;code&gt;MFC&lt;/code&gt; 对话框相关的 &lt;code&gt;bug&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为 &lt;code&gt;ComboBox&lt;/code&gt; 控件设置了文本，但是却显示为空&lt;/li&gt;
&lt;li&gt;明明已经隐藏了控件，但是控件却没有隐藏&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后发现这两个问题是同一个问题，对话框中存在相同 &lt;code&gt;ID&lt;/code&gt; 的控件。因为这两个问题是同一个问题，本文只介绍其中一个问题的排查思路。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="mfc" scheme="https://bianchengnan.github.io/tags/mfc/"/>
    
  </entry>
  
  <entry>
    <title>内存都去哪了？探究 VirtualAlloc 分配背后被“浪费”的 60KB</title>
    <link href="https://bianchengnan.github.io//articles/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/"/>
    <id>https://bianchengnan.github.io//articles/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/</id>
    <published>2025-12-06T13:43:53.000Z</published>
    <updated>2026-02-16T10:40:27.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录了一次因  <code>VirtualAlloc</code> 分配失败引发的 <code>OOM</code> 问题排查过程。通过编写测试程序模拟内存分配，发现 <code>32</code> 位进程在未开启 <code>Large Address Aware</code> 时，用户空间仅 <code>2GB</code> 可用，且 <code>VirtualAlloc</code> 实际分配粒度均为 <strong>64KB</strong>——若申请 <code>4KB</code>，剩余 <code>60KB</code> 将变为不可用空间，导致地址空间碎片化与大量浪费。借助 <code>VMMap</code> 碎片视图与 <code>Windbg</code> 分析，直观展示了分配粒度对内存布局的影响，并验证了按 <code>64KB</code> 对齐分配可避免该问题。</p><a id="more"></a><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>测试代码非常简单，我就直接贴到这里了，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nk = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usage: TestVirtualAlloc.exe N(kb). default 4kb"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    nk = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pAddr = VirtualAlloc(<span class="literal">nullptr</span>, nk * <span class="number">1024</span>, MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">        <span class="keyword">if</span> (pAddr == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"VirtualAlloc(%dkb) loop %6d failed. last error 0n%d\r\n"</span>, nk, idx++, GetLastError());</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"VirtualAlloc(%dkb) loop %6d succeed. address 0x%08x\r\n"</span>, nk, idx++, pAddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Free-空间出乎意料的大"><a href="#Free-空间出乎意料的大" class="headerlink" title="Free 空间出乎意料的大"></a>Free 空间出乎意料的大</h2><p>编译 <code>32</code> 位版本的程序，执行 <code>TestVirtualAlloc.exe 4</code>（每次分配 <code>4kb</code>），执行一段时间后，最终会失败，如下图：</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/virtual-alloc-failed.png" alt="virtual-alloc-failed"></p><p>这是预料内的现象，因为程序在不停的分配空间，<code>32</code> 位进程的虚拟地址空间仅有 <code>4GB</code>，在未开启 <code>Large Address Aware</code> 的情况下，用户程序可用的空间仅有 <code>2GB</code> 空间可用。</p><p>用 <code>windbg</code> 附加到该进程，执行 <code>!address -summary</code> 查看地址空间情况，发现 <code>Free</code> 占比有点太大了（<code>88.90%</code>），这不符合预期。程序在不停的分配空间，虽然没有 <code>commit</code>，但是已经 <code>reserve</code> 了，不应该有这么多 <code>Free</code> 空间才对。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/address-summary.png" alt="address-summary"></p><p><code>VMMap</code> 是查看虚拟内存空间的神器，可以非常详细的查看某个进程的内存空间布局。何不用 <code>VMMap</code> 查看一下？</p><h2 id="请出-VMMap"><a href="#请出-VMMap" class="headerlink" title="请出 VMMap"></a>请出 VMMap</h2><p>打开 <code>VMMap</code> 并选择 <code>TestVirtualAlloc.exe</code>，查看其虚拟内存空间。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/vmmap-view-memory.png" alt="vmmap-view-memory"></p><blockquote><p><strong>说明：</strong>切记勾选 <code>Options</code> 选项下的 <code>Show Free and Unsuable Regions</code></p></blockquote><p>当我看到 <code>60 K</code> 的 <code>Unusable</code> 跟在 <code>4 K</code> 的 <code>Private Data</code> 后时，沉睡的记忆终于被唤醒了，<code>VirtualAlloc</code> 的分配粒度是 <code>64kb</code> ！！！</p><p>在 <code>windbg</code> 中使用 <code>!address</code> 命令查看地址 <code>0x00490000</code> 和 <code>0x00491000</code> 的情况，如下图：</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/windbg-address-490000-491000.png" alt="windbg-address-490000-491000"></p><p>地址 <code>0x00491000</code> 所属的区域是 <code>MEM_FREE</code> 的。需要注意的是虽然从 <code>0x00491000</code> 开始的 <code>60kb</code> 是 <code>Free</code> 的，但是这块地址不能被分配使用了，这就是为什么 <code>VMMap</code> 中显示为 <code>Unusable</code> 的原因。</p><p>如果我分配的是 <code>64kb</code>，那么就不会有这么大的 <code>Free</code> 空间了。是不是呢？简单验证一下就知道了。</p><h2 id="继续验证"><a href="#继续验证" class="headerlink" title="继续验证"></a>继续验证</h2><p>执行 <code>TestVirtualAlloc.exe 64</code>（每次会分配 <code>64kb</code>），然后使用 <code>windbg</code> 观察内存空间的情况。</p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/address-summary-no-much-free-memory.png" alt="address-summary-no-much-free-memory"><p>可以发现 <code>MEM_FREE</code> 类型的内存空间很小了，基本上全是 <code>MEM_RESERVE</code> 类型的内存空间。使用 <code>VMMap</code> 查看的话，也差不多，这里就不截图了。感兴趣的小伙伴可以自己动手实验。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>折腾完，我突然意识到一个致命问题 —— 我的系统是 <code>64</code> 位的啊。<code>32</code> 位程序在 <code>64</code> 位操作系统下，用户态内存空间应该是 <code>4GB</code> 才对，这里为啥才 <code>2GB</code> 呢？想必聪明的你也一定知道其中的缘由了，想要使用 <code>4GB</code> 的内存空间，必须开启 <code>Large Address Aware</code> 才行。</p><p>经过确认，编译程序的时候，默认是没开启这个选项的。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/enable-large-address-aware.png" alt="enable-large-address-aware"></p><p>开启后，再次执行程序，可以发现可分配的内存地址是大于 <code>2gb</code> 的，接近 <code>4gb</code>。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/allocate-at-address-higher-than-2gb.png" alt="allocate-at-address-higher-than-2gb"></p><h2 id="Fragmentation-View"><a href="#Fragmentation-View" class="headerlink" title="Fragmentation View"></a>Fragmentation View</h2><p>其实，<code>VMMap</code> 还有一个非常强悍的功能，叫 <code>Fragmentation View</code>。此功能可以鸟瞰进程的整个内存空间，也可以放大到对应的区域查看，点击对应区域还可以查看具体的地址范围。从下图可以很明显的看到每次分配 <code>4kb</code> 的内存分布模式 —— <code>4kb</code> 的 <code>reserve</code> 空间（黄色方块）后跟着 <code>60kb</code> 的 <code>Unusable</code> 空间（灰色区域）。</p><p><img src="http://resources.bianchengnan.tech/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/vmmap-fragment-view.png" alt="vmmap-fragment-view"></p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>我已经把对应的示例代码上传到了 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/test-virtual-alloc-and-dont-forget-64k-allocation-granularity/TestVirtualAlloc" target="_blank" rel="noopener">github</a>，感兴趣的小伙伴可以自行实验。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>VMMap</code> 是查看虚拟内存空间的神兵利器</li><li><code>VirtualAlloc</code> 分配粒度是 <code>64kb</code>，如果分配的过小，会产生浪费，甚至是内存碎片</li><li>开启 <code>Large Address Aware</code> 后，<code>32</code> 位程序才能使用更大的内存空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录了一次因  &lt;code&gt;VirtualAlloc&lt;/code&gt; 分配失败引发的 &lt;code&gt;OOM&lt;/code&gt; 问题排查过程。通过编写测试程序模拟内存分配，发现 &lt;code&gt;32&lt;/code&gt; 位进程在未开启 &lt;code&gt;Large Address Aware&lt;/code&gt; 时，用户空间仅 &lt;code&gt;2GB&lt;/code&gt; 可用，且 &lt;code&gt;VirtualAlloc&lt;/code&gt; 实际分配粒度均为 &lt;strong&gt;64KB&lt;/strong&gt;——若申请 &lt;code&gt;4KB&lt;/code&gt;，剩余 &lt;code&gt;60KB&lt;/code&gt; 将变为不可用空间，导致地址空间碎片化与大量浪费。借助 &lt;code&gt;VMMap&lt;/code&gt; 碎片视图与 &lt;code&gt;Windbg&lt;/code&gt; 分析，直观展示了分配粒度对内存布局的影响，并验证了按 &lt;code&gt;64KB&lt;/code&gt; 对齐分配可避免该问题。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="vmmap" scheme="https://bianchengnan.github.io/tags/vmmap/"/>
    
  </entry>
  
  <entry>
    <title>排错实战 | 当编译器&quot;吃掉&quot;函数声明：一次由宏冲突引发的离奇编译错误</title>
    <link href="https://bianchengnan.github.io//articles/troubleshoot-another-compile-error/"/>
    <id>https://bianchengnan.github.io//articles/troubleshoot-another-compile-error/</id>
    <published>2025-12-06T13:43:53.000Z</published>
    <updated>2026-02-16T10:40:27.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在编译 <code>.NET Runtime</code> 源码研究 <code>GC</code> 机制时，我遇到了一个离奇的编译错误：函数 <code>__asan_handle_no_return</code> 的声明被编译器报错为”类函数宏的调用”。通过将源文件预处理输出到中间文件，我发现这个函数声明竟然变成了 <code>void ;</code>——它被”吃掉”了！追踪发现，在 <code>utils.h</code> 中定义了一个同名宏，当 <code>__SANITIZE_ADDRESS__</code> 宏未定义时，该宏被展开为空，导致函数声明被意外删除。这个案例再次证明：<strong>宏命名冲突是编译错误的常见陷阱</strong>，而<strong>预处理输出文件</strong>是诊断这类问题的利器。同时，<code>FileLocator</code> 这类文件搜索工具在源码分析中不可或缺。</p><a id="more"></a><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>从 <a href="https://github.com/dotnet/runtime" target="_blank" rel="noopener">https://github.com/dotnet/runtime</a> 下载源代码到本地，打开 <code>powershell</code> 执行 <code>.\build.cmd -vs coreclr.sln -a x64 -c Debug</code>，一切顺利的话会生成对应的 <code>sln</code> 文件。打开 <code>sln</code> 文件，重新生成解决方案，就遇到了下面的错误。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/compile-error.png" alt="compile-error"></p><p>从图中看，这就是一个很简单的函数声明啊，这还能出错？如果仔细看提示，<code>类函数宏的调用</code>。可以猜想这个错误跟宏有关系。难道又是一个宏冲突导致的问题？不管怎么样，还是老一套，把对应的源文件输出到中间文件，可以参考<a href="https://bianchengnan.github.io/articles/troubleshoot-vs-compile-error-C2589-illegal-token-on-right-side-of/">之前的文章</a>。</p><h2 id="初步调查"><a href="#初步调查" class="headerlink" title="初步调查"></a>初步调查</h2><p>错误工程是 <code>minipal_sanitizer_support</code>，出错的源文件是 <code>sansupport.c</code>。把 <code>sansupport.c</code> 经过预处理的文件输出到中间文件中，设置如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/preprocess-to-file-and-keep-comments.png" alt="preprocess-to-file-and-keep-comments"></p><p>设置好后，在 <code>sansupport.c</code> 上右键，编译，编译完成后，会生成一个名为 <code>sansupport.i</code> 的中间文件，打开此文件，并搜索 <code>__asan_handle_no_return</code>，仅发现了一条无关紧要的记录（在注释中出现），如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/search-keyword-and-find-one-useless.png" alt="search-keyword-and-find-one-useless"></p><p>呦吼，直接消失了？有点意思，搜索一下它上面的函数 <code>__asan_addr_is_in_fake_stack</code>。搜到了，而且有了意外收获 —— 目标函数变成了 <code>void ;</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/search-previous-function-and-find-target-function-missing.png" alt="search-previous-function-and-find-target-function-missing"></p><p>至此，已经可以基本确定是宏导致的了，在某处一定有一个与目标函数重名的宏，接下来该怎么办呢？还是搜。</p><h2 id="找出真凶"><a href="#找出真凶" class="headerlink" title="找出真凶"></a>找出真凶</h2><p>清楚 <code>FileLocator</code> 在下载的 <code>.net runtime</code> 源码目录下搜 <code>__asan_handle_no_return</code>，发现在 <code>utils.h</code> 中定义了这个宏。打开 <code>utils.h</code> 查看，果然发现 <code>146</code> 行的宏定义，如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/macro-defined-in-utils-h.png" alt="macro-defined-in-utils-h"></p><p>根据此处的逻辑可知，应该是 <code>126</code> 行的宏（<code>HAS_ADDRESS_SANITIZER</code>）没定义，导致了这个错误。而 <code>126</code> 行用到的宏又是由 <code>91~107</code> 行的宏定义决定的。如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-another-compile-error/macro-HAS_ADDRESS_SANITIZER-definition.png" alt="macro-HAS_ADDRESS_SANITIZER-definition"></p><p>显然是没定义 <code>__SANITIZE_ADDRESS__</code> 宏导致的。知道原因了，简单粗暴的加上一句 <code>#define __SANITIZE_ADDRESS__</code>，再次编译，果然顺利通过了。</p><p>至于为什么编译失败，我就不关心了。因为我有更感兴趣的事情要处理 —— 查看 <code>gc</code> 相关的逻辑。本篇总结就水到这里啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>遇到奇怪的编译错误不要慌，秘密武器就是输出到中间文件，查看编译器眼中的文件到底长什么样</li><li>一定要有自己顺手的一套工具，搜索文件内容强烈推荐 <code>FileLocator</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在编译 &lt;code&gt;.NET Runtime&lt;/code&gt; 源码研究 &lt;code&gt;GC&lt;/code&gt; 机制时，我遇到了一个离奇的编译错误：函数 &lt;code&gt;__asan_handle_no_return&lt;/code&gt; 的声明被编译器报错为”类函数宏的调用”。通过将源文件预处理输出到中间文件，我发现这个函数声明竟然变成了 &lt;code&gt;void ;&lt;/code&gt;——它被”吃掉”了！追踪发现，在 &lt;code&gt;utils.h&lt;/code&gt; 中定义了一个同名宏，当 &lt;code&gt;__SANITIZE_ADDRESS__&lt;/code&gt; 宏未定义时，该宏被展开为空，导致函数声明被意外删除。这个案例再次证明：&lt;strong&gt;宏命名冲突是编译错误的常见陷阱&lt;/strong&gt;，而&lt;strong&gt;预处理输出文件&lt;/strong&gt;是诊断这类问题的利器。同时，&lt;code&gt;FileLocator&lt;/code&gt; 这类文件搜索工具在源码分析中不可或缺。&lt;/p&gt;
    
    </summary>
    
      <category term="排错" scheme="https://bianchengnan.github.io/categories/%E6%8E%92%E9%94%99/"/>
    
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="排错" scheme="https://bianchengnan.github.io/tags/%E6%8E%92%E9%94%99/"/>
    
      <category term="troubleshoot" scheme="https://bianchengnan.github.io/tags/troubleshoot/"/>
    
      <category term="编译" scheme="https://bianchengnan.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="宏" scheme="https://bianchengnan.github.io/tags/%E5%AE%8F/"/>
    
      <category term="compile" scheme="https://bianchengnan.github.io/tags/compile/"/>
    
  </entry>
  
  <entry>
    <title>深入.NET Runtime：一次 OOM 异常的分析与源码追踪之旅</title>
    <link href="https://bianchengnan.github.io//articles/analyze-oom-and-dive-into-dotnet-source/"/>
    <id>https://bianchengnan.github.io//articles/analyze-oom-and-dive-into-dotnet-source/</id>
    <published>2025-11-29T12:42:23.000Z</published>
    <updated>2026-02-16T10:40:27.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录了一次对 <code>.NET</code> 应用程序发生的“内存不足”（<code>OOM</code>）异常进行的深度源码级调查。问题始于一个看似矛盾的现象：诊断工具显示有足够大的空闲内存块（约 <code>50MB</code>），但垃圾回收（<code>GC</code>）过程却在尝试预留较小内存段（约 <code>16MB</code>）时失败。</p><p>为了探究根源，笔者<strong>逆向追踪了诊断工具（如SOS）输出的数据链路</strong>：从高层诊断命令（<code>AnalyzeOOMCommand</code>）入手，逐步深入<code>Microsoft.Diagnostics.Runtime (CLRMD)</code>库、托管辅助类、<code>Dac</code> 接口，最终直达 <code>.NET Runtime(CoreCLR)</code> 底层的 <code>GC</code> 相关 <code>Native</code> 代码（如 <code>ClrDataAccess</code>、<code>gc_heap</code>）。</p><p>虽然最终并没能定位问题的真实原因，但是理清了 <code>GC</code> 在 <code>virtual_alloc</code>过程中因<strong>内存限制检查、地址空间布局考量等因素</strong>导致预留失败的具体逻辑，并对 <code>.NET</code> 源码有了一定的认识，还是非常值得记录分享的。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前些日子，在 <code>.NET</code> 调试群里有位网友的 <code>.NET</code> 程序触发了 <code>OOM (Out Of Memory)</code> 异常，他在群里发了一些截图，询问大家是什么原因导致的。其中一张分析结果图如下：</p><p><img src="http://resources.bianchengnan.tech/analyze-oom-and-dive-into-dotnet-source/oom.png" alt="oom"></p><p>看着是 <code>gc</code> 过程中发生了内存不足的问题。大概率是要分配 <code>16MB</code> 左右的内存空间时失败了，但是另外一张截图显示，最大空闲块还有 <code>50MB</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/analyze-oom-and-dive-into-dotnet-source/address-summary.png" alt="address-summary"></p><p>由于没看过 <code>.net</code> 源码，只能根据自己的认知进行了回复，这种心里没底的感觉很不爽。正好最近想多研究下 <code>.net</code>，而且有源代码可查，为啥不看看呢？</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>可以通过 <code>git clone https://github.com/dotnet/runtime.git</code> 命令把 <code>.NET runtime</code> 源码克隆到本地。还可以下载对应的诊断工具源码，包括但不限于 <code>SOS</code>。可以通过 <code>git clone https://github.com/dotnet/diagnostics.git</code> 克隆到本地。</p><blockquote><p><strong>说明：</strong> 最开始的想法是编译一份进行调试，折腾了半天，还遇到一些编译错误，这里就不展开了，后面会有一篇文章单独总结。</p><p>下载的版本与我我本地的运行时版本（<code>8.0.7</code>）不匹配，切换到对应的版本（<code>git tag --list</code> 然后 <code>git checkout v8.0.7</code> ）。</p></blockquote><p>如何开始呢？截图中的关键信息描述就是入手点，当然从搜索入手了。</p><h2 id="追踪-OOM-来源"><a href="#追踪-OOM-来源" class="headerlink" title="追踪 OOM 来源"></a>追踪 OOM 来源</h2><p>打开文件内容搜索神器 <code>FileLocator</code>，搜索 <code>Failed to reserve memory</code>，在 <code>AnalyzeOOMCommand.cs</code> 中发现了匹配项。 </p><p><img src="http://resources.bianchengnan.tech/analyze-oom-and-dive-into-dotnet-source/search-keyword.png" alt="search-keyword"></p><p>关键类摘录如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnalyzeOOMCommand</span> : <span class="title">ClrRuntimeCommandBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">bool</span> foundOne = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (ClrOutOfMemoryInfo oom <span class="keyword">in</span> Runtime.Heap.SubHeaps.Select(h =&gt; h.OomInfo).Where(oom =&gt; oom != <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            foundOne = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(oom.Reason <span class="keyword">switch</span></span><br><span class="line">            &#123;</span><br><span class="line">                OutOfMemoryReason.Budget or OutOfMemoryReason.CantReserve =&gt; <span class="string">"OOM was due to an internal .Net error, likely a bug in the GC"</span>,</span><br><span class="line">                OutOfMemoryReason.CantCommit =&gt; <span class="string">"Didn't have enough memory to commit"</span>,</span><br><span class="line">                OutOfMemoryReason.LOH =&gt; <span class="string">"Didn't have enough memory to allocate an LOH segment"</span>,</span><br><span class="line">                OutOfMemoryReason.LowMem =&gt; <span class="string">"Low on memory during GC"</span>,</span><br><span class="line">                OutOfMemoryReason.UnproductiveFullGC =&gt; <span class="string">"Could not do a full GC"</span>,</span><br><span class="line">                _ =&gt; oom.Reason.ToString() <span class="comment">// shouldn't happen, we handle all cases above</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oom.GetMemoryFailure != GetMemoryFailureReason.None)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> message = oom.GetMemoryFailure <span class="keyword">switch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    GetMemoryFailureReason.ReserveSegment =&gt; <span class="string">"Failed to reserve memory"</span>,</span><br><span class="line">                    GetMemoryFailureReason.CommitSegmentBegin =&gt; <span class="string">"Didn't have enough memory to commit beginning of the segment"</span>,</span><br><span class="line">                    GetMemoryFailureReason.CommitEphemeralSegment =&gt; <span class="string">"Didn't have enough memory to commit the new ephemeral segment"</span>,</span><br><span class="line">                    GetMemoryFailureReason.GrowTable =&gt; <span class="string">"Didn't have enough memory to grow the internal GC data structures"</span>,</span><br><span class="line">                    GetMemoryFailureReason.CommitTable =&gt; <span class="string">"Didn't have enough memory to commit the internal GC data structures"</span>,</span><br><span class="line">                    _ =&gt; oom.GetMemoryFailure.ToString() <span class="comment">// shouldn't happen, we handle all cases above</span></span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(<span class="string">$"Details: <span class="subst">&#123;(oom.IsLargeObjectHeap ? <span class="string">"LOH"</span> : <span class="string">"SOH"</span>)&#125;</span> <span class="subst">&#123;message&#125;</span> <span class="subst">&#123;oom.Size:n0&#125;</span> bytes"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If it's a commit error (GetMemoryFailureReason.GrowTable can indicate a reserve</span></span><br><span class="line">                <span class="comment">// or a commit error since we make one VirtualAlloc call to reserve and commit),</span></span><br><span class="line">                <span class="comment">// we indicate the available commit space if we recorded it.</span></span><br><span class="line">                <span class="keyword">if</span> (oom.AvailablePageFileMB != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">$" - on GC entry available commit space was <span class="subst">&#123;oom.AvailablePageFileMB:n0&#125;</span> MB"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!foundOne)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"There was no managed OOM due to allocations on the GC heap"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看，与网友截图中的输出高度匹配，看样子是找对地方了。从代码逻辑可知，<code>AnalyzeOOMCommand</code> 命令会遍历堆，输出每个堆上的 <code>ClrOutOfMemoryInfo</code> 信息。关键代码如下：</p><p><code>foreach (ClrOutOfMemoryInfo oom in Runtime.Heap.SubHeaps.Select(h =&gt; h.OomInfo).Where(oom =&gt; oom != null))</code></p><p>至此可推断，发生 <code>OOM</code> 异常时，<code>runtime</code> 会把相关信息保存到堆上。<code>SOS</code> 等插件直接从对上取出对应信息，展示出来即可。看完这个类的实现，感觉我又行了，也能写一个类似的插件了，哈哈哈。不废话了，回到正题。单击 <code>h.OomInfo</code> 跳转到 <code>OomInfo</code> 的实现，可以发现其是类 <code>ClrSubHeap</code> 的一个属性字段。</p><blockquote><p><strong>说明：</strong><code>ClrSubHeap</code> 并没有实现在 <code>diagnostics</code> 工程中，而是实现在 <code>Microsoft.Diagnostics.Runtime</code> 中，可以通过 <code>git clone https://github.com/microsoft/clrmd.git</code> 下载。</p></blockquote><p>打开 <code>Microsoft.Diagnostics.Runtime.sln</code>，可以搜到 <code>OomInfo</code> 的实现，如下：</p><p><code>public ClrOutOfMemoryInfo? OomInfo =&gt; Heap.Helpers.GetOOMInfo(Address, out OomInfo oomInfo) ? new(oomInfo) : null;</code></p><p><code>OomInfo</code> 来自 <code>Heap.Helpers.GetOOMInfo()</code> 函数。而 <code>Heap</code> 是 <code>ClrSubHeap</code> 的一个字段，在 <code>ClrSubHeap</code> 构造的时候传进来。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClrSubHeap</span> : <span class="title">IClrSubHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrSubHeap</span>(<span class="params">ClrHeap clrHeap, <span class="keyword">in</span> SubHeapInfo subHeap</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Heap = clrHeap;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClrHeap Heap &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    IClrHeap IClrSubHeap.Heap =&gt; Heap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转到 <code>ClrHeap</code> 的实现看下 <code>Helpers</code> 的来源</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrHeap</span> : <span class="title">IClrHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrHeap</span>(<span class="params">ClrRuntime runtime, IMemoryReader memoryReader, IAbstractHeapProvider helpers, IAbstractTypeProvider typeHelpers, <span class="keyword">in</span> GCState gcInfo</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Runtime = runtime;</span><br><span class="line">        _memoryReader = memoryReader;</span><br><span class="line">        Helpers = helpers; <span class="comment">//&lt;----</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        SubHeaps = Helpers.EnumerateSubHeaps().Select(r =&gt; <span class="keyword">new</span> ClrSubHeap(<span class="keyword">this</span>, r)).ToImmutableArray();</span><br><span class="line">        Segments = SubHeaps.SelectMany(r =&gt; r.Segments).OrderBy(r =&gt; r.FirstObjectAddress).ToImmutableArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> IAbstractHeap Helpers &#123; <span class="keyword">get</span>; &#125; <span class="comment">//&lt;---</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClrRuntime Runtime &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 <code>Helpers</code> 是在 <code>ClrHeap</code> 构造的时候通过参数传进来的，而且 <code>SubHeaps</code> 也会在 <code>ClrHeap</code> 构造的时候被创建出来。</p><p>再看下 <code>ClrHeap</code> 是怎么被构造出来的。在 <code>ClrHeap</code> 的构造函数上方点击引用数量，跳转到对应的位置。可以发现其来自 <code>ClrRuntime</code> 的 <code>Heap</code> 属性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrRuntime</span> : <span class="title">IClrRuntime</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClrHeap Heap</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            ClrHeap? heap = _heap;</span><br><span class="line">            <span class="keyword">while</span> (heap <span class="keyword">is</span> <span class="literal">null</span>) <span class="comment">// Flush can cause a race.</span></span><br><span class="line">            &#123;</span><br><span class="line">                IAbstractHeap? heapHelpers = GetService&lt;IAbstractHeap&gt;(); <span class="comment">//&lt;---</span></span><br><span class="line">                IAbstractTypeHelpers? typeHelpers = GetService&lt;IAbstractTypeHelpers&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// These are defined as non-nullable but just in case, double check we have a non-null instance.</span></span><br><span class="line">                <span class="keyword">if</span> (heapHelpers <span class="keyword">is</span> <span class="literal">null</span> || typeHelpers <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException(<span class="string">"Unable to create a ClrHeap for this runtime."</span>);</span><br><span class="line"></span><br><span class="line">                heap = <span class="keyword">new</span>(<span class="keyword">this</span>, DataTarget.DataReader, heapHelpers, typeHelpers);</span><br><span class="line">                Interlocked.CompareExchange(<span class="keyword">ref</span> _heap, heap, <span class="literal">null</span>);</span><br><span class="line">                heap = _heap;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> heap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 <code>heapHelpers</code> 参数来自 <code>IAbstractHeap? heapHelpers = GetService&lt;IAbstractHeap&gt;();</code></p><p>跳转到 <code>GetService()</code> 的实现，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> T? GetService&lt;T&gt;() <span class="keyword">where</span> T: <span class="keyword">class</span> =&gt; (T?)_services.GetService(<span class="keyword">typeof</span>(T));</span><br></pre></td></tr></table></figure><p>可以发现，<code>GetService&lt;T&gt;()</code> 是通过 <code>_services.GetService(typeof(T))</code> 实现的，再看下 <code>_services</code> 的来源。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrRuntime</span> : <span class="title">IClrRuntime</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _services;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ClrHeap? _heap;</span><br><span class="line">    <span class="keyword">private</span> ImmutableArray&lt;ClrThread&gt; _threads;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> DomainAndModules? _domainAndModules;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAbstractRuntime? _runtime;</span><br><span class="line">    <span class="keyword">private</span> IAbstractComHelpers? _comHelpers;</span><br><span class="line">    <span class="keyword">private</span> IAbstractMethodLocator? _methodLocator;</span><br><span class="line">    <span class="keyword">private</span> IAbstractDacController? _controller;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrRuntime</span>(<span class="params">ClrInfo clrInfo, IServiceProvider services</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ClrInfo = clrInfo;</span><br><span class="line">        DataTarget = clrInfo.DataTarget;</span><br><span class="line">        _services = services; <span class="comment">//&lt;---</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 <code>_services</code> 是在 <code>ClrRuntime</code> 构造的时候传进来的。点击 <code>ClrRuntime</code> 的构造函数上方的引用计数，可以发现  <code>ClrRuntime</code>  在<code>ClrInfo</code> 的 <code>CreateRuntimeWorker()</code> 函数中被创建，<code>services</code> 参数来自 <code>ClrInfoProvider.GetDacServices()</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrInfo</span> : <span class="title">IClrInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ClrRuntime <span class="title">CreateRuntimeWorker</span>(<span class="params"><span class="keyword">string</span>? dacPath, <span class="keyword">bool</span> ignoreMismatch, <span class="keyword">bool</span> verifySignature</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        IServiceProvider services = ClrInfoProvider.GetDacServices(<span class="keyword">this</span>, dacPath, ignoreMismatch, verifySignature);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClrRuntime(<span class="keyword">this</span>, services);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下 <code>ClrInfoProvider</code> 的来源，发现其是 <code>ClrInfo</code> 的属性成员，在 <code>ClrInfo</code> 构造的时候被初始化。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClrInfo</span> : <span class="title">IClrInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">ClrInfo</span>(<span class="params">DataTarget dt, ModuleInfo module, Version clrVersion, IClrInfoProvider provider</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DataTarget = dt ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(dt));</span><br><span class="line">        ModuleInfo = module ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(module));</span><br><span class="line">        ClrInfoProvider = provider ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(provider)); <span class="comment">//&lt;---</span></span><br><span class="line">        Version = clrVersion ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(clrVersion));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The DataTarget containing this ClrInfo.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> DataTarget DataTarget &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The IClrInfoProvider which created this ClrInfo.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> IClrInfoProvider ClrInfoProvider &#123; <span class="keyword">get</span>; &#125; <span class="comment">//&lt;---</span></span><br><span class="line"></span><br><span class="line">    IDataTarget IClrInfo.DataTarget =&gt; DataTarget;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看 <code>ClrInfo</code> 是在哪里被创建的，点击 <code>ClrInfo</code> 的构造函数上方的引用计数，可以发现其来自 <code>DotNetClrInfoProvider</code> 的 <code>CreateClrInfo()</code> 函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DotNetClrInfoProvider</span> : <span class="title">IClrInfoProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClrInfo <span class="title">CreateClrInfo</span>(<span class="params">DataTarget dataTarget, ModuleInfo module, <span class="keyword">ulong</span> runtimeInfo, ClrFlavor flavor</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        ClrInfo result = <span class="keyword">new</span>(dataTarget, module, version, <span class="keyword">this</span>) <span class="comment">//&lt;---</span></span><br><span class="line">        &#123;</span><br><span class="line">            Flavor = flavor,</span><br><span class="line">            DebuggingLibraries = orderedDebugLibraries.ToImmutableArray(),</span><br><span class="line">            ContractDescriptorAddress = contractDescriptor,</span><br><span class="line">            IndexFileSize = indexFileSize,</span><br><span class="line">            IndexTimeStamp = indexTimeStamp,</span><br><span class="line">            BuildId = buildId,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知，<code>ClrInfo</code> 构造函数的最后一个参数是 <code>this</code>，所以 <code>ClrInfo</code> 中的 <code>ClrInfoProvider</code> 是 <code>DotNetClrInfoProvider</code> 类型的对象。再来查看一下 <code>DotNetClrInfoProvider::GetDacServices()</code> 函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IServiceProvider <span class="title">GetDacServices</span>(<span class="params">ClrInfo clrInfo, <span class="keyword">string</span>? providedPath, <span class="keyword">bool</span> ignoreMismatch, <span class="keyword">bool</span> verifySignature</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DacLibrary library = GetDacLibraryFromPath(clrInfo, providedPath, ignoreMismatch, verifySignature);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DacServiceProvider(clrInfo, library);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会返回 <code>DacServiceProvider</code> 类型的对象，所以 <code>ClrRuntime._services</code> 实际是 <code>DacServiceProvider</code> 类型的对象。<code>ClrRuntime</code> 的 <code>Heap</code> 属性中调用的 <code>IAbstractHeap? heapHelpers = GetService&lt;IAbstractHeap&gt;()</code> 就相当于调用的是 <code>DacServiceProvider.GetService(IAbstractHeap)</code>。</p><p>看看 <code>DacServiceProvider.GetService(Type)</code> 的实现，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DacServiceProvider</span> : <span class="title">IServiceProvider</span>, <span class="title">IDisposable</span>, <span class="title">IAbstractDacController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span>? GetService(Type serviceType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (serviceType == <span class="keyword">typeof</span>(IAbstractRuntime))</span><br><span class="line">            <span class="keyword">return</span> _runtime ??= <span class="keyword">new</span> DacRuntime(_clrInfo, _process, _sos, _sos13);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serviceType == <span class="keyword">typeof</span>(IAbstractHeap)) <span class="comment">//&lt;---</span></span><br><span class="line">        &#123;</span><br><span class="line">            IAbstractHeap? heap = _heapHelper;</span><br><span class="line">            <span class="keyword">if</span> (heap <span class="keyword">is</span> not <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> heap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_sos.GetGCHeapData(<span class="keyword">out</span> GCInfo data) &amp;&amp; _sos.GetCommonMethodTables(<span class="keyword">out</span> CommonMethodTables mts) &amp;&amp; mts.ObjectMethodTable != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> _heapHelper = <span class="keyword">new</span> DacHeap(_sos, _sos8, _sos12, _sos16, _dataReader, data, mts);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>ClrHeap</code> 中的 <code>Helpers</code> 成员的类型是 <code>DacHeap</code>，看看其 <code>GetOOMInfo()</code> 的实现。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DacHeap</span> : <span class="title">IAbstractHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">GetOOMInfo</span>(<span class="params"><span class="keyword">ulong</span> subHeapAddress, <span class="keyword">out</span> OomInfo oomInfo</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DacOOMData oomData;</span><br><span class="line">        <span class="keyword">if</span> (subHeapAddress != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_sos.GetOOMData(subHeapAddress, <span class="keyword">out</span> oomData) || oomData.Reason == OutOfMemoryReason.None &amp;&amp; oomData.GetMemoryFailure == GetMemoryFailureReason.None)</span><br><span class="line">            &#123;</span><br><span class="line">                oomInfo = <span class="keyword">default</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_sos.GetOOMData(<span class="keyword">out</span> oomData) || oomData.Reason == OutOfMemoryReason.None &amp;&amp; oomData.GetMemoryFailure == GetMemoryFailureReason.None)</span><br><span class="line">            &#123;</span><br><span class="line">                oomInfo = <span class="keyword">default</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oomInfo = <span class="keyword">new</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            AllocSize = oomData.AllocSize,</span><br><span class="line">            AvailablePageFileMB = oomData.AvailablePageFileMB,</span><br><span class="line">            GCIndex = oomData.GCIndex,</span><br><span class="line">            GetMemoryFailure = oomData.GetMemoryFailure,</span><br><span class="line">            IsLOH = oomData.IsLOH != <span class="number">0</span>,</span><br><span class="line">            Reason = oomData.Reason,</span><br><span class="line">            Size = oomData.Size,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了 <code>_sos.GetOOMData(out oomData)</code>。<code>_sos</code> 是 <code>DacHeap</code> 的成员变量，来自 <code>DacHeap</code> 构造函数的第一个参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DacHeap</span> : <span class="title">IAbstractHeap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac _sos; <span class="comment">//&lt;--</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac8? _sos8;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DacHeap</span>(<span class="params">SOSDac sos, SOSDac8? sos8, SosDac12? sos12, ISOSDac16? sos16, IMemoryReader reader, <span class="keyword">in</span> GCInfo gcInfo, <span class="keyword">in</span> CommonMethodTables commonMethodTables</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _sos = sos; <span class="comment">//&lt;--</span></span><br><span class="line">        _sos8 = sos8;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>DacHeap</code> 又是在 <code>DacServiceProvider.GetService(Type)</code> 中创建的，关键代码是</p><p><code>return _heapHelper = new DacHeap(_sos, _sos8, _sos12, _sos16, _dataReader, data, mts);</code></p><p>传递给 <code>DacHeap</code> 的第一个参数是 <code>DacServiceProvider</code> 的成员变量 <code>_sos</code>。该成员变量是在 <code>DacServiceProvider</code> 的构造函数中初始化的。构造函数如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DacServiceProvider</span> : <span class="title">IServiceProvider</span>, <span class="title">IDisposable</span>, <span class="title">IAbstractDacController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ClrInfo _clrInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IDataReader _dataReader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DacLibrary _dac;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ClrDataProcess _process;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac _sos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SOSDac6? _sos6;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DacServiceProvider</span>(<span class="params">ClrInfo clrInfo, DacLibrary library</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _clrInfo = clrInfo;</span><br><span class="line">        _dataReader = _clrInfo.DataTarget.DataReader;</span><br><span class="line"></span><br><span class="line">        _dac = library;</span><br><span class="line">        _process = library.CreateClrDataProcess();</span><br><span class="line">        _sos = _process.CreateSOSDacInterface() ?? <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">$"Could not create ISOSDacInterface."</span>); <span class="comment">//&lt;--</span></span><br><span class="line">        _sos6 = _process.CreateSOSDacInterface6();</span><br><span class="line"></span><br><span class="line">        library.DacDataTarget.SetMagicCallback(_process.Flush);</span><br><span class="line">        IsThreadSafe = _sos13 <span class="keyword">is</span> not <span class="literal">null</span> || RuntimeInformation.IsOSPlatform(OSPlatform.Windows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_sos</code> 是由 <code>_process.CreateSOSDacInterface()</code> 创建的，而 <code>_process</code> 的类型是 <code>ClrDataProcess</code>，看一下 <code>_process.CreateSOSDacInterface()</code> 的实现，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">ClrDataProcess</span> : <span class="title">CallableCOMWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Guid IID_IXCLRDataProcess = <span class="keyword">new</span>(<span class="string">"5c552ab6-fc09-4cb3-8e36-22fa03c798b7"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DacLibrary _library;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SOSDac? CreateSOSDacInterface()</span><br><span class="line">    &#123;</span><br><span class="line">        IntPtr result = QueryInterface(SOSDac.IID_ISOSDac);</span><br><span class="line">        <span class="keyword">if</span> (result == IntPtr.Zero)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SOSDac(_library, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvalidOperationException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数会返回 <code>SOSDac</code> 类型的对象，该类型构造函数的第二个参数是通过 <code>QueryInterface(SOSDac.IID_ISOSDac)</code> 得到的，<code>SOSDac.IID_ISOSDac</code> 的值是 <code>436f00f2-b42a-4b9f-870c-e73db66ae930</code>，是 <code>SOSDac</code> 类的静态变量，<code>SOSDac</code> 的定义如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">SOSDac</span> : <span class="title">CallableCOMWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Guid IID_ISOSDac = <span class="keyword">new</span>(<span class="string">"436f00f2-b42a-4b9f-870c-e73db66ae930"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> DacLibrary _library;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt;? _regNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Dictionary&lt;<span class="keyword">ulong</span>, <span class="keyword">string</span>&gt;? _frameNames;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SOSDac</span>(<span class="params">DacLibrary? library, IntPtr ptr</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">library?.OwningLibrary, IID_ISOSDac, ptr</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _library = library ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(library));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">ref</span> <span class="keyword">readonly</span> ISOSDacVTable VTable =&gt; <span class="keyword">ref</span> Unsafe.AsRef&lt;ISOSDacVTable&gt;(_vtable);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SOSDac</span>(<span class="params">DacLibrary lib, CallableCOMWrapper toClone</span>) : <span class="title">base</span>(<span class="params">toClone</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _library = lib;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HResult <span class="title">GetOOMData</span>(<span class="params"><span class="keyword">out</span> DacOOMData oomData</span>)</span> =&gt; VTable.GetOOMStaticData(Self, <span class="keyword">out</span> oomData);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HResult <span class="title">GetOOMData</span>(<span class="params"><span class="keyword">ulong</span> address, <span class="keyword">out</span> DacOOMData oomData</span>)</span> =&gt; VTable.GetOOMData(Self, address, <span class="keyword">out</span> oomData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类什么有用的事情都没做，都是调用 <code>VTable</code> 中的实现，而且其基类是 <code>CallableCOMWrapper</code>，可以大胆猜测此类是一个 <code>COM</code> 调用类，真正的实现在 <code>native</code> 层。是不是呢？到 <code>native</code> 层搜搜就知道了。</p><h2 id="查看-clr-runtime-实现"><a href="#查看-clr-runtime-实现" class="headerlink" title="查看 clr runtime 实现"></a>查看 clr runtime 实现</h2><p>在  <code>native</code> 代码中搜索 <code>436f00f2-b42a-4b9f-870c-e73db66ae930</code>，可以在 <code>sospriv.h</code> 头文件中搜到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MIDL_INTERFACE(<span class="string">"436f00f2-b42a-4b9f-870c-e73db66ae930"</span>) <span class="comment">//&lt;---</span></span><br><span class="line">ISOSDacInterface : <span class="keyword">public</span> IUnknown</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">GetOOMData</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">        CLRDATA_ADDRESS oomAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct DacpOomData *data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">GetOOMStaticData</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">        struct DacpOomData *data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继续搜索 <code>ISOSDacInterface</code>，可以在 <code>daccess.cpp</code> 中找到使用的地方，对应的实现类是 <code>ClrDataAccess</code>。</p><blockquote><p><strong>说明：</strong> 对应的声明文件在 <code>D:\dotnet\runtime\src\coreclr\debug\daccess\dacimpl.h</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\debug\daccess\daccess.cpp</span></span><br><span class="line"></span><br><span class="line">STDMETHODIMP</span><br><span class="line">ClrDataAccess::QueryInterface(THIS_</span><br><span class="line">                              IN REFIID interfaceId,</span><br><span class="line">                              OUT PVOID* iface)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* ifaceRet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsEqualIID(interfaceId, IID_IUnknown) ||</span><br><span class="line">        IsEqualIID(interfaceId, __uuidof(IXCLRDataProcess)) ||</span><br><span class="line">        IsEqualIID(interfaceId, __uuidof(IXCLRDataProcess2)))</span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;IXCLRDataProcess2*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsEqualIID(interfaceId, __uuidof(ICLRDataEnumMemoryRegions)))</span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;ICLRDataEnumMemoryRegions*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsEqualIID(interfaceId, __uuidof(ISOSDacInterface))) <span class="comment">//&lt;---</span></span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;ISOSDacInterface*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsEqualIID(interfaceId, __uuidof(ISOSDacInterface2)))</span><br><span class="line">    &#123;</span><br><span class="line">        ifaceRet = <span class="keyword">static_cast</span>&lt;ISOSDacInterface2*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    AddRef();</span><br><span class="line">    *iface = ifaceRet;</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以查看 <code>ClrDataAccess::GetOOMData()</code> 的具体实现，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\debug\daccess\request.cpp</span></span><br><span class="line"></span><br><span class="line">HRESULT</span><br><span class="line">ClrDataAccess::GetOOMData(CLRDATA_ADDRESS oomAddr, struct DacpOomData *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (oomAddr == <span class="number">0</span> || data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> E_INVALIDARG;</span><br><span class="line"></span><br><span class="line">    SOSDacEnter();</span><br><span class="line">    *data = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!GCHeapUtilities::IsServerHeap())</span><br><span class="line">        hr = E_FAIL; <span class="comment">// doesn't make sense to call this on WKS mode</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FEATURE_SVR_GC</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hr = ServerOomData(oomAddr, data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _ASSERTE_MSG(<span class="literal">false</span>, <span class="string">"IsServerHeap returned true but FEATURE_SVR_GC not defined"</span>);</span><br><span class="line">    hr = E_NOTIMPL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//FEATURE_SVR_GC</span></span></span><br><span class="line"></span><br><span class="line">    SOSDacLeave();</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClrDataAccess::ServerOomData()</code> 的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\debug\daccess\request_svr.cpp</span></span><br><span class="line">    </span><br><span class="line">HRESULT</span><br><span class="line">ClrDataAccess::ServerOomData(CLRDATA_ADDRESS addr, DacpOomData *oomData)</span><br><span class="line">&#123;</span><br><span class="line">    TADDR heapAddress = TO_TADDR(addr);</span><br><span class="line">    dac_gc_heap heap = LoadGcHeapData(heapAddress);</span><br><span class="line">    dac_gc_heap* pHeap = &amp;heap;</span><br><span class="line"></span><br><span class="line">    oom_history pOOMInfo = pHeap-&gt;oom_info;</span><br><span class="line">    oomData-&gt;reason = pOOMInfo.reason;</span><br><span class="line">    oomData-&gt;alloc_size = pOOMInfo.alloc_size;</span><br><span class="line">    oomData-&gt;available_pagefile_mb = pOOMInfo.available_pagefile_mb;</span><br><span class="line">    oomData-&gt;gc_index = pOOMInfo.gc_index;</span><br><span class="line">    oomData-&gt;fgm = pOOMInfo.fgm;</span><br><span class="line">    oomData-&gt;size = pOOMInfo.size;</span><br><span class="line">    oomData-&gt;loh_p = pOOMInfo.loh_p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知，<code>oomData</code> 来自 <code>pHeap-&gt;oom_info</code>，看下 <code>oom_info</code> 的定义，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\gc\gcpriv.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gc_heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    PER_HEAP_FIELD_DIAG_ONLY oom_history oom_info;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其类型是 <code>oom_history</code>，查看定义，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D:\dotnet\runtime\src\coreclr\gc\gcinterface.dac.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reasons why an OOM might occur, recorded in the oom_history</span></span><br><span class="line"><span class="comment">// struct below.</span></span><br><span class="line"><span class="keyword">enum</span> oom_reason</span><br><span class="line">&#123;</span><br><span class="line">    oom_no_failure = <span class="number">0</span>,</span><br><span class="line">    oom_budget = <span class="number">1</span>,</span><br><span class="line">    oom_cant_commit = <span class="number">2</span>,</span><br><span class="line">    oom_cant_reserve = <span class="number">3</span>,</span><br><span class="line">    oom_loh = <span class="number">4</span>,</span><br><span class="line">    oom_low_mem = <span class="number">5</span>,</span><br><span class="line">    oom_unproductive_full_gc = <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/</span></span><br><span class="line"><span class="comment">/* If you modify failure_get_memory and         */</span></span><br><span class="line"><span class="comment">/* oom_reason be sure to make the corresponding */</span></span><br><span class="line"><span class="comment">/* changes in ClrMD.                            */</span></span><br><span class="line"><span class="comment">/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/</span></span><br><span class="line"><span class="keyword">enum</span> failure_get_memory</span><br><span class="line">&#123;</span><br><span class="line">    fgm_no_failure = <span class="number">0</span>,</span><br><span class="line">    fgm_reserve_segment = <span class="number">1</span>,</span><br><span class="line">    fgm_commit_segment_beg = <span class="number">2</span>,</span><br><span class="line">    fgm_commit_eph_segment = <span class="number">3</span>,</span><br><span class="line">    fgm_grow_table = <span class="number">4</span>,</span><br><span class="line">    fgm_commit_table = <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A record of the last OOM that occurred in the GC, with some</span></span><br><span class="line"><span class="comment">// additional information as to what triggered the OOM.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oom_history</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    oom_reason reason;</span><br><span class="line">    <span class="keyword">size_t</span> alloc_size;</span><br><span class="line">    <span class="keyword">uint8_t</span>* reserved;</span><br><span class="line">    <span class="keyword">uint8_t</span>* allocated;</span><br><span class="line">    <span class="keyword">size_t</span> gc_index;</span><br><span class="line">    failure_get_memory fgm;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">size_t</span> available_pagefile_mb;</span><br><span class="line">    BOOL loh_p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到以上定义就太亲切了。根据目前了解到的信息，这个结构体应该是当发生 <code>OOM</code> 时，<code>runtime</code> 设置的结构体。可以在代码中搜索使用 <code>fgm_reserve_segment</code> 的地方，一共就搜到两处，一处是其定义的地方，一处是使用的地方，使用的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">heap_segment*</span><br><span class="line">gc_heap::get_segment (<span class="keyword">size_t</span> size, gc_oh_num oh)</span><br><span class="line">&#123;</span><br><span class="line">    assert(oh != gc_oh_num::unknown);</span><br><span class="line">    BOOL uoh_p = (oh == gc_oh_num::loh) || (oh == gc_oh_num::poh);</span><br><span class="line">    <span class="keyword">if</span> (heap_hard_limit)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    heap_segment* result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (segment_standby_list != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = segment_standby_list;</span><br><span class="line">        heap_segment* last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (result)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> hs = (<span class="keyword">size_t</span>)(heap_segment_reserved (result) - (<span class="keyword">uint8_t</span>*)result);</span><br><span class="line">            <span class="keyword">if</span> ((hs &gt;= size) &amp;&amp; ((hs / <span class="number">2</span>) &lt; size))</span><br><span class="line">            &#123;</span><br><span class="line">                dprintf (<span class="number">2</span>, (<span class="string">"Hoarded segment %zx found"</span>, (<span class="keyword">size_t</span>) result));</span><br><span class="line">                <span class="keyword">if</span> (last)</span><br><span class="line">                &#123;</span><br><span class="line">                    heap_segment_next (last) = heap_segment_next (result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    segment_standby_list = heap_segment_next (result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last = result;</span><br><span class="line">                result = heap_segment_next (result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span>* mem = virtual_alloc (size);</span><br><span class="line">        <span class="keyword">if</span> (!mem)</span><br><span class="line">        &#123;</span><br><span class="line">            fgm_result.set_fgm (fgm_reserve_segment, size, uoh_p); <span class="comment">//&lt;---</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，当 <code>virtual_alloc (size)</code> 的返回值是空时，会设置 <code>fgm_reserve_segment</code>。再看看 <code>virtual_alloc</code> 的实现，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">virtual_alloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> virtual_alloc(size, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">virtual_alloc</span> <span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">bool</span> use_large_pages_p, <span class="keyword">uint16_t</span> numa_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> requested_size = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">    &#123;</span><br><span class="line">        gc_heap::reserved_memory_limit =</span><br><span class="line">            GCScan::AskForMoreReservedMemory (gc_heap::reserved_memory_limit, requested_size);</span><br><span class="line">        <span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//&lt;---</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = VirtualReserveFlags::None;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP</span></span><br><span class="line">    <span class="keyword">if</span> (virtual_alloc_hardware_write_watch)</span><br><span class="line">    &#123;</span><br><span class="line">        flags = VirtualReserveFlags::WriteWatch;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;--- use_large_pages_p 是 false，会调用 GCToOSInterface::VirtualReserve</span></span><br><span class="line">    <span class="keyword">void</span>* prgmem = use_large_pages_p ?</span><br><span class="line">        GCToOSInterface::VirtualReserveAndCommitLargePages(requested_size, numa_node) :</span><br><span class="line">        GCToOSInterface::VirtualReserve(requested_size, card_size * card_word_width, flags, numa_node);</span><br><span class="line">    <span class="keyword">void</span> *aligned_mem = prgmem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want (prgmem + size) to be right at the end of the address space</span></span><br><span class="line">    <span class="comment">// because we'd have to worry about that everytime we do (address + size).</span></span><br><span class="line">    <span class="comment">// We also want to make sure that we leave loh_size_threshold at the end</span></span><br><span class="line">    <span class="comment">// so we allocate a small object we don't need to worry about overflow there</span></span><br><span class="line">    <span class="comment">// when we do alloc_ptr+size.</span></span><br><span class="line">    <span class="keyword">if</span> (prgmem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span>* end_mem = (<span class="keyword">uint8_t</span>*)prgmem + requested_size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((end_mem == <span class="number">0</span>) || ((<span class="keyword">size_t</span>)(MAX_PTR - end_mem) &lt;= END_SPACE_AFTER_GC))</span><br><span class="line">        &#123;</span><br><span class="line">            GCToOSInterface::VirtualRelease (prgmem, requested_size);</span><br><span class="line">            dprintf (<span class="number">2</span>, (<span class="string">"Virtual Alloc size %zd returned memory right against 4GB [%zx, %zx[ - discarding"</span>,</span><br><span class="line">                        requested_size, (<span class="keyword">size_t</span>)prgmem, (<span class="keyword">size_t</span>)((<span class="keyword">uint8_t</span>*)prgmem+requested_size)));</span><br><span class="line">            prgmem = <span class="number">0</span>;</span><br><span class="line">            aligned_mem = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prgmem)</span><br><span class="line">    &#123;</span><br><span class="line">        gc_heap::reserved_memory += requested_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dprintf (<span class="number">2</span>, (<span class="string">"Virtual Alloc size %zd: [%zx, %zx["</span>,</span><br><span class="line">                 requested_size, (<span class="keyword">size_t</span>)prgmem, (<span class="keyword">size_t</span>)((<span class="keyword">uint8_t</span>*)prgmem+requested_size)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aligned_mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，一共有三个地方会导致返回空，第一处代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">&#123;</span><br><span class="line">    gc_heap::reserved_memory_limit =</span><br><span class="line">        GCScan::AskForMoreReservedMemory (gc_heap::reserved_memory_limit, requested_size);</span><br><span class="line">    <span class="keyword">if</span> ((gc_heap::reserved_memory_limit - gc_heap::reserved_memory) &lt; requested_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//&lt;---</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概逻辑是，如果<strong>保留内存限值</strong>（<code>gc_heap::reserved_memory_limit</code>）- <strong>已保留的内存</strong>（<code>gc_heap::reserved_memory</code>）小于 <strong>请求字节数</strong>（<code>requested_size</code>），就调用 <code>GCScan::AskForMoreReservedMemory()</code> 请求保留更多内存，该函数会返回新的限值。如果 <strong>新限值</strong> - <strong>已保留的内存</strong> 还是小于 <strong>请求字节数</strong> 就返回空。</p><p>第二处代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* prgmem = use_large_pages_p ?</span><br><span class="line">        GCToOSInterface::VirtualReserveAndCommitLargePages(requested_size, numa_node) :</span><br><span class="line">        GCToOSInterface::VirtualReserve(requested_size, card_size * card_word_width, flags, numa_node);</span><br><span class="line">    <span class="keyword">void</span> *aligned_mem = prgmem;</span><br></pre></td></tr></table></figure><p>由于，<code>use_large_pages_p</code> 是 <code>false</code>，会调用 <code>GCToOSInterface::VirtualReserve()</code>，该函数底层又会直接调用 <code>VirtualAlloc()</code>。</p><p>第三处代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prgmem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span>* end_mem = (<span class="keyword">uint8_t</span>*)prgmem + requested_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((end_mem == <span class="number">0</span>) || ((<span class="keyword">size_t</span>)(MAX_PTR - end_mem) &lt;= END_SPACE_AFTER_GC))</span><br><span class="line">    &#123;</span><br><span class="line">        GCToOSInterface::VirtualRelease (prgmem, requested_size);</span><br><span class="line">        dprintf (<span class="number">2</span>, (<span class="string">"Virtual Alloc size %zd returned memory right against 4GB [%zx, %zx[ - discarding"</span>,</span><br><span class="line">                     requested_size, (<span class="keyword">size_t</span>)prgmem, (<span class="keyword">size_t</span>)((<span class="keyword">uint8_t</span>*)prgmem+requested_size)));</span><br><span class="line">        prgmem = <span class="number">0</span>;</span><br><span class="line">        aligned_mem = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MAX_PTR</code> 为最大的无符号整数，<code>end_mem</code> 是此次分配的内存段的结束位置，如果结束位置后面的空间不能容纳大对象堆，也返回空。</p><p>至此，本次折腾就告一段路了，第一张图片中的报错信息，基本上是 <code>virtual_alloc</code> 失败导致的问题。为什么 <code>virtual_alloc</code> 会失败，我到现在也没想明白。因为只尝试保留内存空间，并没有进行提交，按理说在有足够大的空闲内存空间时，不应该失败才对。什么情况下 <code>VirtualAlloc()</code> 会失败，还望各位大牛不吝赐教！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>再次强烈推荐一下 <code>FileLocator</code> 文件内容搜索神器，你值得拥有</li><li></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><code>.net</code> 源码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录了一次对 &lt;code&gt;.NET&lt;/code&gt; 应用程序发生的“内存不足”（&lt;code&gt;OOM&lt;/code&gt;）异常进行的深度源码级调查。问题始于一个看似矛盾的现象：诊断工具显示有足够大的空闲内存块（约 &lt;code&gt;50MB&lt;/code&gt;），但垃圾回收（&lt;code&gt;GC&lt;/code&gt;）过程却在尝试预留较小内存段（约 &lt;code&gt;16MB&lt;/code&gt;）时失败。&lt;/p&gt;
&lt;p&gt;为了探究根源，笔者&lt;strong&gt;逆向追踪了诊断工具（如SOS）输出的数据链路&lt;/strong&gt;：从高层诊断命令（&lt;code&gt;AnalyzeOOMCommand&lt;/code&gt;）入手，逐步深入&lt;code&gt;Microsoft.Diagnostics.Runtime (CLRMD)&lt;/code&gt;库、托管辅助类、&lt;code&gt;Dac&lt;/code&gt; 接口，最终直达 &lt;code&gt;.NET Runtime(CoreCLR)&lt;/code&gt; 底层的 &lt;code&gt;GC&lt;/code&gt; 相关 &lt;code&gt;Native&lt;/code&gt; 代码（如 &lt;code&gt;ClrDataAccess&lt;/code&gt;、&lt;code&gt;gc_heap&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;虽然最终并没能定位问题的真实原因，但是理清了 &lt;code&gt;GC&lt;/code&gt; 在 &lt;code&gt;virtual_alloc&lt;/code&gt;过程中因&lt;strong&gt;内存限制检查、地址空间布局考量等因素&lt;/strong&gt;导致预留失败的具体逻辑，并对 &lt;code&gt;.NET&lt;/code&gt; 源码有了一定的认识，还是非常值得记录分享的。&lt;/p&gt;
    
    </summary>
    
      <category term="NET" scheme="https://bianchengnan.github.io/categories/NET/"/>
    
    
      <category term="源码" scheme="https://bianchengnan.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term=".net" scheme="https://bianchengnan.github.io/tags/net/"/>
    
      <category term="OOM" scheme="https://bianchengnan.github.io/tags/OOM/"/>
    
      <category term="clr" scheme="https://bianchengnan.github.io/tags/clr/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 使用 GFlags 与 WinDbg 定位 VS2022 “重复释放” 引发的崩溃</title>
    <link href="https://bianchengnan.github.io//articles/debug-vs2022-double-free-crash-with-gflags-windbg/"/>
    <id>https://bianchengnan.github.io//articles/debug-vs2022-double-free-crash-with-gflags-windbg/</id>
    <published>2025-11-29T02:21:23.000Z</published>
    <updated>2026-02-16T10:40:27.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录了一次独特的调试经历：作为开发利器的 <code>Visual Studio 2022</code>，其在切换调用栈时频繁崩溃。面对这一问题，利用 <code>procdump</code> 自动捕获崩溃转储文件，并通过 <code>WinDbg</code> 初步排查将问题指向堆内存的异常操作，可能是堆损坏或重复释放。为了精准定位，我启用 <code>gflags</code> 工具开启页堆检测，最终成功捕获到首次释放操作的完整调用栈，明确问题根源在于<code>VSDebug!treegrid::CTreeGridItemContainerGenerator::Refresh</code>过程中的<strong>内存重复释放</strong>。虽然因缺少源码无法直接修复，但通过环境隔离（关闭特定程序）避免了问题复现。此次实战再次证明了 <code>procdump</code>、<code>gflags</code> 等工具在诊断复杂内存问题中的巨大价值，也提醒我们即使面对没有源码的“黑盒”组件，系统化的调试方法依然能指引我们找到问题的本质。</p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近，用 <code>vs2022</code> 在调试的时候，切换调用栈，会有很大概率崩溃。一次两次就忍了，不停的崩溃就有点说不过去了。 话不多说，先放张动图看看 <code>vs2022</code> 是怎么崩溃的。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/vs2022%E5%B4%A9%E6%BA%83.gif" alt="vs2022崩溃"></p><a id="more"></a><p>好在我已经设置了 <code>procdump</code> 为事后调试器，每当有进程崩溃的时候，都会在 <code>d:\dumps\</code> 目录下保存一份转储文件。下图是最近保存的一些转储文件（已经清理过几次了）。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/recent-dump-files.png" alt="recent-dump-files"></p><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>老规矩，使用 <code>windbg</code> 打开对应的转储文件，先无脑 <code>!analyze -v</code> 一波，没看到有用的信息。执行 <code>k</code> 命令查看调用栈，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/delete-exception.png" alt="delete-exception"></p><p>看到熟悉的 <code>delete</code> 基本就猜到是堆出问题了，或者是堆破坏或者是重复释放。如果能找到 <code>delete</code> 的地址，然后使用地址相关命令（比如， <code>!address</code> 或者 <code>!heap -x addr</code> 命令）应该是可以看到一些信息的。那么该如何找到这个地址呢？</p><h2 id="查找关键地址"><a href="#查找关键地址" class="headerlink" title="查找关键地址"></a>查找关键地址</h2><p><code>64</code> 位程序一般是 <code>__stdcall</code>，一般第一个参数是通过 <code>rcx</code> 传递的，但是寄存器的值随着调用其它函数是会改变的，除非保存到栈上过。为了查看传递给 <code>delete</code> 的参数，找到调用它的栈帧。找到栈帧 <code>10</code> （<code>VSDebug!operator delete+0x9</code>）对应的返回地址(<code>00007fff98f13082</code>)，使用 <code>ub</code> 查看对应的反汇编。查看是否有保存 <code>rcx</code> 的操作，没有的话，继续向调用方向找（当然也可以向被调用方向查找是否有保存 <code>rcx</code> 的操作）。直到找到栈帧 <code>12</code> 的返回值地址，</p><p><code>12 0000002899dad690 00007fff99103111     VSDebug!CClassFactory&lt;CRefCount&gt;::Release+0x27</code></p><p>使用 <code>ub 00007fff99103111 L28</code>（为什么 <code>L28</code>，因为好截图）</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/find-the-addres-being-deleted.png" alt="find-the-addres-being-deleted"></p><p>从图中可知，<code>rcx</code> 来自 <code>rbx</code>，而 <code>rbx</code> 的值被保存到当前栈帧（栈帧 <code>13</code>） <code>rsp+0x40</code> 的位置上过。</p><p>执行 <code>dq 0000002899dad6c0 + 0x40 L2</code> 然后执行 <code>!address 0000014185ce4360</code>，然后执行 <code>!heap -x 0x14185ce4360</code>，可以发现这个地址确实是 <code>free</code> 的。如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/verify-the-adress-has-been-deleted.png" alt="verify-the-adress-has-been-deleted"></p><p>虽然这里的值不是 <code>100%</code> 靠谱，但是也能在一定程度上证实我们的猜测。其实，解决堆相关问题，可以使用神器 <code>gflags</code>，可以在尽可能早的时候把问题暴露出来。</p><h2 id="设置-gflags"><a href="#设置-gflags" class="headerlink" title="设置 gflags"></a>设置 gflags</h2><p>打开 <code>gflags.exe</code>，切换到 <code>Image File</code> 页，在 <code>Image:(TAB to refresh)</code> 后面的编辑框内输入 <code>vs</code> 的进程名 <code>devenv.exe</code>，然后按 <code>TAB</code> 键。可以无脑勾选跟堆相关的所有选项。每一项的具体意义可以询问 AI，给出的解释比较靠谱。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/set-gflags-for-devenv.png" alt="set-gflags-for-devenv"></p><p>当然，也可以通过命令行执行，最终都是操作注册表（下表摘自<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/gflags-details" target="_blank" rel="noopener">微软官方文档</a>）：</p><table><thead><tr><th align="left">设置类型</th><th align="left">注册表位置</th></tr></thead><tbody><tr><td align="left">系统级设置（注册表）</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\GlobalFlag</td></tr><tr><td align="left">特定程序的设置（“映像文件”）适用于计算机的所有用户。</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\GlobalFlag</td></tr><tr><td align="left">特定程序的无提示退出设置（“无提示进程退出”）适用于计算机的所有用户。</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\ImageFileName</td></tr><tr><td align="left">计算机的所有用户的图像文件的页堆选项</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\PageHeapFlags</td></tr><tr><td align="left">用户模式堆栈跟踪数据库大小 （<strong>tracedb</strong>）</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\StackTraceDatabaseSizeInMb</td></tr><tr><td align="left">为图像文件创建用户模式堆栈跟踪数据库（ust、0x1000）</td><td align="left">Windows 将映像文件名添加到 USTEnabled 注册表项的值（HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\USTEnabled）。</td></tr><tr><td align="left">在可能的情况下大型页加载映像</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\UseLargePages。</td></tr><tr><td align="left">特殊池（内核特殊池标记）</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PoolTag</td></tr><tr><td align="left">验证开始/验证结束</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PoolTagOverruns。 “ <strong>验证开始</strong> ”选项将值设置为 0。 “ <strong>验证结束</strong> ”选项将值设置为 1。</td></tr><tr><td align="left">映像文件的调试器</td><td align="left">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ImageFileName\调试器</td></tr><tr><td align="left">对象引用跟踪</td><td align="left">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Kernel\ObTraceProcessName  ObTracePermanent 和 ObTracePoolTags</td></tr></tbody></table><p>配置好后，再次重现问题，打开转储文件，再次进行分析。</p><h2 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h2><p>执行 <code>k</code> 命令，可以发现在 <code>GetParent</code> 函数内部触发了异常。如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/callstack-after-turn-on-gflags.png" alt="callstack-after-turn-on-gflags"></p><p>执行 <code>.ecxr</code> 查看异常发生时的上下文，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/ecxr-after-turn-on-gflags.png" alt="ecxr-after-turn-on-gflags"></p><p>第一眼就感觉 <code>rax</code> 的值好特殊啊。看看它的来源，很幸运，在崩溃代码附近（<code>00007fff984e309a</code>）执行 <code>ub</code> 和 <code>u</code> 操作可以找到完整信息，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/virtual-function-call-when-crash.png" alt="virtual-function-call-when-crash"></p><p>红色高亮部分是非常典型的虚函数调用代码。<code>rax</code> 指向虚表，<code>rbx</code> 是对象地址。非常幸运的是在红框上方，把 <code>rbx</code> 保存到了栈 <code>rsp+40h</code> 的地方。其实，没必要，因为当前上下文是异常发生时的上下文（执行了 <code>.ecxr</code> 命令），直接可以获取 <code>rbx</code> 的值。通过查看栈上的值，也佐证了这个观点。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/verify-rbx-by-rsp.png" alt="verify-rbx-by-rsp"></p><p>拿到对象地址后，执行 <code>!address 000001a053fd31f0</code> 和 <code>!heap -x 000001a053fd31f0</code></p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/view-heap-address-info.png" alt="view-heap-address-info"></p><p>从图中没看出特别明显的错误（尤其注意 <code>Flags</code> 的值）。我们已经使用 <code>gflags</code> 开启页堆，并且开启了 <code>ust</code>，可以通过 <code>!heap -p -a 0x1a053fd31f0</code> 命令查看此地址相关的调用栈，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/heap-p-a-address.png" alt="heap-p-a-address"></p><p>从上图可知，在 <code>VSDebug!treegrid::CTreeGridItemContainerGenerator::Refresh</code> 的时候已经触发了 <code>delete</code> 操作，至此，已经可以确认这是个重复释放的问题了，而且第一次释放时的调用栈也很清楚。</p><p>虽然问题已经很明确了，但是我堆 <code>f0f0f0f0f0f0f0f0</code> 这个填充模式充满了好奇。</p><h2 id="填充模式"><a href="#填充模式" class="headerlink" title="填充模式"></a>填充模式</h2><p>我在查看 <code>windbg</code> 帮助文档关于 <code>!heap</code> 部分时，意外发现了它的意义。原来是开启轻型页堆时，内存被释放后，会用此模式填充。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/fill-pattern-explanation-from-windbg-help-document.png" alt="fill-pattern-explanation-from-windbg-help-document"></p><p>而且，我还发现了其它几个有意思的填充值，赶紧实战验证下，通过上面的 <code>!heap -x 000001a053fd31f0</code> 命令已经得到了对应的 <code>Heap Entry</code> 的地址是 <code>000001a053fd31a0</code>。使用 <code>dd 000001a053fd31a0 L80</code> 命令看一下这段内存数据的值。</p><p><img src="http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/view-memory-patttern.png" alt="view-memory-patttern"></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>虽然查到问题了，但是没有代码，也没法解决。但是在整个折腾的过程中发现只有开着某个特定程序的时候，<code>vs</code> 才会崩溃，关闭这个特定程序后 <code>vs</code> 就不再崩溃了。应该是那个程序使用了 <code>UIA</code> 相关接口，做了一些事情，导致 <code>vs</code>  崩溃。</p><p>就不再继续折腾了，有时候不是所有问题都要有一个明确的答案，这也算是解决问题的一种方式吧。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>我已经把对应的转储文件上传到百度云盘了，感兴趣的小伙伴可以下载，亲自实战一番。</p><p>链接: <a href="https://pan.baidu.com/s/15Xa-pCeezeHNwNVwJfGzxA" target="_blank" rel="noopener">https://pan.baidu.com/s/15Xa-pCeezeHNwNVwJfGzxA</a> 提取码: puv8</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/gflags-details" target="_blank" rel="noopener">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/gflags-details</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>procdump</code> 是收集转储文件的神兵利器，一定要放到自己的武器库里</li><li><code>gflags</code> 是解决内存破坏问题的神器，一定要放到自己的武器库里</li><li><code>gflags</code> 最终结果是设置注册表，必要时可以手动设置</li><li><code>x64</code> 位程序默认调用约定是 <code>__stdcall</code>，第一个参数一般会通过 <code>rcx</code> 传递</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录了一次独特的调试经历：作为开发利器的 &lt;code&gt;Visual Studio 2022&lt;/code&gt;，其在切换调用栈时频繁崩溃。面对这一问题，利用 &lt;code&gt;procdump&lt;/code&gt; 自动捕获崩溃转储文件，并通过 &lt;code&gt;WinDbg&lt;/code&gt; 初步排查将问题指向堆内存的异常操作，可能是堆损坏或重复释放。为了精准定位，我启用 &lt;code&gt;gflags&lt;/code&gt; 工具开启页堆检测，最终成功捕获到首次释放操作的完整调用栈，明确问题根源在于&lt;code&gt;VSDebug!treegrid::CTreeGridItemContainerGenerator::Refresh&lt;/code&gt;过程中的&lt;strong&gt;内存重复释放&lt;/strong&gt;。虽然因缺少源码无法直接修复，但通过环境隔离（关闭特定程序）避免了问题复现。此次实战再次证明了 &lt;code&gt;procdump&lt;/code&gt;、&lt;code&gt;gflags&lt;/code&gt; 等工具在诊断复杂内存问题中的巨大价值，也提醒我们即使面对没有源码的“黑盒”组件，系统化的调试方法依然能指引我们找到问题的本质。&lt;/p&gt;
&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近，用 &lt;code&gt;vs2022&lt;/code&gt; 在调试的时候，切换调用栈，会有很大概率崩溃。一次两次就忍了，不停的崩溃就有点说不过去了。 话不多说，先放张动图看看 &lt;code&gt;vs2022&lt;/code&gt; 是怎么崩溃的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://resources.bianchengnan.tech/debug-vs2022-double-free-crash-with-gflags-windbg/vs2022%E5%B4%A9%E6%BA%83.gif&quot; alt=&quot;vs2022崩溃&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="gflags" scheme="https://bianchengnan.github.io/tags/gflags/"/>
    
      <category term="vs222" scheme="https://bianchengnan.github.io/tags/vs222/"/>
    
      <category term="debugger" scheme="https://bianchengnan.github.io/tags/debugger/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 一个隐蔽的崩溃：当 this 指针在构造函数中“杀死”自己</title>
    <link href="https://bianchengnan.github.io//articles/debug-unexpected-crash-due-to-misuse-of-refcountedptr/"/>
    <id>https://bianchengnan.github.io//articles/debug-unexpected-crash-due-to-misuse-of-refcountedptr/</id>
    <published>2025-11-22T11:21:23.000Z</published>
    <updated>2026-02-16T10:40:27.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在最近的项目开发中，我遇到了一个由智能指针误用导致的程序崩溃问题。问题的根源在于 <code>SheetDataHandler</code> 类的构造函数中，将 <code>this</code> 指针传递给了一个接收 <code>SheetDataHandlerPtr</code>（智能指针类型）参数的静态函数 <code>HandleMissingColumn</code>。这个看似简单的操作，却导致了对象在构造函数执行期间被意外释放，最终引发空指针访问异常。</p><p>通过深入调试和反汇编分析，我发现当 <code>this</code> 指针被隐式转换为智能指针时，引用计数会从 <code>0</code> 增加到 <code>1</code>，而在函数调用结束后，智能指针对象析构时引用计数又减回 <code>0</code>，从而触发了对象的 <code>delete</code> 操作。这导致构造函数尚未执行完毕，对象就已经被销毁，后续对成员变量的访问变成了访问已释放内存的非法操作。</p><a id="more"></a><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>以下是我精简整理后的模拟代码，大家可以先锻炼一下眼力，看看是否可以一眼看出问题所在。关于 <code>RefCountedPtr</code> 的代码就不列出来了，可以参考<a href="https://bianchengnan.github.io/articles/mixed-use-of-different-shared-ptr/">之前的文章</a>。</p><blockquote><p><strong>提示</strong>：问题出在 <code>SheetDataHandler.cpp</code> 中。</p></blockquote><ul><li>表格数据处理类头文件 <code>SheetDataHandler.h</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SheetDataHandler.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RefCountedPtr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::wstring&gt; headers;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt;&gt; datasVec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataHandler</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> RefCountedPtr&lt;SheetDataHandler&gt; SheetDataHandlerPtr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataHandler</span> :</span> <span class="keyword">public</span> RefCounted&lt;IRefCounted&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SheetDataHandler(<span class="keyword">const</span> SheetData&amp; sheetData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleMissingColumn</span><span class="params">(SheetDataHandlerPtr helper, <span class="keyword">const</span> SheetData&amp; sheetData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetRowDataPtr&gt; rowDatas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::wstring&gt; headers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>表格数据处理类实现文件 <code>SheetDataHandler.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SheetDataHandler.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"></span><br><span class="line">SheetDataHandler::SheetDataHandler(<span class="keyword">const</span> SheetData&amp; sheetData)</span><br><span class="line">&#123;</span><br><span class="line">    HandleMissingColumn(<span class="keyword">this</span>, sheetData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SheetDataHandler::HandleMissingColumn(SheetDataHandlerPtr helper, <span class="keyword">const</span> SheetData&amp; sheetData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> headers = sheetData.headers;</span><br><span class="line">    <span class="keyword">auto</span> datasVec = sheetData.datasVec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle logic</span></span><br><span class="line"></span><br><span class="line">    helper-&gt;headers = headers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; rowData : datasVec)</span><br><span class="line">    &#123;</span><br><span class="line">        helper-&gt;rowDatas.push_back(<span class="built_in">std</span>::make_shared&lt;SheetRowData&gt;(helper, rowData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>表格数据类头文件 <code>SheetRowData.h</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SheetRowData.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RefCountedPtr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetCellData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SheetCellData() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    SheetCellData(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; data_) : data(data_), type(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::wstring data;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataHandler</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> RefCountedPtr&lt;SheetDataHandler&gt; SheetDataHandlerPtr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetRowData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SheetRowData() = <span class="keyword">default</span>;</span><br><span class="line">    SheetRowData(SheetDataHandlerPtr sdhPtr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt; cells);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt; cells;</span><br><span class="line">    SheetDataHandlerPtr sdhPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SheetRowData&gt; SheetRowDataPtr;</span><br></pre></td></tr></table></figure><ul><li>表格数据类实现文件 <code>SheetRowData.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SheetRowData.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"></span><br><span class="line">SheetRowData::SheetRowData(SheetDataHandlerPtr sdhPtr_, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt; cells_) : sdhPtr(sdhPtr_), cells(cells_)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>表格数据处理流程管理类头文件 <code>SheetDataProcessManager.h</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SheetDataProcessManager.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheetDataProcessManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SheetDataProcessManager&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetData&gt; ReadSheetDatas(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetDataHandlerPtr&gt; sdhMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>表格数据处理流程管理类实现文件 <code>SheetDataProcessManager.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SheetDataProcessManager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataProcessManager.h"</span></span></span><br><span class="line"></span><br><span class="line">SheetDataProcessManager&amp; SheetDataProcessManager::Instance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> SheetDataProcessManager s_instance;</span><br><span class="line">    <span class="keyword">return</span> s_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetData&gt; SheetDataProcessManager::ReadSheetDatas(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::wstring, SheetData&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read from excel</span></span><br><span class="line"></span><br><span class="line">    SheetData sheet1;</span><br><span class="line">    sheet1.headers = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::wstring&gt;&#123; <span class="string">L"ID"</span>, <span class="string">L"Name"</span>, <span class="string">L"Age"</span> &#125;;</span><br><span class="line">    sheet1.datasVec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt;&gt;&#123; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SheetCellData&gt;&#123; SheetCellData(<span class="string">L"001"</span>), SheetCellData(<span class="string">L"test"</span>), SheetCellData(<span class="string">L"18"</span>) &#125;&#125;;</span><br><span class="line">    result[<span class="string">L"Sheet1"</span>] = sheet1;</span><br><span class="line"></span><br><span class="line">    result[<span class="string">L"Sheet2"</span>] = SheetData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SheetDataProcessManager::Init(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> sheetDatas = ReadSheetDatas(path);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : sheetDatas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> handler = <span class="keyword">new</span> SheetDataHandler(it.second);</span><br><span class="line">        sdhMap[it.first] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SheetDataProcessManager::Handle()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主文件 <code>TestRefCountedPtrCrash.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TestRefCountedPtrCrash.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetRowData.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataHandler.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SheetDataProcessManager.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SheetDataProcessManager::Instance().Init(<span class="string">L"test.xlsx"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>优化完代码，执行测试时，遇到了一个崩溃问题，从错误提示看是读取非法地址（<code>0xFFFFFFFFFFFFFFF7</code>）导致的异常。从调用栈看是在执行 <code>RefCountedPtr</code> 的构造函数时发生的异常，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/refcountedptr-assignment-error.png" alt="refcountedptr-assignment-error"></p><p>好奇怪，其基类成员 <code>m_refCount</code> 的值是 <code>-572662307</code>，一个负数，按理说不应该是负数才对。<code>this-&gt;p_</code> 的值是 <code>0x000002519d2d2960</code>，并不是 <code>0xFFFFFFFFFFFFFFF7</code>，为什么会提示 <code>this-&gt;_p-&gt;</code> 是 <code>0xFFFFFFFFFFFFFFF7</code> 呢？先不管了，翻看一下上下文相关代码，没看到明显错误，应该是执行以下代码导致的异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdhMap[it.first] = handler;</span><br></pre></td></tr></table></figure><p>可是这行代码简单到不能再简单了——把对象保存到 <code>map</code> 中，这能出什么问题？既然代码看不出什么问题，那就还是回到发生异常的代码处看看吧。</p><h2 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h2><p>查看最顶层栈帧对应的代码，根据经验，最可能发生异常的是这句话 <code>p_-&gt;AddRef()</code>。具体查看一下发生异常时的汇编指令，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/call-virtual-function-AddRef.png" alt="call-virtual-function-AddRef"></p><p>红色高亮部分是明显的虚函数调用汇编代码、<code>rcx</code> 指向 <code>p_</code>，<code>rax</code> 指向虚表。<code>rax+8</code> 指向虚表第一个函数。等等，<code>rax</code> 的值怎么这么大？而且好像是十进制的，这时候我才发现我没开启十六进制显示。那赶紧看看对应的十六进制是什么？如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/view-values-in-hex.png" alt="view-values-in-hex"></p><p>真是不看不知道，一看吓一跳啊！！！ <code>rax</code> 的值是 <code>0xdddddddddddddddd</code>。而且注意看，<code>m_refCount</code> 的值也是 <code>0xdddddddd</code>。这个值可太熟悉了，当一个对象被删除时，<code>debug</code> 模式下会用 <code>0xdddddddd</code> 填充。难道这个指针被删除后，还在继续使用？查看一下这个指针的来源。查看代码可知，指针来源于 <code>auto handler = new SheetDataHandler(it.second);</code>。难道 <code>new</code> 返回的指针被释放了？代码如此简单，难道是构造函数内部出问题了？赶紧查看构造函数的实现。</p><h2 id="构造函数惹的祸"><a href="#构造函数惹的祸" class="headerlink" title="构造函数惹的祸"></a>构造函数惹的祸</h2><p>构造函数内部只调用了静态函数 <code>HandleMissingColumn(this, sheetData);</code>，并且把当前对象地址当作第一个参数传过去了。再看下这个静态函数的声明，<code>void SheetDataHandler::HandleMissingColumn(SheetDataHandlerPtr helper, const SheetData&amp; sheetData)</code>。第一个参数是一个基于引用计数的智能指针对象。至此，思索片刻，我明白了问题所在，正是这个函数的第一个参数导致了问题。执行构造函数时，引用计数是 <code>0</code>，通过 this 指针构造一个 <code>RefCountedPtr</code>，引用计数 <code>+1</code>，当这个 <code>RefCountedPtr</code> 对象声明周期结束时，引用计数 <code>-1</code> ，引用计数会变成 <code>0</code>，当引用计数变成 <code>0</code> 的时候，会触发执行 <code>delete</code>。怎么证明呢？直接在 <code>RefCounted::Release()</code> 函数加断点，再次运行程序，果然命中，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/delete-self-in-constructor.png" alt="delete-self-in-constructor"></p><p>找到问题根源，解决起来就简单了，只需要修改 <code>void SheetDataHandler::HandleMissingColumn(SheetDataHandlerPtr helper, const SheetData&amp; sheetData)</code> 的第一个参数为原生指针即可。或者在构造函数外部调用此函数也可以解决问题。</p><p>但是，这段代码之前运行一直没问题，为什么最近才暴雷呢？</p><h2 id="消除疑问"><a href="#消除疑问" class="headerlink" title="消除疑问"></a>消除疑问</h2><p>仔细想了一下，之前一直没问题，是因为一直能读取到数据。当有数据时，<code>HandleMissingColumn()</code> 函数内部会调用下面这行代码 <code>helper-&gt;rowDatas.push_back(std::make_shared&lt;SheetRowData&gt;(helper, rowData));</code> ，此行代码会构造一个 <code>SheetRowData</code> 对象，该对象内部有一个成员变量 <code>SheetDataHandlerPtr sdhHelper</code>，会增加引用计数。所以一直没发现这个问题。这下终于把所有疑问都搞清楚了，但是正是因为这番刨根问题，让我又意识到了这段代码中存在的另外一个问题——潜在的内存泄漏。</p><h2 id="潜在的内存泄漏"><a href="#潜在的内存泄漏" class="headerlink" title="潜在的内存泄漏"></a>潜在的内存泄漏</h2><p>为什么会导致内存泄漏呢？如果外部只是把 <code>sdhMap</code> 直接清空，当有数据时，<code>SheetDataHandler</code> 的析构函数是不会被调用的，因为 <code>SheetRowData</code> 中还持有着 <code>SheetDataHandlerPtr</code>。要想释放掉内存，就要在清空 <code>sdhMap</code> 前，先清空 <code>SheetDataHandler</code> 对象中的 <code>rowDatas</code>。这样就不会泄漏了。其实，更优雅的做法是使用标准库提供的 <code>std::weak_ptr</code>，让 <code>SheetRowData</code> 中持有 <code>std::weak_ptr&lt;SheetDataHandler&gt;</code>，使用的时候提升成 <code>std::shared_ptr</code>，如果提升成功，可以正常使用，如果失败，说明已经被删除，不能继续使用。</p><h2 id="无解的-vs-异常提示"><a href="#无解的-vs-异常提示" class="headerlink" title="无解的 vs 异常提示"></a>无解的 vs 异常提示</h2><p>当异常发生时，<code>vs</code> 中报的错误是 <code>引发了异常：读取访问权限冲突。this-&gt;p_ -&gt; 是 0xFFFFFFFFFFFFFFF7</code>。分析完整个异常，也没找到这个 <code>0xFFFFFFFFFFFFFFF7</code> 来自哪里，按理说应该访问 <code>0xdddddddddddddddd + 8</code> 这个地址触发的异常才对。于是保存了一个 <code>dump</code>，在 <code>windbg</code> 中打开，输入 <code>.ecxr</code> 指令查看异常发生时的指令及寄存器信息，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-due-to-misuse-of-refcountedptr/check-exception-in-windbg.png" alt="check-exception-in-windbg"></p><p> 确实是无法访问 <code>0xdddddddddddddddd + 8</code> 地址对应的内存。不知道 <code>vs</code> 为什么会给出这么一个提示，希望有知道的朋友不吝赐教！</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>相关工程代码已经上传到 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/debug-unexpected-crash-due-to-misuse-of-refcountedptr\TestRefCountedPtrCrash" target="_blank" rel="noopener">github</a> 了，感兴趣的小伙伴儿可以下载验证。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/crtsetdbgflag?view=msvc-170" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/crtsetdbgflag?view=msvc-170</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在构造函数中一定不能把 <code>this</code> 指针当作 <code>RefCountedPtr</code> 使用</li><li><code>0xdddddddd</code> 是常用的删除后的填充数据，需要提高敏感度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在最近的项目开发中，我遇到了一个由智能指针误用导致的程序崩溃问题。问题的根源在于 &lt;code&gt;SheetDataHandler&lt;/code&gt; 类的构造函数中，将 &lt;code&gt;this&lt;/code&gt; 指针传递给了一个接收 &lt;code&gt;SheetDataHandlerPtr&lt;/code&gt;（智能指针类型）参数的静态函数 &lt;code&gt;HandleMissingColumn&lt;/code&gt;。这个看似简单的操作，却导致了对象在构造函数执行期间被意外释放，最终引发空指针访问异常。&lt;/p&gt;
&lt;p&gt;通过深入调试和反汇编分析，我发现当 &lt;code&gt;this&lt;/code&gt; 指针被隐式转换为智能指针时，引用计数会从 &lt;code&gt;0&lt;/code&gt; 增加到 &lt;code&gt;1&lt;/code&gt;，而在函数调用结束后，智能指针对象析构时引用计数又减回 &lt;code&gt;0&lt;/code&gt;，从而触发了对象的 &lt;code&gt;delete&lt;/code&gt; 操作。这导致构造函数尚未执行完毕，对象就已经被销毁，后续对成员变量的访问变成了访问已释放内存的非法操作。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="warning" scheme="https://bianchengnan.github.io/tags/warning/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 永远不要忽略编译警告：记一次由重复switch语句导致的诡异崩溃</title>
    <link href="https://bianchengnan.github.io//articles/debug-unexpected-crash-and-never-ignore-compiling-warnings/"/>
    <id>https://bianchengnan.github.io//articles/debug-unexpected-crash-and-never-ignore-compiling-warnings/</id>
    <published>2025-11-22T02:21:23.000Z</published>
    <updated>2026-02-16T10:40:27.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文记录并剖析了一次由看似低级的代码错误引发的、令人意想不到的程序崩溃。问题的根源在于 <code>GetErrorStr</code> 函数中一个容易被忽略的重复 <code>switch</code>语句。这个错误导致函数返回的 <code>std::wstring</code> 对象未被正确初始化，最终在构造 <code>CResult</code> 对象时引发了空指针访问异常 。</p><p>本文通过深入分析崩溃调用栈和反汇编代码，清晰地总结了从函数异常返回（未初始化字符串）到调用端使用无效数据（触发崩溃）的完整过程。希望这个案例能提醒各位，<strong>编译警告是发现潜在风险的第一道防线</strong>，而<strong>基础的汇编知识则是深入调试的利器</strong>。文末有可复现问题的代码，欢迎动手实践。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>好久没写文章了，一个是懒，一个是没有好的素材。最近在研发过程中遇到了几个崩溃问题，挺有意思的，值得总结。今天要总结的问题比较低级，而且编译的时候会报警告，但还是挺有教育意义的。一起看看吧。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>以下是我精简整理后的模拟代码，大家可以先锻炼一下眼力，看看是否可以一眼看出问题所在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CResult</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CResult(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; data_) </span><br><span class="line">        : data(data_)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::wstring data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DoModify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// a lot logic code, return error code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">wstring <span class="title">GetErrorStr</span><span class="params">(<span class="keyword">int</span> error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (error)</span><br><span class="line">    <span class="keyword">switch</span> (error)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"Ok"</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"Invalid Param"</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"Operation Failed"</span>;</span><br><span class="line">    <span class="comment">// a lot more other cases</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L"N/A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> modifyResult = DoModify();</span><br><span class="line">    <span class="function">CResult <span class="title">result</span><span class="params">(GetErrorStr(modifyResult))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>优化完代码后，运行突然崩溃了，简单查看后，是非常典型的空指针异常。</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/nullptr-exception-callstacks.png" alt="nullptr-exception-callstacks"></p><p>心想这不是小菜一碟吗？空指针异常？老朋友了！但是简单翻看调用栈，好像不是普通的空指针异常，在构造字符串对象的时候抛出了异常（上图红色高亮部分调用栈）。难道字符串出问题了？当时脑子里就一句话：字符串能出什么问题？？？</p><p>但是通过调试查看，好像还真是字符串出问题了，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/string-error.png" alt="string-error"></p><p>既然是字符串出问题了，那就看下字符串的来源，来自函数 <code>std::wstring GetErrorStr(int error)</code> 的返回值。查看这个函数的实现。真是不看不知道，一看吓一跳！怎么有两行一样的 <code>switch(error)</code> ？这代码肯定是不对的，删掉一行，再次运行，果然没问题了。</p><p>为什么有重复的 <code>swtich</code> 就会崩溃呢？源码猜不出来，那就看看反汇编代码吧。</p><h2 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h2><p>反汇编代码如下，红色高亮部分是第一个 <code>switch</code> 对应的代码，什么有意义的事情都没做，直接跳转到函数结尾<code>00007FF7800F3A34</code> 了。</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/disassembly-code-of-geterrorstr.png" alt="disassembly-code-of-geterrorstr"></p><p>从图中反汇编代码可知，<code>GetErrorStr()</code> 没对字符串对象做任何初始化操作。那么调用端呢？是否初始化了字符串对象呢？我们接着看一下调用端的反汇编代码，从下图中可知，调用函数也没有初始化字符串对象。</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/disassembly-code-of-main.png" alt="disassembly-code-of-geterrorstr"></p><p>综上，该字符串对象没有被初始化，其内容完全是随机的。</p><p>至此，此次崩溃问题已经很清楚了。但是，这种低级错误，按理说应该有警告才对啊？！</p><h2 id="编译警告"><a href="#编译警告" class="headerlink" title="编译警告"></a>编译警告</h2><p>再次编译，果然有警告，当时我应该忽略了，看来一定要注意编译警告！</p><p><img src="http://resources.bianchengnan.tech/debug-unexpected-crash-and-never-ignore-compiling-warnings/compile-warning.png" alt="compile-warning"></p><h2 id="汇编小知识"><a href="#汇编小知识" class="headerlink" title="汇编小知识"></a>汇编小知识</h2><p>简单解释以上汇编代码，对于刚接触汇编的小伙伴会有帮助。先了解一些基本知识：</p><ol><li><code>x64</code> 下的默认调用约定是 <code>stdcall</code>，前四个参数（非浮点型）通过 <code>rcx rdx r8 r9</code> 传递</li><li>对于 <code>std::wstring GetErrorStr(int error)</code> 这种返回复杂类型（非 <code>POD</code> 类型）的函数，生成的汇编代码相当于 <code>std::wstring* GetErrorStr(std::wstring*, int error)</code> 。<strong>第一个参数</strong> 指向了返回值的地址</li><li>调用结束后，返回值会保存在 <code>rax</code> 中</li></ol><p>所以，上图中第二句汇编代码 <code>00007FF7800F3924  mov qword ptr [rsp+8],rcx</code> 把字符串对象地址保存到了 <code>rsp+0x8</code> 的位置。接下来的几句汇编指令把 <code>rsp</code> 向下移动了 <code>0x8 + 0x8 + 0x108 = 0x118</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00007FF7800F3924  mov         qword ptr [rsp+8],rcx  </span><br><span class="line">00007FF7800F3929  push        rbp  </span><br><span class="line">00007FF7800F392A  push        rdi  </span><br><span class="line">00007FF7800F392B  sub         rsp,108h</span><br></pre></td></tr></table></figure><p>接下来的一条汇编指令 <code>00007FF7800F3932  lea rbp,[rsp+20h]</code> 使 <code>rbp</code> 指向了 <code>rsp+0x20</code> 的位置，那么 <code>rbp+0x100</code> 就指向了 第一个参数的地址。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>相关工程代码已经上传到 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/debug-unexpected-crash-and-never-ignore-compiling-warnings\TestSwitchCaseCrash" target="_blank" rel="noopener">github</a> 了，感兴趣的小伙伴儿可以下载验证。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>务必要关注编译器的警告</li><li>掌握汇编知识非常重要，尤其对调试更是如此</li><li><code>64</code> 位程序默认的调用约定是 <code>stdcall</code>，前四个参数（非浮点型）通过 <code>rcx rdx r8 r9</code> 传递</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文记录并剖析了一次由看似低级的代码错误引发的、令人意想不到的程序崩溃。问题的根源在于 &lt;code&gt;GetErrorStr&lt;/code&gt; 函数中一个容易被忽略的重复 &lt;code&gt;switch&lt;/code&gt;语句。这个错误导致函数返回的 &lt;code&gt;std::wstring&lt;/code&gt; 对象未被正确初始化，最终在构造 &lt;code&gt;CResult&lt;/code&gt; 对象时引发了空指针访问异常 。&lt;/p&gt;
&lt;p&gt;本文通过深入分析崩溃调用栈和反汇编代码，清晰地总结了从函数异常返回（未初始化字符串）到调用端使用无效数据（触发崩溃）的完整过程。希望这个案例能提醒各位，&lt;strong&gt;编译警告是发现潜在风险的第一道防线&lt;/strong&gt;，而&lt;strong&gt;基础的汇编知识则是深入调试的利器&lt;/strong&gt;。文末有可复现问题的代码，欢迎动手实践。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="warning" scheme="https://bianchengnan.github.io/tags/warning/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 5 —— 实战修复虚函数导致的编译错误</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/</id>
    <published>2024-12-01T06:37:07.000Z</published>
    <updated>2026-02-16T10:40:27.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，同事遇到了一个奇怪的编译问题，大概情况如下：</p><p><code>classA</code> 是模块 <code>A</code> 中的一个类， <code>classA</code> 没有定义构造函数，其它函数都是导出的。<code>B</code> 模块依赖了 <code>A</code> 模块，并且会调用 <code>classA</code> 的接口。当在 <code>B</code> 模块中添加了实例化 <code>classA</code> 对象的代码的时候，报链接错误，提示找不到 <code>classA</code> 类的某个虚函数。</p><p>我帮忙看过之后发现又是虚函数相关的编译问题（正好最近在总结虚函数相关的问题），这是送上门的素材啊！</p><a id="more"></a><blockquote><p><strong>说明：</strong> 项目代码不方便对外发布，本文所有的代码是我基于实际项目模拟的</p></blockquote><h2 id="示例程序简介"><a href="#示例程序简介" class="headerlink" title="示例程序简介"></a>示例程序简介</h2><p>示例程序由两个工程组成：<strong>主模块</strong>和<strong>接口模块</strong>。</p><ul><li><p>接口模块</p><p>接口模块只提供了头文件 <code>interface.h</code> 和对应的 <code>interface.lib</code> 文件及接口实现文件 <code>interface.dll</code>。头文件内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_INTERFACE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_INTERFACE InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>主模块</p><p>主模块会隐式依赖 <code>interface.lib</code>，并通过 <code>GetInterface()</code> 接口获取 <code>Interface1</code> 指针，然后调用其接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> if2 = Interface1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当在 <code>main()</code> 函数中通过 <code>auto if2 = Interface1();</code> 创建 <code>Interface1</code> 类型的对象时，编译器会报链接错误，提示无法解析的外部符号，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/LNK2001.png" alt="LNK2001"></p><h2 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h2><p>通过之前总结的几篇文章</p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/">《基础知识 | 有趣的动态转换》</a></p><p><a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a></p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/">《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/">《基础知识 | 函数基础 4 —— 又崩溃了，原来是虚函数声明顺序不一致捣的鬼 》</a></p><p>我对虚函数编译相关的问题有了比较全面的认识。</p><p>头文件中没声明 <code>Interface1</code> 的构造函数，并且 <code>Interface1</code> 包含虚函数，那么编译器会自动生成构造函数代码，与我们手动在头文件中<strong>定义</strong>一个空造函数是一样的。</p><p>在这种情况下，如果想在外部模块实例化 <code>Interface1</code> 的对象，那么 <code>Interface1</code> 所有的虚函数都需要是导出的或者需要在头文件中定义。</p><p>快速扫了一遍头文件，所有虚函数确实都是导出的。这就奇怪了，难道 <code>interface.lib</code> 文件又出问题了？</p><h2 id="查看-lib-文件"><a href="#查看-lib-文件" class="headerlink" title="查看 lib 文件"></a>查看 lib 文件</h2><p>使用 <code>vs</code> 自带的 <code>dumpbin</code> 查看 <code>interface.lib</code> 的导出符号，在命令行中分别输入以下两行命令，即可把 <code>Interface.lib</code> 中的导出符号信息导出到 <code>interface.txt</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> PATH=%PATH%;<span class="string">"C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\amd64\"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dumpbin /EXPORTS Interface.lib &gt; interface.txt</span></span><br></pre></td></tr></table></figure><p>在 <code>interface.txt</code> 中搜索 <code>Test4</code>，结果什么也没所搜到，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/cannot-search-Test4-from-interface-lib.png" alt="cannot-search-Test4-from-interface-lib"></p><p>原来又是头文件与 <code>lib</code> 文件不匹配导致的问题，头文件中包含 <code>Test4</code>，但是对应的 <code>lib</code> 文件中却没有。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>示例工程已经上传到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part5-real-sovle-a-real-virtual-function-compile-error" target="_blank" rel="noopener">这里</a>，感兴趣的小伙伴儿可以自行下载验证。</p><blockquote><p><strong>说明：</strong> 我已经上传了对应的 <code>Interface.lib</code> 及 <code>Interface.dll</code>，如果想重新编译 <code>Interface.vcxproj</code>，需要先注释掉 <code>Interface.h</code> 中包含 <code>Test4</code> 的那一行。编译成功后，如果想像我一样重现链接错误，那么需要在 <code>Interface.h</code> 中把删掉的 <code>Test4</code> 哪一行添加回来并且<strong>只重新编译</strong> <code>InterfaceExe.vcxproj</code>。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果类构造函数不是导出的，如果想在外部模块实例化类对象，那么类中所有虚函数都需要是导出的</li><li><code>dumpbin</code> 是查看 <code>.lib</code> 或 <code>.dll</code> 文件中导出符号的神兵利器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一阵子，同事遇到了一个奇怪的编译问题，大概情况如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;classA&lt;/code&gt; 是模块 &lt;code&gt;A&lt;/code&gt; 中的一个类， &lt;code&gt;classA&lt;/code&gt; 没有定义构造函数，其它函数都是导出的。&lt;code&gt;B&lt;/code&gt; 模块依赖了 &lt;code&gt;A&lt;/code&gt; 模块，并且会调用 &lt;code&gt;classA&lt;/code&gt; 的接口。当在 &lt;code&gt;B&lt;/code&gt; 模块中添加了实例化 &lt;code&gt;classA&lt;/code&gt; 对象的代码的时候，报链接错误，提示找不到 &lt;code&gt;classA&lt;/code&gt; 类的某个虚函数。&lt;/p&gt;
&lt;p&gt;我帮忙看过之后发现又是虚函数相关的编译问题（正好最近在总结虚函数相关的问题），这是送上门的素材啊！&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="part5" scheme="https://bianchengnan.github.io/tags/part5/"/>
    
      <category term="编译错误" scheme="https://bianchengnan.github.io/tags/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 4 —— 又崩溃了，原来是虚函数声明顺序不一致捣的鬼</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/</id>
    <published>2024-11-09T06:37:07.000Z</published>
    <updated>2026-02-16T10:40:27.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，同事遇到了一个崩溃问题，解决后发现这个崩溃是由于在公共类中加了一个虚函数接口，但是并没有编译相关模块导致的。这种崩溃问题是老朋友了。在此之前，我已经写了几篇关于虚函数的总结，感兴趣的小伙伴儿可以查看这几篇文章：</p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/">《基础知识 | 有趣的动态转换》</a></p><p><a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a></p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/">《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》</a></p><p>本文主要关注以下两个问题，如果你已经有了很明确的答案，可以跳过本文：</p><ul><li>如果在编译 <code>A</code> 模块的时候，<code>Test</code> 类的虚函数声明的顺序是 <code>Test1, Test2, Test3</code>，但是在 <code>B</code> 模块编译的时候，<code>Test</code> 类头文件中虚函数顺序变成了 <code>Test2, Test1, Test3</code>。在 <code>B</code> 模块中调用 <code>test-&gt;Test1()</code>，调用的是哪个函数呢？</li></ul><ul><li>假设 <code>A</code> 模块代码不变，但是在编译 <code>B</code> 模块的时候，<code>Test</code> 类的头文件中又多了一个虚函数 <code>Test4()</code>，在 <code>B</code> 模块中调用 <code>test-&gt;Test4()</code>，代码可以正常编译吗？会有链接问题吗？如果可以正常编译链接，运行的时候会有问题吗？</li></ul><a id="more"></a><p>在开始验证前先回顾一下之前的结论</p><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><ul><li><p><strong>虚表及虚表中的函数地址会与构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中</p></li><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>调用虚函数的时候会先获取虚表指针，然后根据虚函数的索引从虚表中得到最终的函数地址进行调用</p></li></ul><p>更多结论请参考 <a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">上一篇文章</a>。</p><p>回顾完结论后，让我们用测试程序探寻以上两个问题的答案，先来看看示例程序的代码</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序由两个工程组成：<strong>主模块</strong>和<strong>接口模块</strong>。</p><ul><li><p>接口模块</p><p>对应的工程是 <code>Interface.vcxproj</code>。代码很简单，实现了接口，并暴露了一个导出接口供主模块使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_INTERFACE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_INTERFACE InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT__INTERFACE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Interface1::Test1(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test2(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test3(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>主模块</p><p>对应的工程是 <code>InterfaceExe.vcxproj</code>。主模块通过<strong>导出接口</strong>和<strong>直接实例化</strong>的方式获取 <code>Interface1</code> 的对象指针，然后调用 <code>Test2()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    Interface1* if2 = <span class="keyword">new</span> Interface1();</span><br><span class="line">    if1-&gt;Test2(<span class="number">0</span>);</span><br><span class="line">    if2-&gt;Test2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以上示例程序编译运行一切正常。接下来<strong>保持接口模块不变</strong>，修改代码后<strong>只重新编译主模块</strong>。</p><h2 id="验证1"><a href="#验证1" class="headerlink" title="验证1"></a>验证1</h2><p>交换 <code>Interface.h</code> 中的 <code>Test2()</code> 和 <code>Test3()</code> 的顺序，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>只重新编译主模块</strong>，查看运行结果。结果如下：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/swap-test2-test3.png" alt="swap-test2-test3"></p><p>虽然代码里调用的都是 <code>Test2()</code>，但是从输出结果可知：<code>if1</code> 调用的是 <code>Test3()</code>，<code>if2</code> 调用的是 <code>Test2()</code>。</p><p>在 <code>windbg</code> 中分别查看这两个调用对应的反汇编，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-disassembly-of-virtual-function-call.png" alt="view-disassembly-of-virtual-function-call"></p><p>可以发现，调用的都是虚表中索引为 <code>3</code> （<code>0x18 / 0x8 = 3</code>）的函数。分别查看一下虚表</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-vtable-in-windbg.png" alt="view-vtable-in-windbg"></p><p>可以发现，</p><p><code>if1</code> 对应的虚表存储在 <code>Interface</code> 模块，第 <code>3</code> 项是 <code>Interface!Interface1::Test3</code>；</p><p><code>if2</code> 对应的虚表存储在 <code>InterfaceExe</code> 模块，第 <code>3</code> 项是 <code>InterfaceExe!Interface1::Test2</code>。</p><p>在编译 <code>Interface</code> 模块时，由于 <code>GetInterface()</code> 内部会调用 <code>new Interface1</code>，因此会在 <code>Interface</code> 模块中生成虚表，此时 <code>Test3()</code> 是最后一项。</p><p>在编译 <code>InterfaceExe</code> 模块时，由于会直接调用 <code>new Interface1()</code>，因此会在 <code>InterfaceExe</code> 模块中生成虚表，此时 <code>Test2()</code> 是最后一项。</p><p>在 <code>windbg</code> 中查看  <code>InterfaceExe!Interface1::Test2</code> 对应的反汇编，可以发现其最终会调用 <code>Interface!Interface1::Test2()</code>。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-disassembly-of-interfaceexe-interface1-test2.png" alt="view-disassembly-of-interfaceexe-interface1-test2"></p><blockquote><p><strong>思考：</strong> 如果 <code>Test2</code> 和 <code>Test3</code> 的参数个数或者参数类型不一致，是不是会有更严重的问题？</p><p>根据上面的分析可知，从 <code>if1</code> 调用的话会有问题，从 <code>if2</code> 调用的话没问题。</p></blockquote><h2 id="验证-2"><a href="#验证-2" class="headerlink" title="验证 2"></a>验证 2</h2><p>在  <code>Interface.h</code>  中增加一个名为 <code>Test4</code> 的接口，并在 <code>main()</code> 函数中调用之。修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，<strong>只重新编译主模块</strong>。可以<strong>正常编译链接</strong>，但是执行的时候遇到了一个异常。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-4th-function-in-vtable.png" alt="view-4th-function-in-vtable"></p><p>从上图可知，在 <code>main()</code> 函数调用 <code>Test4()</code> 时，<code>rip</code> 指向了地址 <code>00000003 19930522</code>。因为在重新编译主模块时，<code>Test4()</code> 是虚表中的第 <code>4</code> 项（从 <code>0</code> 开始），而虚表中第 <code>4</code> 项的值是 <code>00000003 19930522</code>。</p><p>因为在编译 <code>Interface.dll</code> 的时候，一共只有 <code>4</code> 项，最大索引是 <code>3</code>。而主模块中的调用代码却尝试访问虚表中的第 <code>4</code> 项，而第 4 项的内容是随机的，所以在执行的时候发生了异常。</p><p>根据以上验证结果可知，<strong>编译器会根据头文件中的顺序生成虚函数调用代码</strong>，如果与虚函数所属模块生成时的顺序不一致，很可能调用的是不同的函数，行为是未定义的。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>示例工程已经上传到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part4-what-will-happen-if-virtual-function-reordered" target="_blank" rel="noopener">这里</a>了，感兴趣的小伙伴儿可以自行下载，根据 <code>验证 1</code> 和 <code>验证 2</code> 中的修改方式手动修改代码，进行验证。</p><blockquote><p><strong>务必注意：</strong> 修改完代码后不要重新编译 <code>Interface</code> 工程，只重新编译 <code>InterfaceExe</code> 工程！</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>编译器会根据头文件中的顺序生成虚函数调用代码</strong>，如果与虚函数所属模块生成时的顺序不一致，很可能调用的是不同的函数，行为是未定义的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一阵子，同事遇到了一个崩溃问题，解决后发现这个崩溃是由于在公共类中加了一个虚函数接口，但是并没有编译相关模块导致的。这种崩溃问题是老朋友了。在此之前，我已经写了几篇关于虚函数的总结，感兴趣的小伙伴儿可以查看这几篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/&quot;&gt;《基础知识 | 有趣的动态转换》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/&quot;&gt;《基础知识 | C++ 虚函数简介》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/&quot;&gt;《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/&quot;&gt;《基础知识 | 函数基础 1 —— 基本概念 &amp;amp; 如何调用外部模块的函数》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/&quot;&gt;《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/&quot;&gt;《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要关注以下两个问题，如果你已经有了很明确的答案，可以跳过本文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在编译 &lt;code&gt;A&lt;/code&gt; 模块的时候，&lt;code&gt;Test&lt;/code&gt; 类的虚函数声明的顺序是 &lt;code&gt;Test1, Test2, Test3&lt;/code&gt;，但是在 &lt;code&gt;B&lt;/code&gt; 模块编译的时候，&lt;code&gt;Test&lt;/code&gt; 类头文件中虚函数顺序变成了 &lt;code&gt;Test2, Test1, Test3&lt;/code&gt;。在 &lt;code&gt;B&lt;/code&gt; 模块中调用 &lt;code&gt;test-&amp;gt;Test1()&lt;/code&gt;，调用的是哪个函数呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;假设 &lt;code&gt;A&lt;/code&gt; 模块代码不变，但是在编译 &lt;code&gt;B&lt;/code&gt; 模块的时候，&lt;code&gt;Test&lt;/code&gt; 类的头文件中又多了一个虚函数 &lt;code&gt;Test4()&lt;/code&gt;，在 &lt;code&gt;B&lt;/code&gt; 模块中调用 &lt;code&gt;test-&amp;gt;Test4()&lt;/code&gt;，代码可以正常编译吗？会有链接问题吗？如果可以正常编译链接，运行的时候会有问题吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="part4" scheme="https://bianchengnan.github.io/tags/part4/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part3-call-unexported-virtual-function-of-another-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part3-call-unexported-virtual-function-of-another-module/</id>
    <published>2024-09-14T06:37:07.000Z</published>
    <updated>2026-02-16T10:40:27.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在上篇文章 <a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a>中，我们明白了一个事实 —— 可以在不依赖外部模块的情况下通过类对象指针调用其<strong>虚函数</strong>。</p><p>但是遗留了几个问题，如下：</p><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li></ul><ul><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p></li><li><p>问题 4：如果在 <code>Interface1</code>  中声明了未导出的构造函数，上述代码能编译通过吗？</p></li><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p></li><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p></li></ul><p>本文力求把这几个问题弄清楚。如果您对以上问题已经有了答案，可以跳过本文。</p><a id="more"></a><p>我们先简单回顾一下<a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">上篇文章</a>中的代码（可以到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module" target="_blank" rel="noopener">这里</a>下载或查看）：</p><ul><li><p><code>Interface</code> 模块定义了 <code>Interface1</code> 类，并且其接口函数都是导出的。</p></li><li><p><code>GetInterface</code> 模块导出了一个接口，该接口内部会 <code>new Interface1()</code> 并返回。</p></li><li><p><code>InterfaceExe</code> 模块通过 <code>GetInterface</code> 模块的导出接口获得 <code>Interface1</code> 的指针，然后调用其虚函数。</p></li></ul><p>在解答以上几个问题前，我们先查看以下几种情况编译器生成的汇编代码。</p><blockquote><p><strong>说明：</strong> </p><ol><li>本文查看的是 <code>release</code> 版本关闭优化后的汇编代码，比 <code>debug</code> 版本更简洁明了</li><li>下文中提到的 <strong>定义</strong> 指的是函数的声明和实现在一起</li></ol></blockquote><h2 id="情况-1"><a href="#情况-1" class="headerlink" title="情况 1"></a>情况 1</h2><p>注释掉上篇文章代码中对 <code>if1-&gt;Test4(0);</code> 的调用。编译并查看反汇编代码，重点关注构造函数及虚表的存储位置。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case1-getinterface-constructor-vftable.png" alt="case1-getinterface-constructor-vftable"></p><p>可以发现 <code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中。虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><h2 id="情况-2"><a href="#情况-2" class="headerlink" title="情况 2"></a>情况 2</h2><p>在 <code>情况 1</code> 代码的基础上进行如下修改：</p><ul><li><p>在头文件<strong>定义</strong>构造函数（注意：头文件中既包含声明又包含实现）</p></li><li><p>在头文件<strong>定义</strong>一个名为 <code>Test5()</code> 的虚函数</p></li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Interface1() &#123;&#125;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="查看构造函数及虚表"><a href="#查看构造函数及虚表" class="headerlink" title="查看构造函数及虚表"></a>查看构造函数及虚表</h3><p>编译运行，跟踪反汇编代码。可以发现，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中。虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-getinterface-constructor-vftable.png" alt="case2-getinterface-constructor-vftable"></p><h3 id="查看虚函数汇编代码"><a href="#查看虚函数汇编代码" class="headerlink" title="查看虚函数汇编代码"></a>查看虚函数汇编代码</h3><p>挑几个典型的虚函数，查看其反汇编代码。</p><ul><li>先来看看 <code>InterfaceBase::scalar deleting destructor</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interfacebase-destructor.png" alt="case2-interfacebase-destructor"></li></ul><ul><li>再来看看 <code>Interface1::scalar deleting destructor</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-destructor.png" alt="case2-interface1-destructor"></li></ul><ul><li><p>再来看看 <code>Interface1::Test1()</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-test1.png" alt="case2-interface1-test1"></p><p>可以发现，<code>GetInterface</code> 模块中的 <code>Interface1::Test1()</code> 会调用 <code>Interface</code> 模块导出的  <code>Interface1::Test1()</code>。</p></li></ul><ul><li>再来看看 <code>Interface1::Test5()</code>的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-test5.png" alt="case2-interface1-test5"></li></ul><p>以上几个函数有一个共同特点：所有函数的实现代码都在 <code>GetInterface</code> 模块中。我是怎么知道的？根据输出结果判断的，输出结果中，<code>!</code> 前面的部分是模块名。比如，<code>GetInterface!Interface1::Test5</code>，对应的模块是 <code>GetInterface</code>。</p><blockquote><p><strong>小贴士：</strong> 还可以根据 <code>lma address</code> 来查找某个地址所属的模块</p></blockquote><h3 id="两种编译报错的情况"><a href="#两种编译报错的情况" class="headerlink" title="两种编译报错的情况"></a>两种编译报错的情况</h3><ul><li>去掉 <code>Test2()</code> 的导出标识，再编译，会报链接错误，如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-test2-not-export-link-error.png" alt="case2-test2-not-export-link-error"></li></ul><ul><li>如果把 <code>Interface1</code> 的构造函数的定义移动到 <code>Interface.cpp</code> 中，头文件中只保留声明，也会报链接错误，如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-constructor-implement-in-cpp-link-error.png" alt="case2-constructor-implement-in-cpp-link-error"></li></ul><p>  其实，这两个错误有共性：</p><ol><li><p>都没有导出标识</p></li><li><p>实现和声明分离</p><p>实现在 <code>Interface.cpp</code> 中，最终会编译到 <code>Interface</code> 模块，而不是 <code>GetInterface</code> 模块</p></li><li><p>都会被 <code>GetInterface</code> 模块用到</p><ul><li>在 <code>new Interface()</code> 时会调用构造函数</li><li>在构造函数调用时会初始化虚表指针，指向虚表。虚表需要记录 <code>Test2()</code> 的地址，而 <code>Test2()</code> 在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址</li></ul></li></ol><blockquote><p><strong>说明：</strong> <code>情况 1</code> 的构造函数的代码是编译器自动生成的，与 <code>情况 2</code> 的构造函数代码是一样的。</p></blockquote><h2 id="情况-3"><a href="#情况-3" class="headerlink" title="情况 3"></a>情况 3</h2><p>在 <code>情况 2</code> 代码的基础上进行如下修改：</p><ul><li>为构造函数增加导出标识，并且把实现移动到 <code>Interface.cpp</code> 中</li><li>去掉其它函数的导出标识。只保留 <code>Test3()</code> 的导出标识</li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="title">Interface1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line">Interface1::Interface1()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看构造函数及虚表-1"><a href="#查看构造函数及虚表-1" class="headerlink" title="查看构造函数及虚表"></a>查看构造函数及虚表</h3><p>编译运行，跟踪反汇编代码。可以发现，<code>GetInterface!GetInterface()</code> 调用的构造函数是从 <code>Interface</code> 模块导入的。</p><p><code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case3-getinterface-constructor-vftable.png" alt="case3-getinterface-constructor-vftable"></p><blockquote><p><strong>注意：</strong> </p><ul><li><p>虚表中的所有函数的地址都属于 <code>Interface</code> 模块，与 <code>情况 2</code> 不一样。</p></li><li><p>虽然 <code>Test3()</code> 是导出的，但是虚表中保存的 <code>Test3</code> 的地址是 <code>Interface</code> 模块的。</p></li><li><p>注意 <code>Test5()</code>。在 <code>情况 2</code> 中，虚表中保存的 <code>Test5()</code> 的地址是在 <code>GetInterface</code> 模块中的，而且不会像其它函数一样调用 <code>Interface</code> 模块中的函数。在  <code>情况 3</code> 中，虚表中保存的 <code>Test5()</code> 的地址在 <code>Interface</code> 模块中。</p></li></ul><p>可以猜测，因为构造函数被导出了，没有必要在外部模块创建虚表了。</p></blockquote><h2 id="情况-4"><a href="#情况-4" class="headerlink" title="情况 4"></a>情况 4</h2><p>在 <code>情况 3</code> 代码的基础上进行如下修改：</p><ul><li>去掉所有函数的导出标识</li><li>增加一个名为 <code>ExportInterface</code> 的导出接口，返回 <code>Interface1</code> 对象指针</li><li>修改 <code>GetInterface.cpp</code> 中的 <code>GetInterface</code> 接口，直接调用 <code>ExportInterface()</code></li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.h </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Interface1();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExportInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，跟踪反汇编代码。可以发现，与 <code>情况 3</code> 基本一致。<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case4-getinterface-constructor-vftable.png" alt="case4-getinterface-constructor-vftable"></p><h2 id="情况-5"><a href="#情况-5" class="headerlink" title="情况 5"></a>情况 5</h2><p>在 <code>情况 2</code> 代码的基础上进行如下修改：</p><ul><li>在 <code>Interface1.h</code> 中声明导出接口 <code>ExportInterface</code></li><li>在 <code>Interface1.cpp</code> 中实现 <code>ExportInterface</code></li><li>在 <code>GetInterface.h</code> 中增加导出接口 <code>GetInterface1</code></li><li>在 <code>GetInterface.cpp</code> 中实现 <code>GetInterface1</code></li><li>在 <code>InterfaceExe.cpp</code> 调用这两个接口得到接口指针</li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.h </span></span><br><span class="line"><span class="function">DLL_EXPORT InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.h </span></span><br><span class="line"><span class="function">DLL_EXPORT_GET InterfaceBase* <span class="title">GetInterface1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExportInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterfaceBase* base = GetInterface();</span><br><span class="line">    InterfaceBase* base1 = GetInterface1();</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(base);</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if1-&gt;Test4(0);</span></span><br><span class="line"></span><br><span class="line">    FreeInterface(if1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看，<code>GetInterface()</code> 相关的反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case5-getinterface-constructor-vftable.png" alt="case5-getinterface-constructor-vftable"></p><p>从上图可以发现，与 <code>情况 2</code> 是一样，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中，虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><p>再来看看 <code>GetInterface1()</code> 相关的反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case5-getinterface1-constructor-vftable.png" alt="case5-getinterface1-constructor-vftable"></p><p>从上图可以发现，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p>简单整理如下：</p><ul><li><p><code>GetInterface!GetInterface()</code> 内部会调用 <code>new Interface1</code>，进而导致 <code>Interface1</code> 的构造函数在 <code>GetInterface</code> 模块中被调用。对应的虚表及虚表中的函数地址都存储在 <code>GetInterface</code> 模块中。</p></li><li><p><code>GetInterface!GetInterface1()</code> 内部会调用 <code>Interface!ExportInterface()</code>，而 <code>Interface!ExportInterface()</code> 内部会调用 <code>new Interface1</code>， 最终 <code>Interface1</code> 的构造函数在 <code>Interface</code> 模块中被调用。对应的虚表及虚表中的函数地址都存储在 <code>Interface</code> 模块中。</p></li></ul><p>因此，可以得到这样的结论： <strong>虚表及虚表中的函数地址会跟构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中。</p><p>有了以上基础，就可以很顺利的回答之前的问题了，我们依次来看看每个问题。</p><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p><p><strong>答：</strong> 参考 <code>情况 1</code>，<code>Interface1</code> 与 <code>InterfaceBase</code> 的构造函数、虚表以及虚表中的函数都保存在  <code>GetInterface</code> 模块中。</p><blockquote><p><strong>小贴士：</strong> 可以推测，如果有另外一个类似 <code>GetInterface</code> 的模块，相应的内容在那个模块中也会生成一份。</p></blockquote></li></ul><ul><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p><p><strong>答：</strong> 参考 <code>情况 1</code>，虚表与构造函数一样保存在 <code>GetInterface</code> 模块中。</p></li></ul><ul><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p><p><strong>答：</strong> 不能。参考 <code>情况 2</code> 中提到的两种编译报错的情况。</p><p>在没有声明构造函数的情况下，编译器生成的构造函数代码和虚表都会保存在 <code>GetInterface</code> 模块中。</p><p>在构造函数调用时会初始化虚表指针，指向虚表。虚表需要记录每个虚函数的地址，而这些虚函数在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址，故报链接错误。</p></li></ul><ul><li><p>问题 4：如果在 <code>Interface1</code>  中声明了<strong>未导出</strong>的构造函数，上述代码能编译通过吗？</p><p><strong>答：</strong> 需要根据构造函数定义的位置判断</p><ul><li><p>如果构造函数的定义也在头文件中，则可以正常编译。</p><p>因为编译后构造函数的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果构造函数的定义在源文件中而且没导出，会报链接错误。</p><p>因为在 <code>GetInterface</code> 模块中调用 <code>new Interface</code> 的时候，会调用 <code>Interface</code> 的构造函数，但是在 <code>GetInterface</code> 模块中找不到其实现代码。</p></li></ul></li></ul><ul><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p><p><strong>答：</strong> 与 <code>问题 4</code> 一样，需要根据 <code>InterfaceBase::Test1()</code> 定义的位置判断</p><ul><li><p>如果 <code>InterfaceBase::Test1()</code> 的定义也在头文件中，则可以正常编译。</p><p>因为编译后 <code>InterfaceBase::Test1()</code> 的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果 <code>InterfaceBase::Test1()</code> 的定义在源文件中而且没导出，会报链接错误。</p><p><code>InterfaceBase::Test1()</code> 的实现代码保存在 <code>Interface</code> 模块中。<code>InterfaceBase</code> 的虚表需要记录 <code>InterfaceBase::Test1()</code> 的地址，而 <code>InterfaceBase::Test1()</code> 在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址，会报链接错误。</p></li></ul></li></ul><ul><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p><p>答： 与 <code>问题 4</code>、<code>问题 5</code> 一样，需要根据析构函数定义的位置判断</p><ul><li><p>如果析构函数的定义也在头文件中，则可以正常编译。</p><p>因为编译后析构函数的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果析构函数的定义在源文件中而且没导出，会报链接错误。</p><p>析构函数最终会保存在 <code>Interface</code> 模块中。当调用 <code>GetInterface</code> 模块中的  <code>FreeInterface()</code> 时，该函数内部会调用 <code>delete</code>，而 <code>delete</code> 内部会调用析构函数，但是在 <code>GetInterface</code> 模块中没有实现，会报链接错误。</p></li></ul><blockquote><p><strong>友情提示：</strong> </p><ol><li>如果基类的析构函数是虚函数，子类的析构函数即使不加 <code>virtual</code> 关键字也是虚的！</li><li>如果一个类被设计为基类并且其析构函数是非虚的，这是一个 <code>bad design</code>， 《effective c++》条款 7 中讲过，感兴趣的朋友可以参考</li></ol></blockquote></li></ul><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>我已经将以上几种情况对应的工程源码上传到个人仓库中了，可以到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part3-call-unexported-virtual-function-of-another-module" target="_blank" rel="noopener">这里</a>下载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>虚表及虚表中的函数地址会与构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中</li></ol><ol start="2"><li>如果 <code>classA</code> 所有函数都定义在头文件中，那么 <code>B</code> 模块不需要依赖 <code>A</code> 模块，因为 <code>classA</code> 的所有实现代码都在 <code>B</code> 中了</li></ol><ol start="3"><li><p>在构造函数调用时会初始化虚表指针，指向虚表。必须能解析每个虚函数的地址，否则会报链接错误。</p><p>务必注意报错的时机 —— <strong>在编译构造函数的时候报错，而不是编译虚函数调用代码的时候报错！</strong></p></li></ol><ol start="4"><li><p>如果在 <code>B</code> 模块中已经拿到了 <code>A</code> 模块中 <code>classA</code> 的对象指针，可以在 <code>B</code> 模块调用其虚函数，不需要关心虚函数是否导出。</p><p>既然已经拿到了对象指针，说明构造函数已经成功执行了，虚表已经保存好了虚函数的地址。</p></li></ol><ol start="5"><li><p>如果想在 <code>B</code> 模块中获取 <code>A</code> 模块中 <code>classA</code> 的对象，有两种方法：</p><ol><li><p><code>A</code> 模块导出一个返回 <code>classA</code> 对象的指针的接口，<code>B</code> 模块通过 <code>A</code> 模块的导出接口获取</p></li><li><p>直接在 <code>B</code> 模块中实例化 <code>classA</code> 对象。通过 <code>auto pA = new classA();</code> 或者 <code>classA a;</code></p></li></ol></li></ol><ol start="6"><li><p>如果想在 <code>B</code> 模块中<strong>直接</strong>实例化 <code>A</code> 模块中 <code>classA</code> 的对象，需要能在 <code>B</code> 模块中访问 <code>classA</code> 的构造函数，有两种方法：</p><ol><li><p><code>classA</code> 的构造函数是导出的 <strong>并且</strong> <code>B</code> 模块依赖 <code>A</code> 模块</p></li><li><p><code>classA</code> 的构造函数定义在头文件中（或者不声明构造函数，编译器会自动生成一个）</p></li></ol></li></ol><ol start="7"><li><p>如果 <code>A</code> 模块中 <code>classA</code> 的构造函数是未导出的，并且 <code>classA</code> 中有虚函数，要想在 <code>B</code> 模块中直接实例化 <code>classA</code>，需要满足：</p><ol><li><p>构造函数定义在头文件中</p></li><li><p>虚函数或者<strong>是导出的</strong>或者<strong>定义在头文件中</strong></p></li></ol></li></ol><ol start="8"><li>如果想在 <code>B</code> 模块中调用 <code>A</code> 模块中 <code>classA</code> 的成员函数（例如， <code>delete pA</code> 会调用 <code>classA</code> 的析构函数），那么 <code>classA</code> 的成员函数<ul><li>或者是虚的</li><li>或者是导出的</li><li>或者定义在头文件中</li></ul></li></ol><ol start="9"><li>如果链接错误是由找不到析构函数导致的，删除导致析构函数调用的代码，就不会报错了</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《effective c++》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在上篇文章 &lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/&quot;&gt;《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》&lt;/a&gt;中，我们明白了一个事实 —— 可以在不依赖外部模块的情况下通过类对象指针调用其&lt;strong&gt;虚函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是遗留了几个问题，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题 1：&lt;code&gt;Interface1&lt;/code&gt; 类中没有声明构造函数，编译器生成的构造函数保存在哪里？&lt;code&gt;GetInterface&lt;/code&gt; 模块还是 &lt;code&gt;Interface&lt;/code&gt; 模块？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 2：&lt;code&gt;Interface1&lt;/code&gt; 的虚表保存在哪里？&lt;code&gt;GetInterface&lt;/code&gt; 模块还是 &lt;code&gt;Interface&lt;/code&gt; 模块？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题 3：如果去掉 &lt;code&gt;Interface1&lt;/code&gt; 中虚函数的导出符号，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 4：如果在 &lt;code&gt;Interface1&lt;/code&gt;  中声明了未导出的构造函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 5：如果 &lt;code&gt;InterfaceBase::Test1()&lt;/code&gt; 不是纯虚函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 6：如果 &lt;code&gt;InterfaceBase&lt;/code&gt; 的析构函数不是虚函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文力求把这几个问题弄清楚。如果您对以上问题已经有了答案，可以跳过本文。&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="part3" scheme="https://bianchengnan.github.io/tags/part3/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/</id>
    <published>2024-07-27T06:37:07.000Z</published>
    <updated>2026-02-16T10:40:27.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一段日子，同事遇到了一个奇怪的现象 —— <code>B</code> 模块调用了 <code>A</code> 模块某个类的成员函数，没有依赖 <code>A</code> 模块，编译时没有报错。而 <code>C</code> 模块也调用了 <code>A</code> 模块中同一个类的成员函数，没有依赖 <code>A</code> 模块，编译时却报了链接错误。</p><p>简单语音沟通后觉得不太可能。用了 <code>A</code> 模块的函数，却不依赖 <code>A</code> 模块，有点儿不讲道理！</p><p>因为当时我没在电脑前，跟同事简单沟通了几个可以设置库依赖的位置，结果都没有发现对应的依赖项。</p><p>心里越发觉得不可思议，难道 <code>B</code> 模块是通过其它方式依赖 <code>A</code> 模块的？正常情况下，如果 <code>B</code> 模块依赖 <code>A</code> 模块，一定可以在 <code>B</code> 模块的导入表中看到 <code>A</code> 模块相关的记录。于是建议同事查看 <code>B</code> 模块的导入表，但是同事不太熟悉。因为项目比较急，遂建议同事在 <code>C</code> 模块中添加对 <code>A</code> 模块的依赖，先解决项目问题，后面有机会再调查具体原因。</p><p>直到最近才有时间调查这个问题，结果发现这个问题非常有意思 —— <code>B</code> 模块确实没有依赖 <code>A</code> 模块（<code>B</code> 模块的导入表中确实没发现 <code>A</code> 模块的相关项），但是 <code>B</code> 模块确实调用了 <code>A</code> 模块中的函数，而且不是通过 <code>LoadLibrary() + GetProcAddress()</code> 的方式调用的。</p><p>本文主要关注以下问题，如果你已经有了答案，可以跳过本文。</p><ul><li><code>B</code> 模块在什么情况下可以调用 <code>A</code> 模块中的函数，但是却不依赖 <code>A</code> 模块？</li></ul><a id="more"></a><blockquote><p><strong>约定：</strong></p><ol><li><p>本文不考虑通过 <code>GetProcAddress()</code> 获取函数指针后再调用的情况</p></li><li><p>虚函数表在本文中简称<strong>虚表</strong>，指向虚表的指针简称<strong>虚表指针</strong></p></li></ol></blockquote><p>为了更好的研究这个问题，我特意写了示例程序</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序由三个工程组成：接口模块、获取接口模块和主模块。</p><ul><li><p>接口模块 </p><p>对应的工程是 <code>Interface.vcxproj</code>，代码很简单，声明并实现了一些接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DLL_INTERFACE_EXPORT</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_INTERFACE_EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Interface1::Test1(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test2(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test3(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test4(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>获取接口模块</p><p>对应的工程是 <code>GetInterface.vcxproj</code>，依赖<strong>接口模块</strong>。代码非常简单，只暴露了一个接口，用来获取接口对象指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DLL_GETINTERFACE_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_GET __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_GET __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_GET InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DLL_EXPORT_GET <span class="keyword">void</span> <span class="title">FreeInterface</span><span class="params">(InterfaceBase*)</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_GETINTERFACE_EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GetInterface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeInterface</span><span class="params">(InterfaceBase* if1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> if1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>主模块</p><p>对应的工程是 <code>InterfaceExe.vcxproj</code>，只依赖<strong>获取接口模块</strong>，不依赖<strong>接口模块</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../GetInterface/GetInterface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterfaceBase* base = GetInterface();</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(base);</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    FreeInterface(if1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>示例工程已经上传到本篇博客对应的资料仓库里，感兴趣的小伙伴儿可以自行到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module" target="_blank" rel="noopener">这里</a>下载验证。</p><p>在以上代码中：</p><ol><li><p><code>if1-&gt;Test4()</code> <strong>会</strong>导致链接错误</p><p>报错信息如下：</p><p><code>LNK2019 无法解析的外部符号 &quot;__declspec(dllimport) public: void __cdecl Interface1::Test4(int)&quot; (__imp_?Test4@Interface1@@QEAAXH@Z)，该符号在函数 main 中被引用</code></p></li></ol><ol start="2"><li><p><code>if1-&gt;Test1()</code> <strong>不会</strong>导致链接错误。惊不惊喜？意不意外？</p><p>注释掉 <code>if1-&gt; Test4();</code> 即可顺利编译，所以可以确定 <code>if1-&gt;Test1()</code> 不会导致链接错误</p></li></ol><p>在解释之前，先回顾一下基础。</p><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><p>我之前写过一篇关于函数基础知识的总结—— <a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p>与当前问题相关的内容整理如下：</p><ul><li><p><code>B</code> 模块要想调用 <code>A</code> 模块中的函数，最重要的原则是：<code>B</code> 模块要能找到 <code>A</code> 模块函数的地址，一般情况下需要做两件事：</p><p><strong>首先</strong>，<code>A</code> 模块中的函数需要声明为导出的。导出的函数会记录在 <code>A</code> 模块的<strong>导出表</strong>中</p><p><strong>其次</strong>，通过头文件 + 库文件，让 <code>B</code> 模块依赖 <code>A</code> 模块。编译器会在 <code>B</code> 模块的<strong>导入表</strong>中添加对应项</p></li></ul><ul><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>虚函数调用是通过<strong>虚表</strong>实现的。大体调用过程如下：</p><ul><li><p>通过类对象找到虚表指针，进而找到虚表</p></li><li><p>根据头文件中虚函数的顺序得到索引</p></li><li><p>根据索引从虚表中取出函数地址进行调用</p></li></ul></li></ul><h2 id="简单解释"><a href="#简单解释" class="headerlink" title="简单解释"></a>简单解释</h2><p>下面我们尝试从虚函数的调用机制来理解编译器的行为：</p><ol><li><code>if1-&gt;Test4()</code> <strong>会</strong>导致链接错误<br>因为 <code>Test4()</code> 是普通成员函数，调用的时候，需要找到其地址。接口模块虽然导出了 <code>Test4()</code>，但是主模块并没有依赖接口模块。所以报链接错误很正常！</li></ol><ol start="2"><li><p><code>if1-&gt;Test1()</code> <strong>不会</strong>导致链接错误</p><p>已经得到了对象指针（<code>if1</code>），说明对象已经被构造好了，虚表指针已经指向了正确的虚表。因为 <code>Test1()</code> 是虚函数，调用 <code>Test1()</code> 是通过虚表进行的，直接到虚表对应的位置获取函数地址即可。 所以不会产生链接错误。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>如果 <code>B</code> 模块已经拿到了 <code>A</code> 模块中的类对象指针，通过该指针调用的类成员函数，</p><ul><li><p>如果调用的成员函数是<strong>普通函数</strong>，则 <code>B</code> 模块<strong>需要</strong>依赖 <code>A</code> 模块</p></li><li><p>如果调用的成员函数是<strong>虚函数</strong>，则 <code>B</code> 模块<strong>不需要</strong>依赖 <code>A</code> 模块</p></li></ul></li></ul><p>实际项目中遇到的正是这种情况：<code>B</code> 模块调用的是 <code>A</code> 模块中的虚函数，所以不需要依赖 <code>A</code> 模块；而 <code>C</code> 模块调用的是 <code>A</code> 模块中的普通成员函数，需要依赖 <code>A</code> 模块。至此，项目中的疑问算是彻底解开了。</p><p>这就完了？ 还有很多问题需要继续深挖……</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p></li><li><p>问题 4：如果在 <code>Interface1</code>  中声明了未导出的构造函数，上述代码能编译通过吗？</p></li><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p></li><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p></li></ul><p>争取在下一篇文章中把上面的坑都填上，<code>stay tuned~</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一段日子，同事遇到了一个奇怪的现象 —— &lt;code&gt;B&lt;/code&gt; 模块调用了 &lt;code&gt;A&lt;/code&gt; 模块某个类的成员函数，没有依赖 &lt;code&gt;A&lt;/code&gt; 模块，编译时没有报错。而 &lt;code&gt;C&lt;/code&gt; 模块也调用了 &lt;code&gt;A&lt;/code&gt; 模块中同一个类的成员函数，没有依赖 &lt;code&gt;A&lt;/code&gt; 模块，编译时却报了链接错误。&lt;/p&gt;
&lt;p&gt;简单语音沟通后觉得不太可能。用了 &lt;code&gt;A&lt;/code&gt; 模块的函数，却不依赖 &lt;code&gt;A&lt;/code&gt; 模块，有点儿不讲道理！&lt;/p&gt;
&lt;p&gt;因为当时我没在电脑前，跟同事简单沟通了几个可以设置库依赖的位置，结果都没有发现对应的依赖项。&lt;/p&gt;
&lt;p&gt;心里越发觉得不可思议，难道 &lt;code&gt;B&lt;/code&gt; 模块是通过其它方式依赖 &lt;code&gt;A&lt;/code&gt; 模块的？正常情况下，如果 &lt;code&gt;B&lt;/code&gt; 模块依赖 &lt;code&gt;A&lt;/code&gt; 模块，一定可以在 &lt;code&gt;B&lt;/code&gt; 模块的导入表中看到 &lt;code&gt;A&lt;/code&gt; 模块相关的记录。于是建议同事查看 &lt;code&gt;B&lt;/code&gt; 模块的导入表，但是同事不太熟悉。因为项目比较急，遂建议同事在 &lt;code&gt;C&lt;/code&gt; 模块中添加对 &lt;code&gt;A&lt;/code&gt; 模块的依赖，先解决项目问题，后面有机会再调查具体原因。&lt;/p&gt;
&lt;p&gt;直到最近才有时间调查这个问题，结果发现这个问题非常有意思 —— &lt;code&gt;B&lt;/code&gt; 模块确实没有依赖 &lt;code&gt;A&lt;/code&gt; 模块（&lt;code&gt;B&lt;/code&gt; 模块的导入表中确实没发现 &lt;code&gt;A&lt;/code&gt; 模块的相关项），但是 &lt;code&gt;B&lt;/code&gt; 模块确实调用了 &lt;code&gt;A&lt;/code&gt; 模块中的函数，而且不是通过 &lt;code&gt;LoadLibrary() + GetProcAddress()&lt;/code&gt; 的方式调用的。&lt;/p&gt;
&lt;p&gt;本文主要关注以下问题，如果你已经有了答案，可以跳过本文。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 模块在什么情况下可以调用 &lt;code&gt;A&lt;/code&gt; 模块中的函数，但是却不依赖 &lt;code&gt;A&lt;/code&gt; 模块？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="part2" scheme="https://bianchengnan.github.io/tags/part2/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/</id>
    <published>2024-07-12T20:37:07.000Z</published>
    <updated>2026-02-16T10:40:27.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近遇到了几个跟虚函数有关的问题，既有编译链接问题，又有运行问题，归根到底是基本功不扎实导致的问题。本文将会简单梳理一下函数相关的基本知识：</p><ul><li>函数是什么？</li><li>函数调用约定有哪些？有什么作用？</li><li>普通函数、类静态函数、类成员函数的区别是什么？</li><li>什么时候会调用构造函数，什么时候会调用析构函数？</li><li>调用虚函数与调用其它函数的区别是什么？</li><li><code>B</code> 模块如何调用 <code>A</code> 模块的函数？</li></ul><p>本文适合初学者，如果您已经有一定的开发经验，可以跳过本文。</p><a id="more"></a><h2 id="函数是什么？"><a href="#函数是什么？" class="headerlink" title="函数是什么？"></a>函数是什么？</h2><p>函数其实就是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>。一般情况下，函数编译后的二进制代码会被存储在可执行文件（又叫 <code>Portable Executive</code>，简称  <code>PE</code> ）的代码段中，程序启动时会加载到内存中。</p><p>有几个关键点需要牢记于心：</p><ol><li>每个函数的二进制代码都会存储在对应的模块中，相对模块基址一定的偏移处</li><li>模块加载到内存后会占据一段内存空间，这段内存空间中包含当前模块的函数、全局变量等</li><li>函数的虚拟地址是由 <strong>模块基址+函数相对于模块基址的偏移</strong> 决定的</li><li><strong>模块中函数地址相对于模块基址的偏移不会改变</strong>，模块的基址发生变化后，函数地址也会跟着变</li></ol><p>下图是用 <code>IDA</code> 查看 <code>ntoskrnl.exe</code> 中的函数情况。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/functions-in-module.png" alt="functions-in-module"></p><p><code>ntoskrnl.exe</code> 的基址是 <code>0x00000001 40000000</code>，每个函数相对于模块有一定的偏移。比如，<code>NtSetEvent</code> 相对于模块基址的偏移是 <code>0x00000001 406B2B60 - 0x00000001 40000000 = 0x006B2B60</code>。</p><p>如果下次启动的时候，<code>ntoskrnl.exe</code> 基址变了，<code>NtSetEvent</code> 的地址也会跟着变，但是相对于模块基址的偏移不会变。</p><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>函数调用约定有哪些？有什么作用？</p><p>在 <code>c++</code> 中，常用的调用约定有  <code>__cdecl</code>，<code>__stdcall</code>， <code>__fastcall</code>， <code>__thiscall</code>。</p><p><code>__cdecl</code> 是 <code>vs</code> 工程属性中默认的调用约定（可以在 <code>vs</code> 工程属性中设置，如下图），<code>__thiscall</code> 是类成员函数默认的调用约定，<code>Windows API</code> 一般会显式使用 <code>__stdcall</code>。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/set-default-calling-convention.png" alt="set-default-calling-convention"></p><p>调用约定的主要作用：</p><ul><li>影响函数名称，每种调用约定生成的函数名称不一样</li><li>影响参数传递方式</li><li>影响谁来平衡调用栈（调用者还是被调用者）</li></ul><h3 id="x86-程序"><a href="#x86-程序" class="headerlink" title="x86 程序"></a>x86 程序</h3><p>在 <code>x86</code> 程序中有各种调用约定，我简单的整理成了表格，如下：</p><table><thead><tr><th>调用约定</th><th>参数传递方式</th><th>谁来平衡堆栈</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-160" target="_blank" rel="noopener">__cdecl</a></td><td>所有参数通过栈传递，从右向左依次入栈，<code>ebp + 8</code> 指向第一个参数</td><td>调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/stdcall?view=msvc-160" target="_blank" rel="noopener">__stdcall</a></td><td>与 <code>__cdecl</code> 调用约定一样</td><td>被调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-160" target="_blank" rel="noopener">__fastcall</a></td><td>前两个 <code>DWORD</code> 类型的参数通过 <code>ecx</code>, <code>edx</code> 传递，其余参数从右向左依次入栈</td><td>被调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/thiscall?view=msvc-160" target="_blank" rel="noopener">__thiscall</a></td><td>对象指针通过 <code>ecx</code> 传递，其余参数与 <code>__cdecl</code> 调用约定一样通过栈传递</td><td>被调用者</td></tr></tbody></table><blockquote><p><strong>说明：</strong> <a href="https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a> 提到了更多种调用约定，感兴趣的小伙伴儿可以自行查看</p></blockquote><p>​                                                                                                                                                                                                                                                                                                                                         关于名字修饰规则可以参考《软件调试》第 <code>1</code> 版 第 <code>25</code> 章，<code>740</code> 页。</p><blockquote><p><strong>小贴士：</strong> 可以使用 <code>vs</code> 自带的工具 <code>undname.exe</code> 查看修饰前的函数名</p></blockquote><h3 id="x64-程序"><a href="#x64-程序" class="headerlink" title="x64 程序"></a>x64 程序</h3><p>在 <code>x64</code> 程序中只有一种调用约定 —— <code>__fastcall</code>。即使显式指定了调用约定，最后也会按 <code>__fastcall</code> 生成代码。</p><p>参数传递方式如下表（摘录自<a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a>）：</p><table><thead><tr><th align="left">Parameter type</th><th align="left">fifth and higher</th><th align="left">fourth</th><th align="left">third</th><th align="left">second</th><th align="right">leftmost</th></tr></thead><tbody><tr><td align="left">floating-point</td><td align="left">stack</td><td align="left">XMM3</td><td align="left">XMM2</td><td align="left">XMM1</td><td align="right">XMM0</td></tr><tr><td align="left">integer</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left">Aggregates (8, 16, 32, or 64 bits) and <strong><code>__m64</code></strong></td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left">Other aggregates, as pointers</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left"><strong><code>__m128</code></strong>, as a pointer</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr></tbody></table><p>各种典型情况下参数传递方式列举如下（摘录自同一个 <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a>，注释按习惯调整到上方了）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a in RCX, b in RDX, c in R8, d in R9, f then e pushed on stack</span></span><br><span class="line">func1(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in XMM0, b in XMM1, c in XMM2, d in XMM3, f then e pushed on stack</span></span><br><span class="line">func2(<span class="keyword">float</span> a, <span class="keyword">double</span> b, <span class="keyword">float</span> c, <span class="keyword">double</span> d, <span class="keyword">float</span> e, <span class="keyword">float</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in RCX, b in XMM1, c in R8, d in XMM3, f then e pushed on stack</span></span><br><span class="line">func3(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> c, <span class="keyword">float</span> d, <span class="keyword">int</span> e, <span class="keyword">float</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3,</span></span><br><span class="line"><span class="comment">// ptr to f pushed on stack, then ptr to e pushed on stack</span></span><br><span class="line">func4(__m64 a, __m128 b, struct c, <span class="keyword">float</span> d, __m128 e, __m128 f);</span><br></pre></td></tr></table></figure><h2 id="各种类型的函数比较"><a href="#各种类型的函数比较" class="headerlink" title="各种类型的函数比较"></a>各种类型的函数比较</h2><p>普通函数、类静态函数、类成员函数的区别是什么？</p><p>平时开发过程中，经常遇到的函数有普通函数、类静态成员函数、类成员函数（构造函数、析构函数等）。</p><p>它们的共同特点是：它们都是函数，编译后都是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>，都会保存在某个模块中。</p><p>它们最主要的区别在调用的写法上：</p><ul><li><p>调用普通函数，直接通过函数名即可</p></li><li><p>构造函数、析构函数会被自动调用</p><blockquote><p><strong>说明：</strong> 虽然是自动调用，其实是编译器生成了调用代码，不用我们手动写而已</p></blockquote></li><li><p>调用类成员函数的时候，需要通过类对象或类对象指针进行调用</p></li><li><p>调用类静态成员函数的时候需要加上类名限定</p><blockquote><p><strong>说明：</strong> 也可以通过类对象或类对象指针进行调用，编译器会自动推断类型</p></blockquote></li></ul><p>以下示例代码展示了这三种函数的调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">T1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">(CDemo*, <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T1(<span class="number">0</span>);</span><br><span class="line">    CDemo::T1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CDemo demo;</span><br><span class="line">    demo.T2(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    T2(&amp;demo, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>x64</code> 程序中，<code>T1()</code> 与 <code>CDemo::T1()</code> ，<code>T2()</code> 与 <code>CDemo::T2()</code> 是等价的，会生成同样的汇编代码。如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/function-call-disassembly-x64.png" alt="function-call-disassembly-x64"></p><p>在 <code>x86</code> 程序中，由于调用约定不同，<code>T2()</code> 与 <code>CDemo::T2()</code> 的参数传递方式不同，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/function-call-disassembly-x86.png" alt="function-call-disassembly-x86"></p><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>什么时候会调用构造函数，什么时候会调用析构函数？</p><ul><li><p>当一个类对象被构造出来的时候，会调用构造函数</p><p>比如有一个名为 <code>CTest</code> 的类。下面两句代码都会导致类构造函数被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTest t1;</span><br><span class="line">  CTest* p = <span class="keyword">new</span> CTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个类对象的生命周期结束的时候，会调用析构函数</p><p>一个对象的生命周期什么时候结束呢？有两种情况：</p><ol><li>变量超出作用域</li><li>显式调用 <code>delete</code> </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTest t1;</span><br><span class="line">  CTest* p = <span class="keyword">new</span> CTest();</span><br><span class="line">  <span class="keyword">delete</span> p; <span class="comment">// delete 内部会调用析构函数</span></span><br><span class="line">&#125; <span class="comment">// t1 会在这里被析构</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>敲黑板：</strong> 如果不在 <code>B</code> 模块中实例化 <code>A</code> 模块中的类对象，那么对 <code>B</code> 模块而言 <code>A</code> 模块的构造函数不必是导出的。析构函数也是一样的道理。</p></blockquote><h2 id="虚函数-vs-其它函数"><a href="#虚函数-vs-其它函数" class="headerlink" title="虚函数 vs 其它函数"></a>虚函数 vs 其它函数</h2><p>调用虚函数与调用其它函数的区别是什么？</p><p>我之前写过一篇关于虚函数的总结 —— <a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a>（如果图挂了可以看<a href="https://zhuanlan.zhihu.com/p/240765167" target="_blank" rel="noopener">这里</a>）。</p><p>介绍了虚函数的相关内容：虚表都包含哪些内容、虚表指针的初始化时机、虚函数是如何支持多态的。这里再简单总结一下：</p><ul><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>虚函数调用是通过虚表实现的。大体调用过程如下：</p><ul><li>通过类对象找到虚表指针，进而找到虚表</li><li>根据头文件中虚函数的顺序得到索引</li><li>根据索引从虚表中取出函数地址进行调用</li></ul></li></ul><p>调用虚函数与调用其它函数最主要的区别是：</p><p>调用普通函数的时候，会直接跳转到函数首地址；调用虚函数的时候，会通过虚表跳转到函数首地址。</p><h2 id="跨模块调用"><a href="#跨模块调用" class="headerlink" title="跨模块调用"></a>跨模块调用</h2><p><code>B</code> 模块如何调用 <code>A</code> 模块中的函数？</p><p><code>B</code> 模块要想调用 <code>A</code> 模块中的函数，最重要的原则是：<code>B</code> 模块要能找到 <code>A</code> 模块中的函数地址，一般情况下需要做两件事：</p><p><strong>首先</strong>，<code>A</code> 模块中的函数需要声明为导出的。导出的函数会记录在 <code>A</code> 模块的<strong>导出表</strong>中</p><p><strong>其次</strong>，通过头文件 + 库文件，让 <code>B</code> 模块依赖 <code>A</code> 模块。编译器会在 <code>B</code> 模块的<strong>导入表</strong>中添加对应项</p><blockquote><p><strong>说明：</strong> 还可以通过 <code>GetAddressProc()</code> 找到函数地址进行调用</p></blockquote><p><code>B</code> 模块依赖 <code>A</code> 模块，在 <code>vs</code> 中有三种设置方法：</p><h2 id="解决库依赖的三种方法"><a href="#解决库依赖的三种方法" class="headerlink" title="解决库依赖的三种方法"></a>解决库依赖的三种方法</h2><ol><li><p>在代码中使用 <code>#pragma comment(lib, libA)</code> 进行依赖</p><p>可以不修改工程配置，直接在代码中设置依赖</p></li></ol><ol start="2"><li><p>在 <code>B</code> 模块对应项目的链接器设置中，添加对项目 <code>A</code> 的依赖</p><p>这是比较常规的做法，设置方法如下图：<img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/add-lib-in-project-link-option.png" alt="add-lib-in-project-link-option"></p></li></ol><ol start="3"><li><p>在 <code>B</code> 模块对应项目的引用配置中添加对项目 <code>A</code> 的引用</p><p>此方法最简单，最省心，甚至都不用考虑被依赖的库文件的生成路径！<img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/add-project-reference.png" alt="add-project-reference"></p></li></ol><blockquote><p><strong>注意：</strong> 前两种方法，可能需要在附加库目录中配置 <code>libA</code> 的路径，第三种方法不用。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>函数是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>，会被存储在模块中的某个位置，<strong>相对于模块基址的偏移不会改变</strong>，模块的基址发生变化后，函数地址也会跟着变</li><li>调用约定会影响编译后的函数名、参数传递方式、谁来平衡调用栈</li><li><code>x86</code> 程序有各种调用约定，<code>x64</code> 程序只有 <code>__fastcall</code> 一种调用约定</li><li>调用函数的两个关键点是：<ul><li>找到函数地址</li><li>明确参数传递方式（由调用约定决定）</li></ul></li><li>调用外部模块的函数，需要依赖对应的库。在 <code>vs</code> 中解决库依赖有三种方法：<ul><li>在代码中使用 <code>#pragma comment(lib, libA)</code> 进行依赖</li><li>在 <code>B</code> 模块对应项目的链接器设置中，添加对项目 <code>A</code> 的依赖</li><li>在 <code>B</code> 模块对应项目的引用配置中添加对项目 <code>A</code> 的引用</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>《软件调试》第一版 </p></li><li><p>调用约定相关参考链接</p><ul><li><a href="https://learn.microsoft.com/en-us/cpp/cpp/calling-conventions?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/cpp/calling-conventions?view=msvc-160</a></li><li><a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160</a></li><li><a href="https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近遇到了几个跟虚函数有关的问题，既有编译链接问题，又有运行问题，归根到底是基本功不扎实导致的问题。本文将会简单梳理一下函数相关的基本知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数是什么？&lt;/li&gt;
&lt;li&gt;函数调用约定有哪些？有什么作用？&lt;/li&gt;
&lt;li&gt;普通函数、类静态函数、类成员函数的区别是什么？&lt;/li&gt;
&lt;li&gt;什么时候会调用构造函数，什么时候会调用析构函数？&lt;/li&gt;
&lt;li&gt;调用虚函数与调用其它函数的区别是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 模块如何调用 &lt;code&gt;A&lt;/code&gt; 模块的函数？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文适合初学者，如果您已经有一定的开发经验，可以跳过本文。&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="part1" scheme="https://bianchengnan.github.io/tags/part1/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（下）</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/</id>
    <published>2024-06-08T09:39:23.000Z</published>
    <updated>2026-02-16T10:40:27.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在前面两篇文章中，应该算是彻底理清了项目中存在的两个问题。感兴趣的小伙伴儿可以参考<a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1">《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》</a>和 <a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2">《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）》</a>。</p><p>在上篇文章的末尾提到一种情况</p><blockquote><p>如果在 <code>LoadDlls.exe</code> 中也显式加载了 <code>dll3.dll</code>，还会不会崩溃呢？答案是<strong>可能崩溃，也可能不崩溃</strong>。</p><p>因为 <code>RegisterInitCallback()</code>内部更新数据时使用的是 <code>map.insert()</code>，这会导致一个问题 —— 如果 <code>map</code> 中已经存在相同的 <code>key</code>，那么 <code>insert()</code> 会失败，不会更新数据。</p><p>试想，如果显式加载 <code>dll3.dll</code> 成功，但是 <code>dll3.dll</code> 的基址变了。<code>map</code> 中保存的还是旧的无效地址，而不是新函数地址。</p><p>如果 <code>dll3.dll</code> 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常<strong>“幸运”</strong>的正常运行。 </p></blockquote><p>本文通过实战来验证上文中的结论，什么情况下会崩溃，什么情况下不崩溃。</p><a id="more"></a><h2 id="显式加载-dll3-dll"><a href="#显式加载-dll3-dll" class="headerlink" title="显式加载 dll3.dll"></a>显式加载 dll3.dll</h2><p>修改 <code>LoadDlls</code> 工程中的 <code>main()</code> 函数代码，使其加载 <code>dll1.dll</code>、<code>dll2.dll</code> 和 <code>dll3.dll</code>。修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="string">"dll3.dll"</span>, <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本以为这样修改后，应该偶尔会崩溃（因为默认开启了 <code>ASLR</code>，模块的加载基址应该会随机才对）。结果发现，每次运行都不崩溃，而且功能一切正常，着实有些出乎意料。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/function-normal.png" alt="function-normal"></p><p>看来 <code>dll3.dll</code> 每次都能加载到上一次被加载的基址。那怎么才能让 <code>dll3.dll</code> 加载到其它基址呢？</p><h2 id="改变加载基址"><a href="#改变加载基址" class="headerlink" title="改变加载基址"></a>改变加载基址</h2><p>最朴素的想法是，如果在显式加载 <code>dll3.dll</code> 之前，又加载了很多其它 <code>dll</code>，把原本 <code>dll3.dll</code> 加载的基址占用掉，那么再次加载 <code>dll3.dll</code> 的基址肯定会发生变化，大概率会崩溃。</p><p>按照这个思路，修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="string">"dll4.dll"</span>, <span class="string">"dll3.dll"</span>, <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完成后，把 <code>dll1.dll</code> 复制一份，修改名字为 <code>dll4.dll</code>，然后运行 <code>LoadDlls.exe</code>，果然崩溃了。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/app-crashed.png" alt="app-crashed"></p><blockquote><p><strong>小提示：</strong> 如果删除 <code>dll4.dll</code>，再次运行程序，又不崩溃了</p></blockquote><p>调查一下崩溃原因，看看是不是跟我们预期的一样。</p><h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><p>用 <code>windbg</code> 打开转储文件后，点击 <code>!analyze -v</code>，分析结果如下：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/windbg-analyze-v.png" alt="windbg-analyze-v"></p><p>可以发现在执行 <code>movsxd rax,dword ptr [rax+4]</code> 的时候崩溃了，而且这段反汇编代码属于 <code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush()</code>。在 <code>windbg</code> 中查看相关反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-disassembly-of-flush.png" alt="view-disassembly-of-flush"></p><p>从上图可知，<code>rax</code> 的值最开始来源于 <code>rsp+0x50</code>（<code>mov rax, qword ptr [rsp+50h]</code>），而 <code>rsp+0x50</code> 的值又来源于 <code>rcx</code>（<code>mov qword ptr [rsp+8], rcx</code>，<code>sub rsp, 48h</code>）。</p><p>在遍历调用 <code>s_init_callbacks</code> 保存的回调函数的时候并不会使用 <code>rcx</code>，因此 <code>rcx</code> 的值是是随机的，那么使用了 <code>rcx</code> 而崩溃是可以理解的。</p><p>还有一个小问题：为什么 <code>dll2!Init()</code> 会调用 <code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush()</code> 呢？</p><h2 id="进一步调查"><a href="#进一步调查" class="headerlink" title="进一步调查"></a>进一步调查</h2><p>使用命令 <code>dx dll2!s_init_callbacks</code> 查看  <code>dll2!s_init_callbacks</code> 的内容，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-s_init_callbacks.png" alt="view-s_init_callbacks"></p><p>可以发现 <code>dll2!s_init_callbacks</code> 中保存的函数地址是 <code>0x7ffd 929e12e4</code>，对应的函数是 <code>dll4!@ILT+735(?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ)</code>，该函数最终会调用<code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush</code>。</p><p>使用 <code>lmm dll*</code> 查看相关模块加载情况，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-modules.png" alt="view-modules"></p><p>从上图可知，<code>dll4.dll</code> 的基址与已经卸载的 <code>dll3.dll</code> 的基址是一样的，都是 <code>00007ffd 929d0000</code>，新加载的 <code>dll3.dll</code> 的基址已经变成了 <code>00007ffd 8c540000</code>。</p><p><code>s_init_callbacks</code> 中保存的函数地址相对于模块基址的偏移是 <code>0x7ffd 929e12e4 - 00007ffd 929d0000 = 0x112e4</code>，换算成在 <code>dll3.dll</code> 中的地址是 <code>0x00007ffd 8c540000 + 0x112e4 = 0x00007ffd 8c5512e4</code>。在 <code>windbg</code> 中使用 <code>ln 0x00007ffd8c5512e4</code> 查看于该地址对应的符号，输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; ln <span class="number">0x00007ffd8c5512e4</span></span><br><span class="line">Browse <span class="keyword">module</span></span><br><span class="line">Set bu breakpoint</span><br><span class="line"></span><br><span class="line">(<span class="number">00007f</span>fd`<span class="number">8</span>c5512e4)   dll3!ILT+<span class="number">735</span>(?Dll3InitCallbackYAXXZ)   |  (<span class="number">00007f</span>fd`<span class="number">8</span>c5512e9)   dll3!ILT+<span class="number">740</span>(?flush?$basic_ostreamDU?$char_traitsDstdstdQEAAAEAV12XZ)</span><br><span class="line">Exact matches:</span><br></pre></td></tr></table></figure><p>可以发现与 <code>dll3!ILT+735(?Dll3InitCallbackYAXXZ)</code> 完全匹配。</p><p>至此，所有疑问都已经解开了。<code>dll3.dll</code> 加载的时候会注册回调函数，由于异常 <code>dll3.dll</code> 会被自动卸载，但是注册回调函数并没有取消注册，<code>dll4.dll</code> 紧接着被加载到了 <code>dll3.dll</code> 旧基址，再次加载 <code>dll3.dll</code>，新的 <code>dll3.dll</code> 被加载到了其他位置。<code>dll3.dll</code> 最开始注册的回调函数变成了 <code>dll4.dll</code> 中的函数。</p><p>因为这是实际项目中遇到的问题，非常有代表性，而且崩溃的代码与业务代码毫不相干，很难查！</p><p>总结下来，主要有两大问题：</p><ol><li>在全局变量的构造函数中调用 <code>LoadLibrary()</code> 加载新的 <code>dll</code>，这是很危险的操作，应该尽量避免。</li><li>当使用 <code>insert()</code> 而不是 <code>operator[]</code> 向 <code>map</code> 中插入数据时，如果对应的 <code>key</code> 已经存在，不会更新数据。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>lm</code> 可以显示模块信息（包括已经卸载的模块信息），<code>lmm dll*</code> 可以显示以 <code>dll</code> 开头的模块</li><li><code>map.insert()</code> 在插入新数据时，如果发现对应的 <code>key</code> 已经存在，会直接返回 <code>false</code>，而不会更新数据。<code>operator []</code> 会强制更新数据</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在前面两篇文章中，应该算是彻底理清了项目中存在的两个问题。感兴趣的小伙伴儿可以参考&lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1&quot;&gt;《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》&lt;/a&gt;和 &lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2&quot;&gt;《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在上篇文章的末尾提到一种情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果在 &lt;code&gt;LoadDlls.exe&lt;/code&gt; 中也显式加载了 &lt;code&gt;dll3.dll&lt;/code&gt;，还会不会崩溃呢？答案是&lt;strong&gt;可能崩溃，也可能不崩溃&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;RegisterInitCallback()&lt;/code&gt;内部更新数据时使用的是 &lt;code&gt;map.insert()&lt;/code&gt;，这会导致一个问题 —— 如果 &lt;code&gt;map&lt;/code&gt; 中已经存在相同的 &lt;code&gt;key&lt;/code&gt;，那么 &lt;code&gt;insert()&lt;/code&gt; 会失败，不会更新数据。&lt;/p&gt;
&lt;p&gt;试想，如果显式加载 &lt;code&gt;dll3.dll&lt;/code&gt; 成功，但是 &lt;code&gt;dll3.dll&lt;/code&gt; 的基址变了。&lt;code&gt;map&lt;/code&gt; 中保存的还是旧的无效地址，而不是新函数地址。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;dll3.dll&lt;/code&gt; 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常&lt;strong&gt;“幸运”&lt;/strong&gt;的正常运行。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文通过实战来验证上文中的结论，什么情况下会崩溃，什么情况下不崩溃。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="全局变量" scheme="https://bianchengnan.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
</feed>
